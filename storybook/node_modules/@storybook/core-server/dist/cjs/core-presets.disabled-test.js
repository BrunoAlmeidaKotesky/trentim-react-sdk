"use strict";

require("jest-specific-snapshot");

var _path = _interopRequireDefault(require("path"));

var _fs = require("fs");

var _os = _interopRequireDefault(require("os"));

var _util = require("util");

var _coreCommon = require("@storybook/core-common");

var _builderWebpack = require("@storybook/builder-webpack5");

var _builderManager = require("@storybook/builder-manager");

var _readPkgUp = require("read-pkg-up");

var _buildDev = require("./build-dev");

var _buildStatic = require("./build-static");

var _outputStats = require("./utils/output-stats");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _global = global,
    SNAPSHOT_OS = _global.SNAPSHOT_OS;
var mkdtemp = (0, _util.promisify)(_fs.mkdtemp);

var _readUpSync = (0, _readPkgUp.sync)({
  cwd: __dirname
}),
    packageJson = _readUpSync.packageJson; // this only applies to this file


jest.setTimeout(10000); // FIXME: this doesn't work

jest.mock('webpack', function () {
  var value = jest.fn(function () {
    return false;
  });
  var actual = jest.requireActual('webpack');
  Object.keys(actual).forEach(function (key) {
    value[key] = actual[key];
  });
  return value;
});
jest.mock('@storybook/telemetry', function () {
  return {
    getStorybookMetadata: jest.fn(function () {
      return {};
    }),
    telemetry: jest.fn(function () {
      return {};
    })
  };
});
jest.mock('fs-extra', function () {
  return {
    copy: jest.fn(function () {
      return undefined;
    }),
    emptyDir: jest.fn(function () {
      return undefined;
    }),
    ensureDir: jest.fn(function () {
      return true;
    }),
    ensureFile: jest.fn(function () {
      return undefined;
    }),
    pathExists: jest.fn(function () {
      return true;
    }),
    readFile: jest.fn(function (f) {
      return '';
    }),
    readJSON: jest.fn(function () {
      return {};
    }),
    remove: jest.fn(function () {
      return undefined;
    }),
    writeFile: jest.fn(function () {
      return undefined;
    }),
    writeJSON: jest.fn(function () {
      return undefined;
    })
  };
});
jest.mock('./utils/StoryIndexGenerator', function () {
  var _jest$requireActual = jest.requireActual('./utils/StoryIndexGenerator'),
      StoryIndexGenerator = _jest$requireActual.StoryIndexGenerator;

  return {
    StoryIndexGenerator: class extends StoryIndexGenerator {
      initialize() {
        return Promise.resolve(undefined);
      }

      getIndex() {
        return {
          stories: {},
          v: 3
        };
      }

    }
  };
});
jest.mock('./utils/stories-json', function () {
  return {
    extractStoriesJson: function () {
      return Promise.resolve();
    },
    useStoriesJson: function () {}
  };
}); // we're not in the right directory for auto-title to work, so just
// stub it out

jest.mock('@storybook/store', function () {
  var actualStore = jest.requireActual('@storybook/store');
  return _objectSpread(_objectSpread({}, actualStore), {}, {
    autoTitle: function () {
      return 'auto-title';
    },
    autoTitleFromSpecifier: function () {
      return 'auto-title-from-specifier';
    }
  });
});
jest.mock('http', function () {
  return _objectSpread(_objectSpread({}, jest.requireActual('http')), {}, {
    createServer: function () {
      return {
        listen: function (_options, cb) {
          return cb();
        },
        on: jest.fn()
      };
    }
  });
});
jest.mock('ws');
jest.mock('@storybook/node-logger', function () {
  return {
    logger: {
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
      line: jest.fn(),
      trace: jest.fn()
    }
  };
});
jest.mock('./utils/output-startup-information', function () {
  return {
    outputStartupInformation: jest.fn()
  };
});
jest.mock('./utils/output-stats');
jest.mock('./utils/open-in-browser', function () {
  return {
    openInBrowser: jest.fn()
  };
});
var cache = (0, _coreCommon.createFileSystemCache)({
  basePath: (0, _coreCommon.resolvePathInStorybookCache)('dev-server'),
  ns: 'storybook-test' // Optional. A grouping namespace for items.

});
var managerOnly = false;
var baseOptions = {
  ignorePreview: managerOnly,
  // FIXME: this should just be ignorePreview everywhere
  managerOnly: managerOnly,
  // production
  docsMode: false,
  cache: cache,
  configDir: _path.default.resolve(`${__dirname}/__for-testing__/`),
  ci: true,
  managerCache: false
};
var ROOT = (0, _coreCommon.getProjectRoot)();
var CWD = process.cwd();
var NODE_MODULES = /.*node_modules/g;

var cleanRoots = function (obj) {
  if (!obj) return obj;
  if (typeof obj === 'string') return obj.replace(CWD, 'CWD').replace(ROOT, 'ROOT').replace(NODE_MODULES, 'NODE_MODULES');
  if (Array.isArray(obj)) return obj.map(cleanRoots);
  if (obj instanceof RegExp) return cleanRoots(obj.toString());

  if (typeof obj === 'object') {
    return Object.fromEntries(Object.entries(obj).map(function ([key, val]) {
      if (key === 'version' && typeof val === 'string') {
        return [key, '*'];
      }

      return [key, cleanRoots(val)];
    }));
  }

  return obj;
};

var getConfig = function (fn, name) {
  var call = fn.mock.calls.find(function (c) {
    return c[0].name === name;
  });

  if (!call) {
    return null;
  }

  return call[0];
};

var prepareSnap = function (get, name) {
  var config = getConfig(get(), name);

  if (!config) {
    return null;
  }

  var keys = Object.keys(config);
  var module = config.module,
      entry = config.entry,
      plugins = config.plugins;
  return cleanRoots({
    keys: keys,
    module: module,
    entry: entry,
    plugins: plugins.map(function (p) {
      return p.constructor.name;
    })
  });
};

var snap = function (name) {
  return `__snapshots__/${name}`;
}; // FIXME: we no longer have test cases
// eslint-disable-next-line jest/no-disabled-tests


describe.skip('FIXME', function () {
  describe.each([[]])('%s', function (example) {
    describe.each([['manager', _builderManager.executor], ['preview', _builderWebpack.executor]])('%s', function (component, executor) {
      beforeEach(async function () {
        jest.clearAllMocks();
        await cache.clear();
      });
      it.each([['prod', _buildStatic.buildStaticStandalone], ['dev', _buildDev.buildDevStandalone]])('%s', async function (mode, builder) {
        var options = _objectSpread(_objectSpread({}, baseOptions), {}, {
          configDir: _path.default.resolve(`${__dirname}/../../../examples/${example}/.storybook`),
          // Only add an outputDir in production mode.
          outputDir: mode === 'prod' ? await mkdtemp(_path.default.join(_os.default.tmpdir(), 'storybook-static-')) : undefined,
          ignorePreview: component === 'manager',
          managerCache: component === 'preview',
          packageJson: packageJson
        });

        await builder(options);
        var config = prepareSnap(executor.get, component);
        expect(config).toMatchSpecificSnapshot(snap(`${example}_${component}-${mode}-${SNAPSHOT_OS}`));
      });
    });
  });
});

var progressPlugin = function (config) {
  return config.plugins.find(function (p) {
    return p.constructor.name === 'ProgressPlugin';
  });
};

describe('dev cli flags', function () {
  beforeEach(async function () {
    jest.clearAllMocks();
    await cache.clear();
  });

  var cliOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {
    packageJson: packageJson
  }); // eslint-disable-next-line jest/no-disabled-tests


  it.skip('baseline', async function () {
    await (0, _buildDev.buildDevStandalone)(cliOptions);
    var config = getConfig(_builderWebpack.executor.get, 'preview');
    expect(progressPlugin(config)).toBeTruthy();
  }); // eslint-disable-next-line jest/no-disabled-tests

  it.skip('--quiet', async function () {
    var options = _objectSpread(_objectSpread({}, cliOptions), {}, {
      quiet: true
    });

    await (0, _buildDev.buildDevStandalone)(options);
    var config = getConfig(_builderWebpack.executor.get, 'preview');
    expect(progressPlugin(config)).toBeFalsy();
  });
  it('--webpack-stats-json calls output-stats', async function () {
    await (0, _buildDev.buildDevStandalone)(cliOptions);
    expect(_outputStats.outputStats).not.toHaveBeenCalled();
    await (0, _buildDev.buildDevStandalone)(_objectSpread(_objectSpread({}, cliOptions), {}, {
      webpackStatsJson: '/tmp/dir'
    }));
    expect(_outputStats.outputStats).toHaveBeenCalledWith('/tmp/dir', expect.objectContaining({
      toJson: expect.any(Function)
    }));
  });
  describe.each([['root directory /', '/', "Won't remove directory '/'. Check your outputDir!"], ['empty string ""', '', "Won't remove current directory. Check your outputDir!"]])('Invalid outputDir must throw: %s', function (_, outputDir, expectedErrorMessage) {
    var optionsWithInvalidDir = _objectSpread(_objectSpread({}, cliOptions), {}, {
      outputDir: outputDir
    });

    it('production mode', async function () {
      expect.assertions(1);
      await expect((0, _buildStatic.buildStaticStandalone)(optionsWithInvalidDir)).rejects.toThrow(expectedErrorMessage);
    });
  });
  describe('Invalid staticDir must throw: root directory /', function () {
    var optionsWithInvalidStaticDir = _objectSpread(_objectSpread({}, cliOptions), {}, {
      staticDir: ['/']
    });

    it('production mode', async function () {
      expect.assertions(1);
      await expect((0, _buildStatic.buildStaticStandalone)(optionsWithInvalidStaticDir)).rejects.toThrow("Won't copy root directory. Check your staticDirs!");
    });
  });
});
describe('build cli flags', function () {
  beforeEach(async function () {
    jest.clearAllMocks();
    await cache.clear();
  });

  var cliOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {
    outputDir: `${__dirname}/storybook-static`,
    packageJson: packageJson
  });

  it('does not call output-stats', async function () {
    await (0, _buildStatic.buildStaticStandalone)(cliOptions);
    expect(_outputStats.outputStats).not.toHaveBeenCalled();
  });
  it('--webpack-stats-json calls output-stats', async function () {
    await (0, _buildStatic.buildStaticStandalone)(_objectSpread(_objectSpread({}, cliOptions), {}, {
      webpackStatsJson: '/tmp/dir'
    }));
    expect(_outputStats.outputStats).toHaveBeenCalledWith('/tmp/dir', expect.objectContaining({
      toJson: expect.any(Function)
    }));
  });
});