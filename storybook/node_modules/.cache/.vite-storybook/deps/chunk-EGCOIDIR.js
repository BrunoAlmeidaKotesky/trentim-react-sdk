import {
  Do,
  F,
  Tr,
  jo,
  w
} from "./chunk-ZQ2CAHCN.js";
import {
  isExportStory,
  sanitize,
  storyNameFromExport,
  toId
} from "./chunk-H7VH7ZR2.js";
import {
  dedent
} from "./chunk-6P6QZ5GB.js";
import {
  require_synchronous_promise
} from "./chunk-N442H5QH.js";
import {
  require_lib
} from "./chunk-3OL5LWJI.js";
import {
  i
} from "./chunk-3QDDUDC7.js";
import {
  require_window
} from "./chunk-Z3ID2O7F.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@storybook/client-api/dist/index.mjs
var import_global = __toESM(require_window(), 1);
var import_global2 = __toESM(require_window(), 1);
var import_synchronous_promise = __toESM(require_synchronous_promise(), 1);
var import_global3 = __toESM(require_window(), 1);
var import_qs = __toESM(require_lib(), 1);
var E = class {
  constructor() {
    this.projectAnnotations = { loaders: [], decorators: [], parameters: {}, argsEnhancers: [], argTypesEnhancers: [], args: {}, argTypes: {} }, this.entries = {}, this.csfExports = {};
  }
  importFn(r) {
    return import_synchronous_promise.SynchronousPromise.resolve().then(() => {
      let e = this.csfExports[r];
      if (!e)
        throw new Error(`Unknown path: ${r}`);
      return e;
    });
  }
  getStoryIndex(r) {
    var _a, _b;
    let e = Object.keys(this.csfExports), p = (_b = (_a = this.projectAnnotations.parameters) == null ? void 0 : _a.options) == null ? void 0 : _b.storySort, u = Object.entries(this.entries).map(([s, { type: y, importPath: a, ...d }]) => {
      let i2 = this.csfExports[a], f = r.processCSFFileWithCache(i2, a, i2.default.title), n;
      return y === "story" ? n = r.storyFromCSFFile({ storyId: s, csfFile: f }) : n = { ...d, story: d.name, kind: d.title, componentId: toId(d.componentId || d.title), parameters: { fileName: a } }, [s, n, f.meta.parameters, this.projectAnnotations.parameters];
    }), m;
    try {
      m = Do(u, p, e);
    } catch (s) {
      throw typeof p == "function" ? new Error(dedent`
          Error sorting stories with sort parameter ${p}:

          > ${s.message}
          
          Are you using a V7-style sort function in V6 compatibility mode?
          
          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
        `) : s;
    }
    let o = m.reduce((s, y) => (s[y.id] = this.entries[y.id], s), {});
    return { v: 4, entries: o };
  }
  clearFilenameExports(r) {
    !this.csfExports[r] || (Object.entries(this.entries).forEach(([e, { importPath: p }]) => {
      p === r && delete this.entries[e];
    }), this.csfExports[r] = {});
  }
  addStoriesFromExports(r, e) {
    if (r.match(/\.mdx$/) && !r.match(/\.stories\.mdx$/) || this.csfExports[r] === e)
      return;
    this.clearFilenameExports(r);
    let { default: p, __namedExportsOrder: l, ...u } = e, { id: m, title: o, tags: s = [] } = p || {}, y = (import_global2.default.STORIES || []).map((n) => ({ ...n, importPathMatcher: new RegExp(n.importPathMatcher) }));
    if (o = jo(r, y, o), !o) {
      i.info(`Unexpected default export without title in '${r}': ${JSON.stringify(e.default)}`);
      return;
    }
    this.csfExports[r] = { ...e, default: { ...p, title: o } };
    let a = u;
    Array.isArray(l) && (a = {}, l.forEach((n) => {
      let c = u[n];
      c && (a[n] = c);
    }));
    let d = Object.entries(a).filter(([n]) => isExportStory(n, p)), i2 = import_global2.default.DOCS_OPTIONS || {}, f = i2.docsPage === "automatic" || i2.docsPage && s.includes("docsPage");
    if (i2.enabled && d.length && (s.includes("mdx") || f)) {
      let n = i2.defaultName, c = toId(m || o, n);
      this.entries[c] = { type: "docs", standalone: false, id: c, title: o, name: n, importPath: r, ...m && { componentId: m }, tags: [...s, "docs"], storiesImports: [] };
    }
    d.forEach(([n, c]) => {
      var _a, _b, _c;
      let A = storyNameFromExport(n), S = ((_a = c.parameters) == null ? void 0 : _a.__id) || toId(m || o, A), x = typeof c != "function" && c.name || c.storyName || ((_b = c.story) == null ? void 0 : _b.name) || A;
      ((_c = c.parameters) == null ? void 0 : _c.docsOnly) || (this.entries[S] = { type: "story", id: S, name: x, title: o, importPath: r, ...m && { componentId: m }, tags: [...c.tags || s, "story"] });
    });
  }
};
var h;
var Y = { addDecorator: "Instead, use `export const decorators = [];` in your `preview.js`.", addParameters: "Instead, use `export const parameters = {};` in your `preview.js`.", addLoader: "Instead, use `export const loaders = [];` in your `preview.js`.", addArgs: "", addArgTypes: "", addArgsEnhancer: "", addArgTypesEnhancer: "", addStepRunner: "", getGlobalRender: "", setGlobalRender: "" };
var g = (t) => {
  var _a;
  if ((_a = import_global.default.FEATURES) == null ? void 0 : _a.storyStoreV7)
    throw new Error(dedent`You cannot use \`${t}\` with the new Story Store.

      ${Y[t]}`);
  if (!h)
    throw new Error(`Singleton client API not yet initialized, cannot call \`${t}\`.`);
};
var Q = (t) => {
  g("addDecorator"), h.addDecorator(t);
};
var U = (t) => {
  g("addParameters"), h.addParameters(t);
};
var B = (t) => {
  g("addLoader"), h.addLoader(t);
};
var H = (t) => {
  g("addArgs"), h.addArgs(t);
};
var J = (t) => {
  g("addArgTypes"), h.addArgTypes(t);
};
var W = (t) => {
  g("addArgsEnhancer"), h.addArgsEnhancer(t);
};
var q = (t) => {
  g("addArgTypesEnhancer"), h.addArgTypesEnhancer(t);
};
var K = (t) => {
  g("addStepRunner"), h.addStepRunner(t);
};
var X = (t) => {
  g("setGlobalRender"), h.facade.projectAnnotations.render = t;
};
var Z = /* @__PURE__ */ new Set(["string", "number", "boolean", "symbol"]);
var T = class {
  constructor({ storyStore: r } = {}) {
    this.lastFileName = 0;
    this.addDecorator = (r2) => {
      this.facade.projectAnnotations.decorators.push(r2);
    };
    this.addParameters = ({ globals: r2, globalTypes: e, ...p }) => {
      this.facade.projectAnnotations.parameters = F(this.facade.projectAnnotations.parameters, p), r2 && (this.facade.projectAnnotations.globals = { ...this.facade.projectAnnotations.globals, ...r2 }), e && (this.facade.projectAnnotations.globalTypes = { ...this.facade.projectAnnotations.globalTypes, ...w(e) });
    };
    this.addStepRunner = (r2) => {
      this.facade.projectAnnotations.runStep = Tr([this.facade.projectAnnotations.runStep, r2].filter(Boolean));
    };
    this.addLoader = (r2) => {
      this.facade.projectAnnotations.loaders.push(r2);
    };
    this.addArgs = (r2) => {
      this.facade.projectAnnotations.args = { ...this.facade.projectAnnotations.args, ...r2 };
    };
    this.addArgTypes = (r2) => {
      this.facade.projectAnnotations.argTypes = { ...this.facade.projectAnnotations.argTypes, ...w(r2) };
    };
    this.addArgsEnhancer = (r2) => {
      this.facade.projectAnnotations.argsEnhancers.push(r2);
    };
    this.addArgTypesEnhancer = (r2) => {
      this.facade.projectAnnotations.argTypesEnhancers.push(r2);
    };
    this._addedExports = {};
    this.storiesOf = (r2, e) => {
      if (!r2 && typeof r2 != "string")
        throw new Error("Invalid or missing kind provided for stories, should be a string");
      if (e || i.warn(`Missing 'module' parameter for story with a kind of '${r2}'. It will break your HMR`), e) {
        let a = Object.getPrototypeOf(e);
        a.exports && a.exports.default && i.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${a.i}`);
      }
      let p = e && e.id ? `${e.id}` : (this.lastFileName++).toString(), l = p, u = 1;
      for (; this._addedExports[l]; )
        u += 1, l = `${p}-${u}`;
      e && e.hot && e.hot.accept && (e.hot.accept(), e.hot.dispose(() => {
        this.facade.clearFilenameExports(l), delete this._addedExports[l], setTimeout(() => {
          var _a;
          this._loadAddedExports(), (_a = this.onImportFnChanged) == null ? void 0 : _a.call(this, { importFn: this.importFn.bind(this) });
        }, 0);
      }));
      let m = false, o = { kind: r2.toString(), add: () => o, addDecorator: () => o, addLoader: () => o, addParameters: () => o };
      Object.keys(this.addons).forEach((a) => {
        let d = this.addons[a];
        o[a] = (...i2) => (d.apply(o, i2), o);
      });
      let s = { id: sanitize(r2), title: r2, decorators: [], loaders: [], parameters: {} };
      this._addedExports[l] = { default: s };
      let y = 0;
      return o.add = (a, d, i2 = {}) => {
        if (m = true, typeof a != "string")
          throw new Error(`Invalid or missing storyName provided for a "${r2}" story.`);
        if (!d || Array.isArray(d) || Z.has(typeof d))
          throw new Error(`Cannot load story "${a}" in "${r2}" due to invalid format. Storybook expected a function/object but received ${typeof d} instead.`);
        let { decorators: f, loaders: n, component: c, args: A, argTypes: S, ...x } = i2, P = i2.__id || toId(r2, a), j = this._addedExports[l];
        return j[`story${y}`] = { name: a, parameters: { fileName: l, __id: P, ...x }, decorators: f, loaders: n, args: A, argTypes: S, component: c, render: d }, y += 1, o;
      }, o.addDecorator = (a) => {
        if (m)
          throw new Error(`You cannot add a decorator after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return s.decorators.push(a), o;
      }, o.addLoader = (a) => {
        if (m)
          throw new Error("You cannot add a loader after the first story for a kind.");
        return s.loaders.push(a), o;
      }, o.addParameters = ({ component: a, args: d, argTypes: i2, tags: f, ...n }) => {
        if (m)
          throw new Error(`You cannot add parameters after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return s.parameters = F(s.parameters, n), a && (s.component = a), d && (s.args = { ...s.args, ...d }), i2 && (s.argTypes = { ...s.argTypes, ...i2 }), f && (s.tags = f), o;
      }, o;
    };
    this.raw = () => this.storyStore.raw();
    this.facade = new E(), this.addons = {}, this.storyStore = r, h = this;
  }
  importFn(r) {
    return this.facade.importFn(r);
  }
  getStoryIndex() {
    if (!this.storyStore)
      throw new Error("Cannot get story index before setting storyStore");
    return this.facade.getStoryIndex(this.storyStore);
  }
  _loadAddedExports() {
    Object.entries(this._addedExports).forEach(([r, e]) => this.facade.addStoriesFromExports(r, e));
  }
  get _storyStore() {
    return this.storyStore;
  }
};
var er = () => {
  let { document: t } = import_global3.default;
  return t && t.location && t.location.search ? (0, import_qs.parse)(t.location.search, { ignoreQueryPrefix: true }) : {};
};
var Sr = (t) => er()[t];

export {
  Q,
  U,
  B,
  H,
  J,
  W,
  q,
  K,
  X,
  T,
  er,
  Sr
};
//# sourceMappingURL=chunk-EGCOIDIR.js.map
