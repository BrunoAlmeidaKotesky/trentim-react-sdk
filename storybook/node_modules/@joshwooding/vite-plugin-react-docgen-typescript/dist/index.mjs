import { createFilter } from '@rollup/pluginutils';
import * as docGen from 'react-docgen-typescript';
import * as ts from 'typescript';
import glob from 'glob-promise';
import * as path from 'path';
import path__default from 'path';
import MagicString from 'magic-string';

function createLiteral(value) {
  switch (typeof value) {
    case "string":
      return ts.factory.createStringLiteral(value);
    case "number":
      return ts.factory.createNumericLiteral(value);
    case "boolean":
      return Boolean(value) ? ts.factory.createTrue() : ts.factory.createFalse();
  }
}
function insertTsIgnoreBeforeStatement(statement) {
  ts.setSyntheticLeadingComments(statement, [
    {
      text: " @ts-ignore",
      kind: ts.SyntaxKind.SingleLineCommentTrivia,
      pos: -1,
      end: -1
    }
  ]);
  return statement;
}
function setDisplayName(d) {
  return insertTsIgnoreBeforeStatement(ts.factory.createExpressionStatement(ts.factory.createBinaryExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(d.displayName), ts.factory.createIdentifier("displayName")), ts.SyntaxKind.EqualsToken, ts.factory.createStringLiteral(d.displayName))));
}
function createPropDefinition(propName, prop, options) {
  const setDefaultValue = (defaultValue) => ts.factory.createPropertyAssignment(ts.factory.createStringLiteral("defaultValue"), defaultValue?.value !== void 0 && (typeof defaultValue.value === "string" || typeof defaultValue.value === "number" || typeof defaultValue.value === "boolean") ? ts.factory.createObjectLiteralExpression([
    ts.factory.createPropertyAssignment(ts.factory.createIdentifier("value"), createLiteral(defaultValue.value))
  ]) : ts.factory.createNull());
  const setStringLiteralField = (fieldName, fieldValue) => ts.factory.createPropertyAssignment(ts.factory.createStringLiteral(fieldName), ts.factory.createStringLiteral(fieldValue));
  const setDescription = (description) => setStringLiteralField("description", description);
  const setName = (name) => setStringLiteralField("name", name);
  const setRequired = (required) => ts.factory.createPropertyAssignment(ts.factory.createStringLiteral("required"), required ? ts.factory.createTrue() : ts.factory.createFalse());
  const setValue = (typeValue) => Array.isArray(typeValue) && typeValue.every((value) => typeof value.value === "string") ? ts.factory.createPropertyAssignment(ts.factory.createStringLiteral("value"), ts.factory.createArrayLiteralExpression(typeValue.map((value) => ts.factory.createObjectLiteralExpression([
    setStringLiteralField("value", value.value)
  ])))) : void 0;
  const setType = (typeName, typeValue) => {
    const objectFields = [setStringLiteralField("name", typeName)];
    const valueField = setValue(typeValue);
    if (valueField) {
      objectFields.push(valueField);
    }
    return ts.factory.createPropertyAssignment(ts.factory.createStringLiteral(options.typePropName), ts.factory.createObjectLiteralExpression(objectFields));
  };
  return ts.factory.createPropertyAssignment(ts.factory.createStringLiteral(propName), ts.factory.createObjectLiteralExpression([
    setDefaultValue(prop.defaultValue),
    setDescription(prop.description),
    setName(prop.name),
    setRequired(prop.required),
    setType(prop.type.name, prop.type.value)
  ]));
}
function insertDocgenIntoGlobalCollection(d, docgenCollectionName, relativeFilename) {
  return insertTsIgnoreBeforeStatement(ts.factory.createIfStatement(ts.factory.createBinaryExpression(ts.factory.createTypeOfExpression(ts.factory.createIdentifier(docgenCollectionName)), ts.SyntaxKind.ExclamationEqualsEqualsToken, ts.factory.createStringLiteral("undefined")), insertTsIgnoreBeforeStatement(ts.factory.createExpressionStatement(ts.factory.createBinaryExpression(ts.factory.createElementAccessExpression(ts.factory.createIdentifier(docgenCollectionName), ts.factory.createStringLiteral(`${relativeFilename}#${d.displayName}`)), ts.SyntaxKind.EqualsToken, ts.factory.createObjectLiteralExpression([
    ts.factory.createPropertyAssignment(ts.factory.createIdentifier("docgenInfo"), ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(d.displayName), ts.factory.createIdentifier("__docgenInfo"))),
    ts.factory.createPropertyAssignment(ts.factory.createIdentifier("name"), ts.factory.createStringLiteral(d.displayName)),
    ts.factory.createPropertyAssignment(ts.factory.createIdentifier("path"), ts.factory.createStringLiteral(`${relativeFilename}#${d.displayName}`))
  ]))))));
}
function setComponentDocGen(d, options) {
  return insertTsIgnoreBeforeStatement(ts.factory.createExpressionStatement(ts.factory.createBinaryExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(d.displayName), ts.factory.createIdentifier("__docgenInfo")), ts.SyntaxKind.EqualsToken, ts.factory.createObjectLiteralExpression([
    ts.factory.createPropertyAssignment(ts.factory.createStringLiteral("description"), ts.factory.createStringLiteral(d.description)),
    ts.factory.createPropertyAssignment(ts.factory.createStringLiteral("displayName"), ts.factory.createStringLiteral(d.displayName)),
    ts.factory.createPropertyAssignment(ts.factory.createStringLiteral("props"), ts.factory.createObjectLiteralExpression(Object.entries(d.props).map(([propName, prop]) => createPropDefinition(propName, prop, options))))
  ]))));
}
function generateDocgenCodeBlock(options) {
  const sourceFile = ts.createSourceFile(options.filename, options.source, ts.ScriptTarget.ESNext);
  const relativeFilename = path__default.relative("./", path__default.resolve("./", options.filename)).replace(/\\/g, "/");
  const wrapInTryStatement = (statements) => ts.factory.createTryStatement(ts.factory.createBlock(statements, true), ts.factory.createCatchClause(ts.factory.createVariableDeclaration(ts.factory.createIdentifier("__react_docgen_typescript_loader_error")), ts.factory.createBlock([])), void 0);
  const codeBlocks = options.componentDocs.map((d) => wrapInTryStatement([
    options.setDisplayName ? setDisplayName(d) : null,
    setComponentDocGen(d, options),
    options.docgenCollectionName === null || options.docgenCollectionName === void 0 ? null : insertDocgenIntoGlobalCollection(d, options.docgenCollectionName, relativeFilename)
  ].filter((s2) => s2 !== null)));
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const printNode = (sourceNode) => printer.printNode(ts.EmitHint.Unspecified, sourceNode, sourceFile);
  const s = new MagicString(options.source);
  codeBlocks.forEach((node) => {
    s.append(printNode(node));
  });
  return {
    code: s.toString(),
    map: s.generateMap()
  };
}

function getTSConfigFile(tsconfigPath) {
  try {
    const basePath = path.dirname(tsconfigPath);
    const configFile = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
    return ts.parseJsonConfigFileContent(configFile.config, ts.sys, basePath, {}, tsconfigPath);
  } catch (error) {
    return {};
  }
}
const defaultPropFilter = (prop) => {
  return !prop.parent?.fileName.includes("node_modules");
};
function getOptions(options) {
  const {
    tsconfigPath = "./tsconfig.json",
    compilerOptions: userCompilerOptions,
    docgenCollectionName = "STORYBOOK_REACT_CLASSES",
    setDisplayName = true,
    typePropName = "type",
    propFilter = defaultPropFilter,
    ...docgenOptions
  } = options;
  let compilerOptions = {
    jsx: ts.JsxEmit.React,
    module: ts.ModuleKind.CommonJS,
    target: ts.ScriptTarget.Latest
  };
  if (userCompilerOptions) {
    compilerOptions = {
      ...compilerOptions,
      ...userCompilerOptions
    };
  } else {
    const { options: tsOptions } = getTSConfigFile(tsconfigPath);
    compilerOptions = { ...compilerOptions, ...tsOptions };
  }
  return {
    docgenOptions: {
      propFilter,
      ...docgenOptions
    },
    generateOptions: {
      docgenCollectionName,
      setDisplayName,
      typePropName
    },
    compilerOptions
  };
}
function reactDocgenTypescript(config = {}) {
  const { docgenOptions, compilerOptions, generateOptions } = getOptions(config);
  const docGenParser = docGen.withCompilerOptions(compilerOptions, docgenOptions);
  const { exclude = ["**/**.stories.tsx"], include = ["**/**.tsx"] } = docgenOptions;
  const filter = createFilter(include, exclude);
  const files = include.map((filePath) => glob.sync(path.isAbsolute(filePath) ? filePath : path.join(process.cwd(), filePath))).reduce((carry, files2) => carry.concat(files2), []);
  const tsProgram = ts.createProgram(files, compilerOptions);
  return {
    name: "vite:react-docgen-typescript",
    async transform(src, id) {
      if (!filter(id))
        return;
      const componentDocs = docGenParser.parseWithProgramProvider(id, () => tsProgram);
      if (!componentDocs.length) {
        return null;
      }
      return generateDocgenCodeBlock({
        filename: id,
        source: src,
        componentDocs,
        ...generateOptions
      });
    }
  };
}

export { reactDocgenTypescript as default };
