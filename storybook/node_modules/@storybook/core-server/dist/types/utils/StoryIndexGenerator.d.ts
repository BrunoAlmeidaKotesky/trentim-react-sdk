import type { Addon_IndexEntry, Addon_StandaloneDocsIndexEntry, Addon_StoryIndexEntry, Addon_TemplateDocsIndexEntry, CoreCommon_NormalizedStoriesSpecifier, CoreCommon_StoryIndexer, DocsOptions, Path, Store_StoryIndex } from '@storybook/types';
/** A .mdx file will produce a "standalone" docs entry */
declare type DocsCacheEntry = Addon_StandaloneDocsIndexEntry;
/** A *.stories.* file will produce a list of stories and possibly a docs entry */
declare type StoriesCacheEntry = {
    entries: (Addon_StoryIndexEntry | Addon_TemplateDocsIndexEntry)[];
    dependents: Path[];
    type: 'stories';
};
declare type CacheEntry = false | StoriesCacheEntry | DocsCacheEntry;
/**
 * The StoryIndexGenerator extracts stories and docs entries for each file matching
 * (one or more) stories "specifiers", as defined in main.js.
 *
 * The output is a set of entries (see above for the types).
 *
 * Each file is treated as a stories or a (modern) docs file.
 *
 * A stories file is indexed by an indexer (passed in), which produces a list of stories.
 *   - If the stories have the `parameters.docsOnly` setting, they are disregarded.
 *   - If the indexer is a "docs template" indexer, OR docsPage is enabled,
 *       a templated docs entry is added pointing to the story file.
 *
 * A (modern) docs file is indexed, a standalone docs entry is added.
 *
 * The entries are "uniq"-ed and sorted. Stories entries are preferred to docs entries and
 * standalone docs entries are preferred to templates (with warnings).
 */
export declare class StoryIndexGenerator {
    readonly specifiers: CoreCommon_NormalizedStoriesSpecifier[];
    readonly options: {
        workingDir: Path;
        configDir: Path;
        storiesV2Compatibility: boolean;
        storyStoreV7: boolean;
        storyIndexers: CoreCommon_StoryIndexer[];
        docs: DocsOptions;
    };
    private specifierToCache;
    private lastIndex?;
    constructor(specifiers: CoreCommon_NormalizedStoriesSpecifier[], options: {
        workingDir: Path;
        configDir: Path;
        storiesV2Compatibility: boolean;
        storyStoreV7: boolean;
        storyIndexers: CoreCommon_StoryIndexer[];
        docs: DocsOptions;
    });
    initialize(): Promise<void>;
    /**
     * Run the updater function over all the empty cache entries
     */
    updateExtracted(updater: (specifier: CoreCommon_NormalizedStoriesSpecifier, absolutePath: Path, existingEntry: CacheEntry) => Promise<CacheEntry>, overwrite?: boolean): Promise<void>;
    isDocsMdx(absolutePath: Path): boolean;
    ensureExtracted(): Promise<Addon_IndexEntry[]>;
    findDependencies(absoluteImports: Path[]): StoriesCacheEntry[];
    extractStories(specifier: CoreCommon_NormalizedStoriesSpecifier, absolutePath: Path): Promise<StoriesCacheEntry>;
    extractDocs(specifier: CoreCommon_NormalizedStoriesSpecifier, absolutePath: Path): Promise<false | Addon_StandaloneDocsIndexEntry>;
    chooseDuplicate(firstEntry: Addon_IndexEntry, secondEntry: Addon_IndexEntry): Addon_IndexEntry;
    sortStories(storiesList: Addon_IndexEntry[]): Promise<Record<string, Addon_IndexEntry>>;
    getIndex(): Promise<Store_StoryIndex>;
    invalidate(specifier: CoreCommon_NormalizedStoriesSpecifier, importPath: Path, removed: boolean): void;
    getStorySortParameter(): Promise<any>;
    storyFileNames(): string[];
}
export {};
