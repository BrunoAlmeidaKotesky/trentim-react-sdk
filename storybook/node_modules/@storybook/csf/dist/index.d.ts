import { Simplify, UnionToIntersection } from 'type-fest';

interface SBBaseType {
    required?: boolean;
    raw?: string;
}
declare type SBScalarType = SBBaseType & {
    name: 'boolean' | 'string' | 'number' | 'function' | 'symbol';
};
declare type SBArrayType = SBBaseType & {
    name: 'array';
    value: SBType;
};
declare type SBObjectType = SBBaseType & {
    name: 'object';
    value: Record<string, SBType>;
};
declare type SBEnumType = SBBaseType & {
    name: 'enum';
    value: (string | number)[];
};
declare type SBIntersectionType = SBBaseType & {
    name: 'intersection';
    value: SBType[];
};
declare type SBUnionType = SBBaseType & {
    name: 'union';
    value: SBType[];
};
declare type SBOtherType = SBBaseType & {
    name: 'other';
    value: string;
};
declare type SBType = SBScalarType | SBEnumType | SBArrayType | SBObjectType | SBIntersectionType | SBUnionType | SBOtherType;

declare type StoryId = string;
declare type ComponentId = string;
declare type ComponentTitle = string;
declare type StoryName = string;
/** @deprecated */
declare type StoryKind = ComponentTitle;
declare type Tag = string;
interface StoryIdentifier {
    componentId: ComponentId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    id: StoryId;
    name: StoryName;
    /** @deprecated */
    story: StoryName;
    tags: Tag[];
}
declare type Parameters = {
    [name: string]: any;
};
declare type ConditionalTest = {
    truthy?: boolean;
} | {
    exists: boolean;
} | {
    eq: any;
} | {
    neq: any;
};
declare type ConditionalValue = {
    arg: string;
} | {
    global: string;
};
declare type Conditional = ConditionalValue & ConditionalTest;
interface InputType {
    name?: string;
    description?: string;
    defaultValue?: any;
    type?: SBType | SBScalarType['name'];
    if?: Conditional;
    [key: string]: any;
}
interface StrictInputType extends InputType {
    name: string;
    type?: SBType;
}
declare type Args = {
    [name: string]: any;
};
declare type ArgTypes<TArgs = Args> = {
    [name in keyof TArgs]: InputType;
};
declare type StrictArgTypes<TArgs = Args> = {
    [name in keyof TArgs]: StrictInputType;
};
declare type Globals = {
    [name: string]: any;
};
declare type GlobalTypes = {
    [name: string]: InputType;
};
declare type StrictGlobalTypes = {
    [name: string]: StrictInputType;
};
declare type Framework = {
    /** What does is the type of the `component` annotation in this framework? */
    component: unknown;
    /** What does the story function return in this framework? */
    storyResult: unknown;
    /** What type of element does this framework render to? */
    canvasElement: unknown;
    T?: unknown;
};
/** @deprecated - use `Framework` */
declare type AnyFramework = Framework;
declare type StoryContextForEnhancers<TFramework extends Framework = Framework, TArgs = Args> = StoryIdentifier & {
    component?: (TFramework & {
        T: any;
    })['component'];
    subcomponents?: Record<string, (TFramework & {
        T: any;
    })['component']>;
    parameters: Parameters;
    initialArgs: TArgs;
    argTypes: StrictArgTypes<TArgs>;
};
declare type ArgsEnhancer<TFramework extends Framework = Framework, TArgs = Args> = (context: StoryContextForEnhancers<TFramework, TArgs>) => TArgs;
declare type ArgTypesEnhancer<TFramework extends Framework = Framework, TArgs = Args> = ((context: StoryContextForEnhancers<TFramework, TArgs>) => StrictArgTypes<TArgs>) & {
    secondPass?: boolean;
};
declare type StoryContextUpdate<TArgs = Args> = {
    args?: TArgs;
    globals?: Globals;
    [key: string]: any;
};
declare type ViewMode = 'story' | 'docs';
declare type StoryContextForLoaders<TFramework extends Framework = Framework, TArgs = Args> = StoryContextForEnhancers<TFramework, TArgs> & Required<StoryContextUpdate<TArgs>> & {
    hooks: unknown;
    viewMode: ViewMode;
    originalStoryFn: StoryFn<TFramework>;
};
declare type LoaderFunction<TFramework extends Framework = Framework, TArgs = Args> = (context: StoryContextForLoaders<TFramework, TArgs>) => Promise<Record<string, any>>;
declare type StoryContext<TFramework extends Framework = Framework, TArgs = Args> = StoryContextForLoaders<TFramework, TArgs> & {
    loaded: Record<string, any>;
    abortSignal: AbortSignal;
    canvasElement: TFramework['canvasElement'];
};
declare type StepLabel = string;
declare type StepFunction<TFramework extends Framework = Framework, TArgs = Args> = (label: StepLabel, play: PlayFunction<TFramework, TArgs>) => Promise<void> | void;
declare type PlayFunctionContext<TFramework extends Framework = Framework, TArgs = Args> = StoryContext<TFramework, TArgs> & {
    step: StepFunction<TFramework, TArgs>;
};
declare type PlayFunction<TFramework extends Framework = Framework, TArgs = Args> = (context: PlayFunctionContext<TFramework, TArgs>) => Promise<void> | void;
declare type PartialStoryFn<TFramework extends Framework = Framework, TArgs = Args> = (update?: StoryContextUpdate<Partial<TArgs>>) => TFramework['storyResult'];
declare type LegacyStoryFn<TFramework extends Framework = Framework, TArgs = Args> = (context: StoryContext<TFramework, TArgs>) => TFramework['storyResult'];
declare type ArgsStoryFn<TFramework extends Framework = Framework, TArgs = Args> = (args: TArgs, context: StoryContext<TFramework, TArgs>) => (TFramework & {
    T: TArgs;
})['storyResult'];
declare type StoryFn<TFramework extends Framework = Framework, TArgs = Args> = LegacyStoryFn<TFramework, TArgs> | ArgsStoryFn<TFramework, TArgs>;
declare type DecoratorFunction<TFramework extends Framework = Framework, TArgs = Args> = (fn: PartialStoryFn<TFramework, TArgs>, c: StoryContext<TFramework, TArgs>) => TFramework['storyResult'];
declare type DecoratorApplicator<TFramework extends Framework = Framework, TArgs = Args> = (storyFn: LegacyStoryFn<TFramework, TArgs>, decorators: DecoratorFunction<TFramework, TArgs>[]) => LegacyStoryFn<TFramework, TArgs>;
declare type StepRunner<TFramework extends Framework = Framework, TArgs = Args> = (label: StepLabel, play: PlayFunction<TFramework, TArgs>, context: PlayFunctionContext<TFramework, TArgs>) => Promise<void>;
declare type BaseAnnotations<TFramework extends Framework = Framework, TArgs = Args> = {
    /**
     * Wrapper components or Storybook decorators that wrap a story.
     *
     * Decorators defined in Meta will be applied to every story variation.
     * @see [Decorators](https://storybook.js.org/docs/addons/introduction/#1-decorators)
     */
    decorators?: DecoratorFunction<TFramework, TArgs>[];
    /**
     * Custom metadata for a story.
     * @see [Parameters](https://storybook.js.org/docs/basics/writing-stories/#parameters)
     */
    parameters?: Parameters;
    /**
     * Dynamic data that are provided (and possibly updated by) Storybook and its addons.
     * @see [Arg story inputs](https://storybook.js.org/docs/react/api/csf#args-story-inputs)
     */
    args?: Partial<TArgs>;
    /**
     * ArgTypes encode basic metadata for args, such as `name`, `description`, `defaultValue` for an arg. These get automatically filled in by Storybook Docs.
     * @see [Control annotations](https://github.com/storybookjs/storybook/blob/91e9dee33faa8eff0b342a366845de7100415367/addons/controls/README.md#control-annotations)
     */
    argTypes?: Partial<ArgTypes<TArgs>>;
    /**
     * Asynchronous functions which provide data for a story.
     * @see [Loaders](https://storybook.js.org/docs/react/writing-stories/loaders)
     */
    loaders?: LoaderFunction<TFramework, TArgs>[];
    /**
     * Define a custom render function for the story(ies). If not passed, a default render function by the framework will be used.
     */
    render?: ArgsStoryFn<TFramework, TArgs>;
};
declare type ProjectAnnotations<TFramework extends Framework = Framework, TArgs = Args> = BaseAnnotations<TFramework, TArgs> & {
    argsEnhancers?: ArgsEnhancer<TFramework, Args>[];
    argTypesEnhancers?: ArgTypesEnhancer<TFramework, Args>[];
    globals?: Globals;
    globalTypes?: GlobalTypes;
    applyDecorators?: DecoratorApplicator<TFramework, Args>;
    runStep?: StepRunner<TFramework, TArgs>;
};
declare type StoryDescriptor$1 = string[] | RegExp;
interface ComponentAnnotations<TFramework extends Framework = Framework, TArgs = Args> extends BaseAnnotations<TFramework, TArgs> {
    /**
     * Title of the component which will be presented in the navigation. **Should be unique.**
     *
     * Components can be organized in a nested structure using "/" as a separator.
     *
     * Since CSF 3.0 this property is optional -- it can be inferred from the filesystem path
     *
     * @example
     * export default {
     *   ...
     *   title: 'Design System/Atoms/Button'
     * }
     *
     * @see [Story Hierarchy](https://storybook.js.org/docs/basics/writing-stories/#story-hierarchy)
     */
    title?: ComponentTitle;
    /**
     * Id of the component (prefix of the story id) which is used for URLs.
     *
     * By default is inferred from sanitizing the title
     *
     * @see [Story Hierarchy](https://storybook.js.org/docs/basics/writing-stories/#story-hierarchy)
     */
    id?: ComponentId;
    /**
     * Used to only include certain named exports as stories. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * includeStories: ['SimpleStory', 'ComplexStory']
     * includeStories: /.*Story$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    includeStories?: StoryDescriptor$1;
    /**
     * Used to exclude certain named exports. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * excludeStories: ['simpleData', 'complexData']
     * excludeStories: /.*Data$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    excludeStories?: StoryDescriptor$1;
    /**
     * The primary component for your story.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     */
    component?: (TFramework & {
        T: Args extends TArgs ? any : TArgs;
    })['component'];
    /**
     * Auxiliary subcomponents that are part of the stories.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     *
     * @example
     * import { Button, ButtonGroup } from './components';
     *
     * export default {
     *   ...
     *   subcomponents: { Button, ButtonGroup }
     * }
     *
     * By defining them each component will have its tab in the args table.
     */
    subcomponents?: Record<string, TFramework['component']>;
    /**
     * Function that is executed after the story is rendered.
     */
    play?: PlayFunction<TFramework, TArgs>;
    /**
     * Named tags for a story, used to filter stories in different contexts.
     */
    tags?: Tag[];
}
declare type StoryAnnotations<TFramework extends Framework = Framework, TArgs = Args, TRequiredArgs = Partial<TArgs>> = BaseAnnotations<TFramework, TArgs> & {
    /**
     * Override the display name in the UI (CSF v3)
     */
    name?: StoryName;
    /**
     * Override the display name in the UI (CSF v2)
     */
    storyName?: StoryName;
    /**
     * Function that is executed after the story is rendered.
     */
    play?: PlayFunction<TFramework, TArgs>;
    /**
     * Named tags for a story, used to filter stories in different contexts.
     */
    tags?: Tag[];
    /** @deprecated */
    story?: Omit<StoryAnnotations<TFramework, TArgs>, 'story'>;
} & ({} extends TRequiredArgs ? {
    args?: TRequiredArgs;
} : {
    args: TRequiredArgs;
});
declare type LegacyAnnotatedStoryFn<TFramework extends Framework = Framework, TArgs = Args> = StoryFn<TFramework, TArgs> & StoryAnnotations<TFramework, TArgs>;
declare type LegacyStoryAnnotationsOrFn<TFramework extends Framework = Framework, TArgs = Args> = LegacyAnnotatedStoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>;
declare type AnnotatedStoryFn<TFramework extends Framework = Framework, TArgs = Args> = ArgsStoryFn<TFramework, TArgs> & StoryAnnotations<TFramework, TArgs>;
declare type StoryAnnotationsOrFn<TFramework extends Framework = Framework, TArgs = Args> = AnnotatedStoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>;
declare type ArgsFromMeta<TFramework extends Framework, Meta> = Meta extends {
    render?: ArgsStoryFn<TFramework, infer RArgs>;
    loaders?: (infer Loaders)[];
    decorators?: (infer Decorators)[];
} ? Simplify<RArgs & DecoratorsArgs<TFramework, Decorators> & LoaderArgs<TFramework, Loaders>> : unknown;
declare type DecoratorsArgs<TFramework extends Framework, Decorators> = UnionToIntersection<Decorators extends DecoratorFunction<TFramework, infer TArgs> ? TArgs : unknown>;
declare type LoaderArgs<TFramework extends Framework, Loaders> = UnionToIntersection<Loaders extends LoaderFunction<TFramework, infer TArgs> ? TArgs : unknown>;

/**
 * Helper function to include/exclude an arg based on the value of other other args
 * aka "conditional args"
 */
declare const includeConditionalArg: (argType: InputType, args: Args, globals: Globals) => boolean;

/**
 * Remove punctuation and illegal characters from a story ID.
 *
 * See https://gist.github.com/davidjrice/9d2af51100e41c6c4b4a
 */
declare const sanitize: (string: string) => string;
/**
 * Generate a storybook ID from a component/kind and story name.
 */
declare const toId: (kind: string, name?: string) => string;
/**
 * Transform a CSF named export into a readable story name
 */
declare const storyNameFromExport: (key: string) => string;
declare type StoryDescriptor = string[] | RegExp;
interface IncludeExcludeOptions {
    includeStories?: StoryDescriptor;
    excludeStories?: StoryDescriptor;
}
/**
 * Does a named export match CSF inclusion/exclusion options?
 */
declare function isExportStory(key: string, { includeStories, excludeStories }: IncludeExcludeOptions): boolean | null;
interface SeparatorOptions {
    rootSeparator: string | RegExp;
    groupSeparator: string | RegExp;
}
/**
 * Parse out the component/kind name from a path, using the given separator config.
 */
declare const parseKind: (kind: string, { rootSeparator, groupSeparator }: SeparatorOptions) => {
    root: string | null;
    groups: string[];
};

export { AnnotatedStoryFn, AnyFramework, ArgTypes, ArgTypesEnhancer, Args, ArgsEnhancer, ArgsFromMeta, ArgsStoryFn, BaseAnnotations, ComponentAnnotations, ComponentId, ComponentTitle, Conditional, DecoratorApplicator, DecoratorFunction, Framework, GlobalTypes, Globals, IncludeExcludeOptions, InputType, LegacyAnnotatedStoryFn, LegacyStoryAnnotationsOrFn, LegacyStoryFn, LoaderFunction, Parameters, PartialStoryFn, PlayFunction, PlayFunctionContext, ProjectAnnotations, SBArrayType, SBEnumType, SBIntersectionType, SBObjectType, SBOtherType, SBScalarType, SBType, SBUnionType, SeparatorOptions, StepFunction, StepLabel, StepRunner, StoryAnnotations, StoryAnnotationsOrFn, StoryContext, StoryContextForEnhancers, StoryContextForLoaders, StoryContextUpdate, StoryFn, StoryId, StoryIdentifier, StoryKind, StoryName, StrictArgTypes, StrictGlobalTypes, StrictInputType, Tag, ViewMode, includeConditionalArg, isExportStory, parseKind, sanitize, storyNameFromExport, toId };
