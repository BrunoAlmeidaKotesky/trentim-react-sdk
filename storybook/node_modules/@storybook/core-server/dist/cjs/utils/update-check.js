"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createUpdateMessage = createUpdateMessage;
exports.updateCheck = void 0;

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _chalk = _interopRequireDefault(require("chalk"));

var _nodeLogger = require("@storybook/node-logger");

var _semver = _interopRequireDefault(require("semver"));

var _tsDedent = require("ts-dedent");

var _coreCommon = require("@storybook/core-common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _process$env = process.env,
    _process$env$STORYBOO = _process$env.STORYBOOK_VERSION_BASE,
    STORYBOOK_VERSION_BASE = _process$env$STORYBOO === void 0 ? 'https://storybook.js.org' : _process$env$STORYBOO,
    CI = _process$env.CI;

var updateCheck = async function (version) {
  var result;
  var time = Date.now();

  try {
    var fromCache = await _coreCommon.cache.get('lastUpdateCheck', {
      success: false,
      time: 0
    }); // if last check was more then 24h ago

    if (time - 86400000 > fromCache.time && !CI) {
      var fromFetch = await Promise.race([(0, _nodeFetch.default)(`${STORYBOOK_VERSION_BASE}/versions.json?current=${version}`), // if fetch is too slow, we won't wait for it
      new Promise(function (res, rej) {
        return global.setTimeout(rej, 1500);
      })]);
      var data = await fromFetch.json();
      result = {
        success: true,
        cached: false,
        data: data,
        time: time
      };
      await _coreCommon.cache.set('lastUpdateCheck', result);
    } else {
      result = _objectSpread(_objectSpread({}, fromCache), {}, {
        cached: true
      });
    }
  } catch (error) {
    result = {
      success: false,
      cached: false,
      error: error,
      time: time
    };
  }

  return result;
};

exports.updateCheck = updateCheck;

function createUpdateMessage(updateInfo, version) {
  var updateMessage;

  try {
    var suffix = _semver.default.prerelease(updateInfo.data.latest.version) ? '--prerelease' : '';
    var upgradeCommand = `npx storybook@latest upgrade ${suffix}`.trim();
    updateMessage = updateInfo.success && _semver.default.lt(version, updateInfo.data.latest.version) ? (0, _tsDedent.dedent)`
          ${_nodeLogger.colors.orange(`A new version (${_chalk.default.bold(updateInfo.data.latest.version)}) is available!`)}

          ${_chalk.default.gray('Upgrade now:')} ${_nodeLogger.colors.green(upgradeCommand)}

          ${_chalk.default.gray('Read full changelog:')} ${_chalk.default.gray.underline('https://github.com/storybookjs/storybook/blob/next/CHANGELOG.md')}
        ` : '';
  } catch (e) {
    updateMessage = '';
  }

  return updateMessage;
}