class y {
  constructor(e, r, t, s) {
    this.blob = e, this.byteArrays = r, this.mimeType = t, this.fileName = s;
  }
  getBlob() {
    return this.blob;
  }
  getFile() {
    return new File([this.getBlob()], this == null ? void 0 : this.fileName, { type: this == null ? void 0 : this.mimeType });
  }
  getByteArray() {
    return this.byteArrays;
  }
}
async function m(b, e, r = null) {
  try {
    const t = await fetch(b, r).then((l) => l.blob());
    return new File(
      [t],
      e.fileName,
      {
        type: e == null ? void 0 : e.fileMime,
        lastModified: (e == null ? void 0 : e.lastModified) || new Date().getTime()
      }
    );
  } catch (t) {
    return console.error(t == null ? void 0 : t.message), null;
  }
}
const i = async (b, e) => {
  var t;
  const r = (t = e == null ? void 0 : e.readAs) != null ? t : "DataURL";
  try {
    return new Promise((s, l) => {
      const n = new FileReader();
      n.onloadend = async () => {
        const a = n == null ? void 0 : n.result;
        if (a || l(new Error("[TRS] - FileReader error on blobToBase64")), e != null && e.customCb) {
          const o = await (e == null ? void 0 : e.customCb(a));
          return s(o);
        } else {
          const o = /^data:.+;base64,/;
          return s(a == null ? void 0 : a.replace(o, ""));
        }
      }, n.onerror = (a) => l(a), e != null && e.encoding ? n[`readAs${r}`](b) : n[`readAs${r}`](b, e == null ? void 0 : e.encoding);
    });
  } catch (s) {
    return console.log(s), null;
  }
};
function w(b, e, r) {
  r = r || this.checkIfHasMime(e);
  let t = 512, s = atob(decodeURIComponent(b)), l = [];
  for (let a = 0; a < s.length; a += t) {
    let o = s == null ? void 0 : s.slice(a, a + t), h = new Array(o.length);
    for (let u = 0; u < o.length; u++)
      h[u] = o.charCodeAt(u);
    let d = new Uint8Array(h);
    l.push(d);
  }
  const n = r ? new Blob(l, { type: r }) : new Blob(l);
  return new y(n, l, r, e);
}
export {
  y as C,
  i as b,
  w as c,
  m as u
};
