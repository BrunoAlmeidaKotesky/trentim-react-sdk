import {
  t
} from "./chunk-VN7B5P5J.js";
import {
  I,
  P,
  U,
  g,
  u,
  y
} from "./chunk-M3XCZAQ7.js";
import {
  r
} from "./chunk-EF2YLWYO.js";
import {
  i
} from "./chunk-3QDDUDC7.js";
import {
  require_window
} from "./chunk-Z3ID2O7F.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@storybook/addons/dist/index.mjs
var import_global = __toESM(require_window(), 1);
var import_global2 = __toESM(require_window(), 1);
function T() {
  let r2 = { setHandler: () => {
  }, send: () => {
  } };
  return new r({ transport: r2 });
}
function J(r2) {
  return !!Object.values(t).find((e) => e === r2);
}
var y2 = class {
  constructor() {
    this.loaders = {};
    this.elements = {};
    this.config = {};
    this.getChannel = () => (this.channel || this.setChannel(T()), this.channel);
    this.getServerChannel = () => {
      if (!this.serverChannel)
        throw new Error("Accessing non-existent serverChannel");
      return this.serverChannel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.hasServerChannel = () => !!this.serverChannel;
    this.setChannel = (e) => {
      this.channel = e, this.resolve();
    };
    this.setServerChannel = (e) => {
      this.serverChannel = e;
    };
    this.getElements = (e) => (this.elements[e] || (this.elements[e] = {}), this.elements[e]);
    this.addPanel = (e, t2) => {
      this.add(e, { type: t.PANEL, ...t2 });
    };
    this.add = (e, t2) => {
      let { type: n } = t2, o = this.getElements(n);
      o[e] = { id: e, ...t2 };
    };
    this.setConfig = (e) => {
      Object.assign(this.config, e), this.hasChannel() && this.getChannel().emit(I, e);
    };
    this.getConfig = () => this.config;
    this.register = (e, t2) => {
      this.loaders[e] && i.warn(`${e} was loaded twice, this could have bad side-effects`), this.loaders[e] = t2;
    };
    this.loadAddons = (e) => {
      Object.values(this.loaders).forEach((t2) => t2(e));
    };
    this.promise = new Promise((e) => {
      this.resolve = () => e(this.getChannel());
    });
  }
};
var k = "__STORYBOOK_ADDONS";
function R() {
  return import_global.default[k] || (import_global.default[k] = new y2()), import_global.default[k];
}
var c = R();
var V = ({ name: r2, parameterName: e, wrapper: t2, skipIfNoParametersOrOptions: n = false }) => {
  let o = (s) => (a, i2) => {
    let d = i2.parameters && i2.parameters[e];
    return d && d.disable || n && !s && !d ? a(i2) : t2(a, i2, { options: s, parameters: d });
  };
  return (...s) => typeof s[0] == "function" ? o()(...s) : (...a) => {
    if (a.length > 1)
      return s.length > 1 ? o(s)(...a) : o(...s)(...a);
    throw new Error(`Passing stories directly into ${r2}() is not allowed,
        instead use addDecorator(${r2}) and pass options with the '${e}' parameter`);
  };
};
var x = class {
  constructor() {
    this.renderListener = (e) => {
      e === this.currentContext.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = this.mountedDecorators, this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((e) => {
      e.destroy && e.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let e = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, e;
  }
  triggerEffects() {
    this.prevEffects.forEach((e) => {
      !this.currentEffects.includes(e) && e.destroy && e.destroy();
    }), this.currentEffects.forEach((e) => {
      this.prevEffects.includes(e) || (e.destroy = e.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), c.getChannel().on(U, this.renderListener);
  }
  removeRenderListeners() {
    c.getChannel().removeListener(U, this.renderListener);
  }
};
function C(r2) {
  return (...e) => {
    let { hooks: t2 } = typeof e[0] == "function" ? e[1] : e[0], n = t2.currentPhase, o = t2.currentHooks, s = t2.nextHookIndex, a = t2.currentDecoratorName;
    t2.currentDecoratorName = r2.name, t2.prevMountedDecorators.has(r2) ? (t2.currentPhase = "UPDATE", t2.currentHooks = t2.hookListsMap.get(r2) || []) : (t2.currentPhase = "MOUNT", t2.currentHooks = [], t2.hookListsMap.set(r2, t2.currentHooks), t2.prevMountedDecorators.add(r2)), t2.nextHookIndex = 0;
    let i2 = import_global2.default.STORYBOOK_HOOKS_CONTEXT;
    import_global2.default.STORYBOOK_HOOKS_CONTEXT = t2;
    let d = r2(...e);
    if (import_global2.default.STORYBOOK_HOOKS_CONTEXT = i2, t2.currentPhase === "UPDATE" && t2.getNextHook() != null)
      throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    return t2.currentPhase = n, t2.currentHooks = o, t2.nextHookIndex = s, t2.currentDecoratorName = a, d;
  };
}
var S = 0;
var M = 25;
var ne = (r2) => (e, t2) => {
  let n = r2(C(e), t2.map((o) => C(o)));
  return (o) => {
    let { hooks: s } = o;
    s.prevMountedDecorators = s.mountedDecorators, s.mountedDecorators = /* @__PURE__ */ new Set([e, ...t2]), s.currentContext = o, s.hasUpdates = false;
    let a = n(o);
    for (S = 1; s.hasUpdates; )
      if (s.hasUpdates = false, s.currentEffects = [], a = n(o), S += 1, S > M)
        throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");
    return s.addRenderListeners(), a;
  };
};
var U2 = (r2, e) => r2.length === e.length && r2.every((t2, n) => t2 === e[n]);
var g2 = () => new Error("Storybook preview hooks can only be called inside decorators and story functions.");
function O() {
  return import_global2.default.STORYBOOK_HOOKS_CONTEXT || null;
}
function A() {
  let r2 = O();
  if (r2 == null)
    throw g2();
  return r2;
}
function $(r2, e, t2) {
  let n = A();
  if (n.currentPhase === "MOUNT") {
    t2 != null && !Array.isArray(t2) && i.warn(`${r2} received a final argument that is not an array (instead, received ${t2}). When specified, the final argument must be an array.`);
    let o = { name: r2, deps: t2 };
    return n.currentHooks.push(o), e(o), o;
  }
  if (n.currentPhase === "UPDATE") {
    let o = n.getNextHook();
    if (o == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return o.name !== r2 && i.warn(`Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`), t2 != null && o.deps == null && i.warn(`${r2} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`), t2 != null && o.deps != null && t2.length !== o.deps.length && i.warn(`The final argument passed to ${r2} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${t2}`), (t2 == null || o.deps == null || !U2(t2, o.deps)) && (e(o), o.deps = t2), o;
  }
  throw g2();
}
function p(r2, e, t2) {
  let { memoizedState: n } = $(r2, (o) => {
    o.memoizedState = e();
  }, t2);
  return n;
}
function se(r2, e) {
  return p("useMemo", r2, e);
}
function f(r2, e) {
  return p("useCallback", () => r2, e);
}
function b(r2, e) {
  return p(r2, () => ({ current: e }), []);
}
function ae(r2) {
  return b("useRef", r2);
}
function K() {
  let r2 = O();
  if (r2 != null && r2.currentPhase !== "NONE")
    r2.hasUpdates = true;
  else
    try {
      c.getChannel().emit(P);
    } catch {
      i.warn("State updates of Storybook preview hooks work only in browser");
    }
}
function F(r2, e) {
  let t2 = b(r2, typeof e == "function" ? e() : e), n = (o) => {
    t2.current = typeof o == "function" ? o(t2.current) : o, K();
  };
  return [t2.current, n];
}
function ie(r2) {
  return F("useState", r2);
}
function ce(r2, e, t2) {
  let n = t2 != null ? () => t2(e) : e, [o, s] = F("useReducer", n);
  return [o, (i2) => s((d) => r2(d, i2))];
}
function Y(r2, e) {
  let t2 = A(), n = p("useEffect", () => ({ create: r2 }), e);
  t2.currentEffects.includes(n) || t2.currentEffects.push(n);
}
function de(r2, e = []) {
  let t2 = c.getChannel();
  return Y(() => (Object.entries(r2).forEach(([n, o]) => t2.on(n, o)), () => {
    Object.entries(r2).forEach(([n, o]) => t2.removeListener(n, o));
  }), [...Object.keys(r2), ...e]), f(t2.emit.bind(t2), [t2]);
}
function v() {
  let { currentContext: r2 } = A();
  if (r2 == null)
    throw g2();
  return r2;
}
function ue(r2, e) {
  var _a;
  let { parameters: t2 } = v();
  if (r2)
    return (_a = t2[r2]) != null ? _a : e;
}
function he() {
  let r2 = c.getChannel(), { id: e, args: t2 } = v(), n = f((s) => r2.emit(y, { storyId: e, updatedArgs: s }), [r2, e]), o = f((s) => r2.emit(g, { storyId: e, argNames: s }), [r2, e]);
  return [t2, n, o];
}
function le() {
  let r2 = c.getChannel(), { globals: e } = v(), t2 = f((n) => r2.emit(u, { globals: n }), [r2]);
  return [e, t2];
}
var me = c;

export {
  T,
  J,
  y2 as y,
  c,
  V,
  x,
  ne,
  se,
  f,
  ae,
  ie,
  ce,
  Y,
  de,
  v,
  ue,
  he,
  le,
  me
};
//# sourceMappingURL=chunk-UACHQL3Y.js.map
