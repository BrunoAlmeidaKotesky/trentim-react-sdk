import { FileSystemCache } from 'file-system-cache';
import { TransformOptions } from '@babel/core';
import { Router } from 'express';
import { Server } from 'http';

/**
Matches any [primitive value](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).

@category Type
*/
type Primitive =
	| null
	| undefined
	| string
	| number
	| boolean
	| symbol
	| bigint;

declare global {
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
@see Simplify
*/
interface SimplifyOptions {
	/**
	Do the simplification recursively.

	@default false
	*/
	deep?: boolean;
}

// Flatten a type without worrying about the result.
type Flatten<
	AnyType,
	Options extends SimplifyOptions = {},
> = Options['deep'] extends true
	? {[KeyType in keyof AnyType]: Simplify<AnyType[KeyType], Options>}
	: {[KeyType in keyof AnyType]: AnyType[KeyType]};

/**
Useful to flatten the type output to improve type hints shown in editors. And also to transform an interface into a type to aide with assignability.

@example
```
import type {Simplify} from 'type-fest';

type PositionProps = {
	top: number;
	left: number;
};

type SizeProps = {
	width: number;
	height: number;
};

// In your editor, hovering over `Props` will show a flattened object with all the properties.
type Props = Simplify<PositionProps & SizeProps>;
```

Sometimes it is desired to pass a value as a function argument that has a different type. At first inspection it may seem assignable, and then you discover it is not because the `value`'s type definition was defined as an interface. In the following example, `fn` requires an argument of type `Record<string, unknown>`. If the value is defined as a literal, then it is assignable. And if the `value` is defined as type using the `Simplify` utility the value is assignable.  But if the `value` is defined as an interface, it is not assignable because the interface is not sealed and elsewhere a non-string property could be added to the interface.

If the type definition must be an interface (perhaps it was defined in a third-party npm package), then the `value` can be defined as `const value: Simplify<SomeInterface> = ...`. Then `value` will be assignable to the `fn` argument.  Or the `value` can be cast as `Simplify<SomeInterface>` if you can't re-declare the `value`.

@example
```
import type {Simplify} from 'type-fest';

interface SomeInterface {
	foo: number;
	bar?: string;
	baz: number | undefined;
}

type SomeType = {
	foo: number;
	bar?: string;
	baz: number | undefined;
};

const literal = {foo: 123, bar: 'hello', baz: 456};
const someType: SomeType = literal;
const someInterface: SomeInterface = literal;

function fn(object: Record<string, unknown>): void {}

fn(literal); // Good: literal object type is sealed
fn(someType); // Good: type is sealed
fn(someInterface); // Error: Index signature for type 'string' is missing in type 'someInterface'. Because `interface` can be re-opened
fn(someInterface as Simplify<SomeInterface>); // Good: transform an `interface` into a `type`
```

@link https://github.com/microsoft/TypeScript/issues/15300

@category Object
*/
type Simplify<
	AnyType,
	Options extends SimplifyOptions = {},
> = Flatten<AnyType> extends AnyType
	? Flatten<AnyType, Options>
	: AnyType;

/**
Allows creating a union type by combining primitive types and literal types without sacrificing auto-completion in IDEs for the literal type part of the union.

Currently, when a union type of a primitive type is combined with literal types, TypeScript loses all information about the combined literals. Thus, when such type is used in an IDE with autocompletion, no suggestions are made for the declared literals.

This type is a workaround for [Microsoft/TypeScript#29729](https://github.com/Microsoft/TypeScript/issues/29729). It will be removed as soon as it's not needed anymore.

@example
```
import type {LiteralUnion} from 'type-fest';

// Before

type Pet = 'dog' | 'cat' | string;

const pet: Pet = '';
// Start typing in your TypeScript-enabled IDE.
// You **will not** get auto-completion for `dog` and `cat` literals.

// After

type Pet2 = LiteralUnion<'dog' | 'cat', string>;

const pet: Pet2 = '';
// You **will** get auto-completion for `dog` and `cat` literals.
```

@category Type
*/
type LiteralUnion<
	LiteralType,
	BaseType extends Primitive,
> = LiteralType | (BaseType & Record<never, never>);

/**
Convert a union type to an intersection type using [distributive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).

Inspired by [this Stack Overflow answer](https://stackoverflow.com/a/50375286/2172153).

@example
```
import type {UnionToIntersection} from 'type-fest';

type Union = {the(): void} | {great(arg: string): void} | {escape: boolean};

type Intersection = UnionToIntersection<Union>;
//=> {the(): void; great(arg: string): void; escape: boolean};
```

A more applicable example which could make its way into your library code follows.

@example
```
import type {UnionToIntersection} from 'type-fest';

class CommandOne {
	commands: {
		a1: () => undefined,
		b1: () => undefined,
	}
}

class CommandTwo {
	commands: {
		a2: (argA: string) => undefined,
		b2: (argB: string) => undefined,
	}
}

const union = [new CommandOne(), new CommandTwo()].map(instance => instance.commands);
type Union = typeof union;
//=> {a1(): void; b1(): void} | {a2(argA: string): void; b2(argB: string): void}

type Intersection = UnionToIntersection<Union>;
//=> {a1(): void; b1(): void; a2(argA: string): void; b2(argB: string): void}
```

@category Type
*/
type UnionToIntersection<Union> = (
	// `extends unknown` is always going to be the case and is used to convert the
	// `Union` into a [distributive conditional
	// type](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).
	Union extends unknown
		// The union type is used as the only argument to a function since the union
		// of function arguments is an intersection.
		? (distributedUnion: Union) => void
		// This won't happen.
		: never
		// Infer the `Intersection` type since TypeScript represents the positional
		// arguments of unions of functions as an intersection of the union.
	) extends ((mergedIntersection: infer Intersection) => void)
		? Intersection
		: never;

declare namespace PackageJson$1 {
	/**
	A person who has been involved in creating or maintaining the package.
	*/
	export type Person =
		| string
		| {
			name: string;
			url?: string;
			email?: string;
		};

	export type BugsLocation =
		| string
		| {
			/**
			The URL to the package's issue tracker.
			*/
			url?: string;

			/**
			The email address to which issues should be reported.
			*/
			email?: string;
		};

	export interface DirectoryLocations {
		[directoryType: string]: unknown;

		/**
		Location for executable scripts. Sugar to generate entries in the `bin` property by walking the folder.
		*/
		bin?: string;

		/**
		Location for Markdown files.
		*/
		doc?: string;

		/**
		Location for example scripts.
		*/
		example?: string;

		/**
		Location for the bulk of the library.
		*/
		lib?: string;

		/**
		Location for man pages. Sugar to generate a `man` array by walking the folder.
		*/
		man?: string;

		/**
		Location for test files.
		*/
		test?: string;
	}

	export type Scripts = {
		/**
		Run **before** the package is published (Also run on local `npm install` without any arguments).
		*/
		prepublish?: string;

		/**
		Run both **before** the package is packed and published, and on local `npm install` without any arguments. This is run **after** `prepublish`, but **before** `prepublishOnly`.
		*/
		prepare?: string;

		/**
		Run **before** the package is prepared and packed, **only** on `npm publish`.
		*/
		prepublishOnly?: string;

		/**
		Run **before** a tarball is packed (on `npm pack`, `npm publish`, and when installing git dependencies).
		*/
		prepack?: string;

		/**
		Run **after** the tarball has been generated and moved to its final destination.
		*/
		postpack?: string;

		/**
		Run **after** the package is published.
		*/
		publish?: string;

		/**
		Run **after** the package is published.
		*/
		postpublish?: string;

		/**
		Run **before** the package is installed.
		*/
		preinstall?: string;

		/**
		Run **after** the package is installed.
		*/
		install?: string;

		/**
		Run **after** the package is installed and after `install`.
		*/
		postinstall?: string;

		/**
		Run **before** the package is uninstalled and before `uninstall`.
		*/
		preuninstall?: string;

		/**
		Run **before** the package is uninstalled.
		*/
		uninstall?: string;

		/**
		Run **after** the package is uninstalled.
		*/
		postuninstall?: string;

		/**
		Run **before** bump the package version and before `version`.
		*/
		preversion?: string;

		/**
		Run **before** bump the package version.
		*/
		version?: string;

		/**
		Run **after** bump the package version.
		*/
		postversion?: string;

		/**
		Run with the `npm test` command, before `test`.
		*/
		pretest?: string;

		/**
		Run with the `npm test` command.
		*/
		test?: string;

		/**
		Run with the `npm test` command, after `test`.
		*/
		posttest?: string;

		/**
		Run with the `npm stop` command, before `stop`.
		*/
		prestop?: string;

		/**
		Run with the `npm stop` command.
		*/
		stop?: string;

		/**
		Run with the `npm stop` command, after `stop`.
		*/
		poststop?: string;

		/**
		Run with the `npm start` command, before `start`.
		*/
		prestart?: string;

		/**
		Run with the `npm start` command.
		*/
		start?: string;

		/**
		Run with the `npm start` command, after `start`.
		*/
		poststart?: string;

		/**
		Run with the `npm restart` command, before `restart`. Note: `npm restart` will run the `stop` and `start` scripts if no `restart` script is provided.
		*/
		prerestart?: string;

		/**
		Run with the `npm restart` command. Note: `npm restart` will run the `stop` and `start` scripts if no `restart` script is provided.
		*/
		restart?: string;

		/**
		Run with the `npm restart` command, after `restart`. Note: `npm restart` will run the `stop` and `start` scripts if no `restart` script is provided.
		*/
		postrestart?: string;
	} & Partial<Record<string, string>>;

	/**
	Dependencies of the package. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or Git URL.
	*/
	export type Dependency = Partial<Record<string, string>>;

	/**
	Conditions which provide a way to resolve a package entry point based on the environment.
	*/
	export type ExportCondition = LiteralUnion<
		| 'import'
		| 'require'
		| 'node'
		| 'node-addons'
		| 'deno'
		| 'browser'
		| 'electron'
		| 'react-native'
		| 'default',
		string
	>;

	type ExportConditions = {[condition in ExportCondition]: Exports};

	/**
	Entry points of a module, optionally with conditions and subpath exports.
	*/
	export type Exports =
	| null
	| string
	| Array<string | ExportConditions>
	| ExportConditions
	| {[path: string]: Exports}; // eslint-disable-line @typescript-eslint/consistent-indexed-object-style

	/**
	Import map entries of a module, optionally with conditions.
	*/
	export type Imports = { // eslint-disable-line @typescript-eslint/consistent-indexed-object-style
		[key: string]: string | {[key in ExportCondition]: Exports};
	};

	export interface NonStandardEntryPoints {
		/**
		An ECMAScript module ID that is the primary entry point to the program.
		*/
		module?: string;

		/**
		A module ID with untranspiled code that is the primary entry point to the program.
		*/
		esnext?:
		| string
		| {
			[moduleName: string]: string | undefined;
			main?: string;
			browser?: string;
		};

		/**
		A hint to JavaScript bundlers or component tools when packaging modules for client side use.
		*/
		browser?:
		| string
		| Partial<Record<string, string | false>>;

		/**
		Denote which files in your project are "pure" and therefore safe for Webpack to prune if unused.

		[Read more.](https://webpack.js.org/guides/tree-shaking/)
		*/
		sideEffects?: boolean | string[];
	}

	export interface TypeScriptConfiguration {
		/**
		Location of the bundled TypeScript declaration file.
		*/
		types?: string;

		/**
		Version selection map of TypeScript.
		*/
		typesVersions?: Partial<Record<string, Partial<Record<string, string[]>>>>;

		/**
		Location of the bundled TypeScript declaration file. Alias of `types`.
		*/
		typings?: string;
	}

	/**
	An alternative configuration for Yarn workspaces.
	*/
	export interface WorkspaceConfig {
		/**
		An array of workspace pattern strings which contain the workspace packages.
		*/
		packages?: WorkspacePattern[];

		/**
		Designed to solve the problem of packages which break when their `node_modules` are moved to the root workspace directory - a process known as hoisting. For these packages, both within your workspace, and also some that have been installed via `node_modules`, it is important to have a mechanism for preventing the default Yarn workspace behavior. By adding workspace pattern strings here, Yarn will resume non-workspace behavior for any package which matches the defined patterns.

		[Read more](https://classic.yarnpkg.com/blog/2018/02/15/nohoist/)
		*/
		nohoist?: WorkspacePattern[];
	}

	/**
	A workspace pattern points to a directory or group of directories which contain packages that should be included in the workspace installation process.

	The patterns are handled with [minimatch](https://github.com/isaacs/minimatch).

	@example
	`docs` → Include the docs directory and install its dependencies.
	`packages/*` → Include all nested directories within the packages directory, like `packages/cli` and `packages/core`.
	*/
	type WorkspacePattern = string;

	export interface YarnConfiguration {
		/**
		Used to configure [Yarn workspaces](https://classic.yarnpkg.com/docs/workspaces/).

		Workspaces allow you to manage multiple packages within the same repository in such a way that you only need to run `yarn install` once to install all of them in a single pass.

		Please note that the top-level `private` property of `package.json` **must** be set to `true` in order to use workspaces.
		*/
		workspaces?: WorkspacePattern[] | WorkspaceConfig;

		/**
		If your package only allows one version of a given dependency, and you’d like to enforce the same behavior as `yarn install --flat` on the command-line, set this to `true`.

		Note that if your `package.json` contains `"flat": true` and other packages depend on yours (e.g. you are building a library rather than an app), those other packages will also need `"flat": true` in their `package.json` or be installed with `yarn install --flat` on the command-line.
		*/
		flat?: boolean;

		/**
		Selective version resolutions. Allows the definition of custom package versions inside dependencies without manual edits in the `yarn.lock` file.
		*/
		resolutions?: Dependency;
	}

	export interface JSPMConfiguration {
		/**
		JSPM configuration.
		*/
		jspm?: PackageJson$1;
	}

	/**
	Type for [npm's `package.json` file](https://docs.npmjs.com/creating-a-package-json-file). Containing standard npm properties.
	*/
	export interface PackageJsonStandard {
		/**
		The name of the package.
		*/
		name?: string;

		/**
		Package version, parseable by [`node-semver`](https://github.com/npm/node-semver).
		*/
		version?: string;

		/**
		Package description, listed in `npm search`.
		*/
		description?: string;

		/**
		Keywords associated with package, listed in `npm search`.
		*/
		keywords?: string[];

		/**
		The URL to the package's homepage.
		*/
		homepage?: LiteralUnion<'.', string>;

		/**
		The URL to the package's issue tracker and/or the email address to which issues should be reported.
		*/
		bugs?: BugsLocation;

		/**
		The license for the package.
		*/
		license?: string;

		/**
		The licenses for the package.
		*/
		licenses?: Array<{
			type?: string;
			url?: string;
		}>;

		author?: Person;

		/**
		A list of people who contributed to the package.
		*/
		contributors?: Person[];

		/**
		A list of people who maintain the package.
		*/
		maintainers?: Person[];

		/**
		The files included in the package.
		*/
		files?: string[];

		/**
		Resolution algorithm for importing ".js" files from the package's scope.

		[Read more.](https://nodejs.org/api/esm.html#esm_package_json_type_field)
		*/
		type?: 'module' | 'commonjs';

		/**
		The module ID that is the primary entry point to the program.
		*/
		main?: string;

		/**
		Subpath exports to define entry points of the package.

		[Read more.](https://nodejs.org/api/packages.html#subpath-exports)
		*/
		exports?: Exports;

		/**
		Subpath imports to define internal package import maps that only apply to import specifiers from within the package itself.

		[Read more.](https://nodejs.org/api/packages.html#subpath-imports)
		*/
		imports?: Imports;

		/**
		The executable files that should be installed into the `PATH`.
		*/
		bin?:
		| string
		| Partial<Record<string, string>>;

		/**
		Filenames to put in place for the `man` program to find.
		*/
		man?: string | string[];

		/**
		Indicates the structure of the package.
		*/
		directories?: DirectoryLocations;

		/**
		Location for the code repository.
		*/
		repository?:
		| string
		| {
			type: string;
			url: string;

			/**
			Relative path to package.json if it is placed in non-root directory (for example if it is part of a monorepo).

			[Read more.](https://github.com/npm/rfcs/blob/latest/implemented/0010-monorepo-subdirectory-declaration.md)
			*/
			directory?: string;
		};

		/**
		Script commands that are run at various times in the lifecycle of the package. The key is the lifecycle event, and the value is the command to run at that point.
		*/
		scripts?: Scripts;

		/**
		Is used to set configuration parameters used in package scripts that persist across upgrades.
		*/
		config?: Record<string, unknown>;

		/**
		The dependencies of the package.
		*/
		dependencies?: Dependency;

		/**
		Additional tooling dependencies that are not required for the package to work. Usually test, build, or documentation tooling.
		*/
		devDependencies?: Dependency;

		/**
		Dependencies that are skipped if they fail to install.
		*/
		optionalDependencies?: Dependency;

		/**
		Dependencies that will usually be required by the package user directly or via another dependency.
		*/
		peerDependencies?: Dependency;

		/**
		Indicate peer dependencies that are optional.
		*/
		peerDependenciesMeta?: Partial<Record<string, {optional: true}>>;

		/**
		Package names that are bundled when the package is published.
		*/
		bundledDependencies?: string[];

		/**
		Alias of `bundledDependencies`.
		*/
		bundleDependencies?: string[];

		/**
		Engines that this package runs on.
		*/
		engines?: {
			[EngineName in 'npm' | 'node' | string]?: string;
		};

		/**
		@deprecated
		*/
		engineStrict?: boolean;

		/**
		Operating systems the module runs on.
		*/
		os?: Array<LiteralUnion<
		| 'aix'
		| 'darwin'
		| 'freebsd'
		| 'linux'
		| 'openbsd'
		| 'sunos'
		| 'win32'
		| '!aix'
		| '!darwin'
		| '!freebsd'
		| '!linux'
		| '!openbsd'
		| '!sunos'
		| '!win32',
		string
		>>;

		/**
		CPU architectures the module runs on.
		*/
		cpu?: Array<LiteralUnion<
		| 'arm'
		| 'arm64'
		| 'ia32'
		| 'mips'
		| 'mipsel'
		| 'ppc'
		| 'ppc64'
		| 's390'
		| 's390x'
		| 'x32'
		| 'x64'
		| '!arm'
		| '!arm64'
		| '!ia32'
		| '!mips'
		| '!mipsel'
		| '!ppc'
		| '!ppc64'
		| '!s390'
		| '!s390x'
		| '!x32'
		| '!x64',
		string
		>>;

		/**
		If set to `true`, a warning will be shown if package is installed locally. Useful if the package is primarily a command-line application that should be installed globally.

		@deprecated
		*/
		preferGlobal?: boolean;

		/**
		If set to `true`, then npm will refuse to publish it.
		*/
		private?: boolean;

		/**
		A set of config values that will be used at publish-time. It's especially handy to set the tag, registry or access, to ensure that a given package is not tagged with 'latest', published to the global public registry or that a scoped module is private by default.
		*/
		publishConfig?: PublishConfig;

		/**
		Describes and notifies consumers of a package's monetary support information.

		[Read more.](https://github.com/npm/rfcs/blob/latest/accepted/0017-add-funding-support.md)
		*/
		funding?: string | {
			/**
			The type of funding.
			*/
			type?: LiteralUnion<
			| 'github'
			| 'opencollective'
			| 'patreon'
			| 'individual'
			| 'foundation'
			| 'corporation',
			string
			>;

			/**
			The URL to the funding page.
			*/
			url: string;
		};
	}

	export interface PublishConfig {
		/**
		Additional, less common properties from the [npm docs on `publishConfig`](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#publishconfig).
		*/
		[additionalProperties: string]: unknown;

		/**
		When publishing scoped packages, the access level defaults to restricted. If you want your scoped package to be publicly viewable (and installable) set `--access=public`. The only valid values for access are public and restricted. Unscoped packages always have an access level of public.
		*/
		access?: 'public' | 'restricted';

		/**
		The base URL of the npm registry.

		Default: `'https://registry.npmjs.org/'`
		*/
		registry?: string;

		/**
		The tag to publish the package under.

		Default: `'latest'`
		*/
		tag?: string;
	}
}

/**
Type for [npm's `package.json` file](https://docs.npmjs.com/creating-a-package-json-file). Also includes types for fields used by other popular projects, like TypeScript and Yarn.

@category File
*/
type PackageJson$1 =
PackageJson$1.PackageJsonStandard &
PackageJson$1.NonStandardEntryPoints &
PackageJson$1.TypeScriptConfiguration &
PackageJson$1.YarnConfiguration &
PackageJson$1.JSPMConfiguration;

interface SBBaseType {
    required?: boolean;
    raw?: string;
}
declare type SBScalarType = SBBaseType & {
    name: 'boolean' | 'string' | 'number' | 'function' | 'symbol';
};
declare type SBArrayType = SBBaseType & {
    name: 'array';
    value: SBType;
};
declare type SBObjectType = SBBaseType & {
    name: 'object';
    value: Record<string, SBType>;
};
declare type SBEnumType = SBBaseType & {
    name: 'enum';
    value: (string | number)[];
};
declare type SBIntersectionType = SBBaseType & {
    name: 'intersection';
    value: SBType[];
};
declare type SBUnionType = SBBaseType & {
    name: 'union';
    value: SBType[];
};
declare type SBOtherType = SBBaseType & {
    name: 'other';
    value: string;
};
declare type SBType = SBScalarType | SBEnumType | SBArrayType | SBObjectType | SBIntersectionType | SBUnionType | SBOtherType;

declare type StoryId = string;
declare type ComponentId = string;
declare type ComponentTitle = string;
declare type StoryName = string;
/** @deprecated */
declare type StoryKind = ComponentTitle;
declare type Tag = string;
interface StoryIdentifier {
    componentId: ComponentId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    id: StoryId;
    name: StoryName;
    /** @deprecated */
    story: StoryName;
    tags: Tag[];
}
declare type Parameters$1 = {
    [name: string]: any;
};
declare type ConditionalTest = {
    truthy?: boolean;
} | {
    exists: boolean;
} | {
    eq: any;
} | {
    neq: any;
};
declare type ConditionalValue = {
    arg: string;
} | {
    global: string;
};
declare type Conditional = ConditionalValue & ConditionalTest;
interface InputType {
    name?: string;
    description?: string;
    defaultValue?: any;
    type?: SBType | SBScalarType['name'];
    if?: Conditional;
    [key: string]: any;
}
interface StrictInputType extends InputType {
    name: string;
    type?: SBType;
}
declare type Args = {
    [name: string]: any;
};
declare type ArgTypes<TArgs = Args> = {
    [name in keyof TArgs]: InputType;
};
declare type StrictArgTypes<TArgs = Args> = {
    [name in keyof TArgs]: StrictInputType;
};
declare type Globals = {
    [name: string]: any;
};
declare type GlobalTypes = {
    [name: string]: InputType;
};
declare type StrictGlobalTypes = {
    [name: string]: StrictInputType;
};
declare type AnyFramework = {
    component: unknown;
    storyResult: unknown;
    T?: unknown;
};
declare type StoryContextForEnhancers<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = StoryIdentifier & {
    component?: (TFramework & {
        T: any;
    })['component'];
    subcomponents?: Record<string, (TFramework & {
        T: any;
    })['component']>;
    parameters: Parameters$1;
    initialArgs: TArgs;
    argTypes: StrictArgTypes<TArgs>;
};
declare type ArgsEnhancer<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (context: StoryContextForEnhancers<TFramework, TArgs>) => TArgs;
declare type ArgTypesEnhancer<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = ((context: StoryContextForEnhancers<TFramework, TArgs>) => StrictArgTypes<TArgs>) & {
    secondPass?: boolean;
};
declare type StoryContextUpdate<TArgs = Args> = {
    args?: TArgs;
    globals?: Globals;
    [key: string]: any;
};
declare type ViewMode$1 = 'story' | 'docs';
declare type StoryContextForLoaders<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = StoryContextForEnhancers<TFramework, TArgs> & Required<StoryContextUpdate<TArgs>> & {
    hooks: unknown;
    viewMode: ViewMode$1;
    originalStoryFn: StoryFn<TFramework>;
};
declare type LoaderFunction<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (context: StoryContextForLoaders<TFramework, TArgs>) => Promise<Record<string, any>>;
declare type StoryContext<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = StoryContextForLoaders<TFramework, TArgs> & {
    loaded: Record<string, any>;
    abortSignal: AbortSignal;
    canvasElement: HTMLElement;
};
declare type StepLabel = string;
declare type StepFunction<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (label: StepLabel, play: PlayFunction<TFramework, TArgs>) => Promise<void> | void;
declare type PlayFunctionContext<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = StoryContext<TFramework, TArgs> & {
    step: StepFunction<TFramework, TArgs>;
};
declare type PlayFunction<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (context: PlayFunctionContext<TFramework, TArgs>) => Promise<void> | void;
declare type PartialStoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (update?: StoryContextUpdate<Partial<TArgs>>) => TFramework['storyResult'];
declare type LegacyStoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (context: StoryContext<TFramework, TArgs>) => TFramework['storyResult'];
declare type ArgsStoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (args: TArgs, context: StoryContext<TFramework, TArgs>) => (TFramework & {
    T: TArgs;
})['storyResult'];
declare type StoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = LegacyStoryFn<TFramework, TArgs> | ArgsStoryFn<TFramework, TArgs>;
declare type DecoratorFunction<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (fn: PartialStoryFn<TFramework, TArgs>, c: StoryContext<TFramework, TArgs>) => TFramework['storyResult'];
declare type DecoratorApplicator<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (storyFn: LegacyStoryFn<TFramework, TArgs>, decorators: DecoratorFunction<TFramework, TArgs>[]) => LegacyStoryFn<TFramework, TArgs>;
declare type StepRunner<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = (label: StepLabel, play: PlayFunction<TFramework, TArgs>, context: PlayFunctionContext<TFramework, TArgs>) => Promise<void>;
declare type BaseAnnotations<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = {
    /**
     * Wrapper components or Storybook decorators that wrap a story.
     *
     * Decorators defined in Meta will be applied to every story variation.
     * @see [Decorators](https://storybook.js.org/docs/addons/introduction/#1-decorators)
     */
    decorators?: DecoratorFunction<TFramework, TArgs>[];
    /**
     * Custom metadata for a story.
     * @see [Parameters](https://storybook.js.org/docs/basics/writing-stories/#parameters)
     */
    parameters?: Parameters$1;
    /**
     * Dynamic data that are provided (and possibly updated by) Storybook and its addons.
     * @see [Arg story inputs](https://storybook.js.org/docs/react/api/csf#args-story-inputs)
     */
    args?: Partial<TArgs>;
    /**
     * ArgTypes encode basic metadata for args, such as `name`, `description`, `defaultValue` for an arg. These get automatically filled in by Storybook Docs.
     * @see [Control annotations](https://github.com/storybookjs/storybook/blob/91e9dee33faa8eff0b342a366845de7100415367/addons/controls/README.md#control-annotations)
     */
    argTypes?: Partial<ArgTypes<TArgs>>;
    /**
     * Asynchronous functions which provide data for a story.
     * @see [Loaders](https://storybook.js.org/docs/react/writing-stories/loaders)
     */
    loaders?: LoaderFunction<TFramework, TArgs>[];
    /**
     * Define a custom render function for the story(ies). If not passed, a default render function by the framework will be used.
     */
    render?: ArgsStoryFn<TFramework, TArgs>;
};
declare type ProjectAnnotations<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = BaseAnnotations<TFramework, TArgs> & {
    argsEnhancers?: ArgsEnhancer<TFramework, Args>[];
    argTypesEnhancers?: ArgTypesEnhancer<TFramework, Args>[];
    globals?: Globals;
    globalTypes?: GlobalTypes;
    applyDecorators?: DecoratorApplicator<TFramework, Args>;
    runStep?: StepRunner<TFramework, TArgs>;
};
declare type StoryDescriptor$1 = string[] | RegExp;
interface ComponentAnnotations<TFramework extends AnyFramework = AnyFramework, TArgs = Args> extends BaseAnnotations<TFramework, TArgs> {
    /**
     * Title of the component which will be presented in the navigation. **Should be unique.**
     *
     * Components can be organized in a nested structure using "/" as a separator.
     *
     * Since CSF 3.0 this property is optional -- it can be inferred from the filesystem path
     *
     * @example
     * export default {
     *   ...
     *   title: 'Design System/Atoms/Button'
     * }
     *
     * @see [Story Hierarchy](https://storybook.js.org/docs/basics/writing-stories/#story-hierarchy)
     */
    title?: ComponentTitle;
    /**
     * Id of the component (prefix of the story id) which is used for URLs.
     *
     * By default is inferred from sanitizing the title
     *
     * @see [Story Hierarchy](https://storybook.js.org/docs/basics/writing-stories/#story-hierarchy)
     */
    id?: ComponentId;
    /**
     * Used to only include certain named exports as stories. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * includeStories: ['SimpleStory', 'ComplexStory']
     * includeStories: /.*Story$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    includeStories?: StoryDescriptor$1;
    /**
     * Used to exclude certain named exports. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * excludeStories: ['simpleData', 'complexData']
     * excludeStories: /.*Data$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    excludeStories?: StoryDescriptor$1;
    /**
     * The primary component for your story.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     */
    component?: (TFramework & {
        T: Args extends TArgs ? any : TArgs;
    })['component'];
    /**
     * Auxiliary subcomponents that are part of the stories.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     *
     * @example
     * import { Button, ButtonGroup } from './components';
     *
     * export default {
     *   ...
     *   subcomponents: { Button, ButtonGroup }
     * }
     *
     * By defining them each component will have its tab in the args table.
     */
    subcomponents?: Record<string, TFramework['component']>;
    /**
     * Function that is executed after the story is rendered.
     */
    play?: PlayFunction<TFramework, TArgs>;
    /**
     * Named tags for a story, used to filter stories in different contexts.
     */
    tags?: Tag[];
}
declare type StoryAnnotations<TFramework extends AnyFramework = AnyFramework, TArgs = Args, TRequiredArgs = Partial<TArgs>> = BaseAnnotations<TFramework, TArgs> & {
    /**
     * Override the display name in the UI (CSF v3)
     */
    name?: StoryName;
    /**
     * Override the display name in the UI (CSF v2)
     */
    storyName?: StoryName;
    /**
     * Function that is executed after the story is rendered.
     */
    play?: PlayFunction<TFramework, TArgs>;
    /**
     * Named tags for a story, used to filter stories in different contexts.
     */
    tags?: Tag[];
    /** @deprecated */
    story?: Omit<StoryAnnotations<TFramework, TArgs>, 'story'>;
} & ({} extends TRequiredArgs ? {
    args?: TRequiredArgs;
} : {
    args: TRequiredArgs;
});
declare type LegacyAnnotatedStoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = StoryFn<TFramework, TArgs> & StoryAnnotations<TFramework, TArgs>;
declare type LegacyStoryAnnotationsOrFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = LegacyAnnotatedStoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>;
declare type AnnotatedStoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = ArgsStoryFn<TFramework, TArgs> & StoryAnnotations<TFramework, TArgs>;
declare type StoryAnnotationsOrFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = AnnotatedStoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>;
declare type ArgsFromMeta<TFramework extends AnyFramework, Meta> = Meta extends {
    render?: ArgsStoryFn<TFramework, infer RArgs>;
    loaders?: (infer Loaders)[];
    decorators?: (infer Decorators)[];
} ? Simplify<RArgs & DecoratorsArgs<TFramework, Decorators> & LoaderArgs<TFramework, Loaders>> : unknown;
declare type DecoratorsArgs<TFramework extends AnyFramework, Decorators> = UnionToIntersection<Decorators extends DecoratorFunction<TFramework, infer TArgs> ? TArgs : unknown>;
declare type LoaderArgs<TFramework extends AnyFramework, Loaders> = UnionToIntersection<Loaders extends LoaderFunction<TFramework, infer TArgs> ? TArgs : unknown>;
declare type StoryDescriptor = string[] | RegExp;
interface IncludeExcludeOptions {
    includeStories?: StoryDescriptor;
    excludeStories?: StoryDescriptor;
}
interface SeparatorOptions {
    rootSeparator: string | RegExp;
    groupSeparator: string | RegExp;
}

/**
 * A URL pathname, beginning with a /.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
 */
declare type Pathname = string;
/**
 * A URL search string, beginning with a ?.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
 */
declare type Search = string;
/**
 * A URL fragment identifier, beginning with a #.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
 */
declare type Hash = string;
/**
 * A unique string associated with a location. May be used to safely store
 * and retrieve data in some other storage API, like `localStorage`.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
 */
declare type Key = string;
/**
 * The pathname, search, and hash values of a URL.
 */
interface Path$1 {
    /**
     * A URL pathname, beginning with a /.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
     */
    pathname: Pathname;
    /**
     * A URL search string, beginning with a ?.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
     */
    search: Search;
    /**
     * A URL fragment identifier, beginning with a #.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
     */
    hash: Hash;
}
/**
 * An entry in a history stack. A location contains information about the
 * URL path, as well as possibly some arbitrary state and a key.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location
 */
interface Location extends Path$1 {
    /**
     * A value of arbitrary data associated with this location.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.state
     */
    state: unknown;
    /**
     * A unique string associated with this location. May be used to safely store
     * and retrieve data in some other storage API, like `localStorage`.
     *
     * Note: This value is always "default" on the initial location.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
     */
    key: Key;
}

interface StoryData {
    viewMode?: string;
    storyId?: string;
    refId?: string;
}

interface Other extends StoryData {
    path: string;
    singleStory?: boolean;
}
declare type RouterData = {
    location: Partial<Location>;
    navigate: ReturnType<typeof useNavigate>;
} & Other;
declare type RenderData = Pick<RouterData, 'location'> & Other;
declare const useNavigate: () => (to: string | number, { plain, ...options }?: any) => void;

interface ThemeVars {
    base: 'light' | 'dark';
    colorPrimary?: string;
    colorSecondary?: string;
    appBg?: string;
    appContentBg?: string;
    appBorderColor?: string;
    appBorderRadius?: number;
    fontBase?: string;
    fontCode?: string;
    textColor?: string;
    textInverseColor?: string;
    textMutedColor?: string;
    barTextColor?: string;
    barSelectedColor?: string;
    barBg?: string;
    buttonBg?: string;
    buttonBorder?: string;
    booleanBg?: string;
    booleanSelectedBg?: string;
    inputBg?: string;
    inputBorder?: string;
    inputTextColor?: string;
    inputBorderRadius?: number;
    brandTitle?: string;
    brandUrl?: string;
    brandImage?: string;
    brandTarget?: string;
    gridCellSize?: number;
}

declare type Addon_Types = Addon_TypesEnum | string;
interface Addon_ArgType<TArg = unknown> extends InputType {
    defaultValue?: TArg;
}
declare type Addons_ArgTypes<TArgs = Args> = {
    [key in keyof Partial<TArgs>]: Addon_ArgType<TArgs[key]>;
} & {
    [key in string]: Addon_ArgType<unknown>;
};
declare type Addon_Comparator<T> = ((a: T, b: T) => boolean) | ((a: T, b: T) => number);
declare type Addon_StorySortMethod = 'configure' | 'alphabetical';
interface Addon_StorySortObjectParameter {
    method?: Addon_StorySortMethod;
    order?: any[];
    locales?: string;
    includeNames?: boolean;
}
interface Addon_BaseIndexEntry {
    id: StoryId;
    name: StoryName;
    title: ComponentTitle;
    tags?: Tag[];
    importPath: Path;
}
declare type Addon_StoryIndexEntry = Addon_BaseIndexEntry & {
    type: 'story';
};
declare type Addon_DocsIndexEntry = Addon_BaseIndexEntry & {
    storiesImports: Path[];
    type: 'docs';
    standalone: boolean;
};
/** A StandaloneDocsIndexExtry represents a file who's default export is directly renderable */
declare type Addon_StandaloneDocsIndexEntry = Addon_DocsIndexEntry & {
    standalone: true;
};
/** A TemplateDocsIndexEntry represents a stories file that gets rendered in "docs" mode */
declare type Addon_TemplateDocsIndexEntry = Addon_DocsIndexEntry & {
    standalone: false;
};
declare type Addon_IndexEntry = Addon_StoryIndexEntry | Addon_DocsIndexEntry;
declare type Addon_IndexEntryLegacy = [StoryId, any, Parameters, Parameters];
declare type Addon_StorySortComparator = Addon_Comparator<Addon_IndexEntryLegacy>;
declare type Addon_StorySortParameter = Addon_StorySortComparator | Addon_StorySortObjectParameter;
declare type Addon_StorySortComparatorV7 = Addon_Comparator<Addon_IndexEntry>;
declare type Addon_StorySortParameterV7 = Addon_StorySortComparatorV7 | Addon_StorySortObjectParameter;
interface Addon_OptionsParameter extends Object {
    storySort?: Addon_StorySortParameter;
    theme?: {
        base: string;
        brandTitle?: string;
    };
    [key: string]: any;
}
declare type Addon_StoryContext<TFramework extends AnyFramework = AnyFramework> = StoryContext<TFramework>;
declare type Addon_StoryContextUpdate = Partial<Addon_StoryContext>;
declare type Addon_ReturnTypeFramework<ReturnType> = {
    component: any;
    storyResult: ReturnType;
};
declare type Addon_PartialStoryFn<ReturnType = unknown> = PartialStoryFn<Addon_ReturnTypeFramework<ReturnType>>;
declare type Addon_LegacyStoryFn<ReturnType = unknown> = LegacyStoryFn<Addon_ReturnTypeFramework<ReturnType>>;
declare type Addon_ArgsStoryFn<ReturnType = unknown> = ArgsStoryFn<Addon_ReturnTypeFramework<ReturnType>>;
declare type Addon_StoryFn<ReturnType = unknown> = StoryFn<Addon_ReturnTypeFramework<ReturnType>>;
declare type Addon_DecoratorFunction<StoryFnReturnType = unknown> = DecoratorFunction<Addon_ReturnTypeFramework<StoryFnReturnType>>;
declare type Addon_LoaderFunction = LoaderFunction<Addon_ReturnTypeFramework<unknown>>;
interface Addon_WrapperSettings {
    options: object;
    parameters: {
        [key: string]: any;
    };
}
declare type Addon_StoryWrapper = (storyFn: Addon_LegacyStoryFn, context: Addon_StoryContext, settings: Addon_WrapperSettings) => any;
declare type Addon_MakeDecoratorResult = (...args: any) => any;
interface Addon_AddStoryArgs<StoryFnReturnType = unknown> {
    id: StoryId;
    kind: StoryKind;
    name: StoryName;
    storyFn: Addon_StoryFn<StoryFnReturnType>;
    parameters: Parameters;
}
interface Addon_ClientApiAddon<StoryFnReturnType = unknown> extends Addon_Type {
    apply: (a: Addon_StoryApi<StoryFnReturnType>, b: any[]) => any;
}
interface Addon_ClientApiAddons<StoryFnReturnType> {
    [key: string]: Addon_ClientApiAddon<StoryFnReturnType>;
}
declare type Addon_ClientApiReturnFn<StoryFnReturnType = unknown> = (...args: any[]) => Addon_StoryApi<StoryFnReturnType>;
interface Addon_StoryApi<StoryFnReturnType = unknown> {
    kind: StoryKind;
    add: (storyName: StoryName, storyFn: Addon_StoryFn<StoryFnReturnType>, parameters?: Parameters) => Addon_StoryApi<StoryFnReturnType>;
    addDecorator: (decorator: Addon_DecoratorFunction<StoryFnReturnType>) => Addon_StoryApi<StoryFnReturnType>;
    addLoader: (decorator: Addon_LoaderFunction) => Addon_StoryApi<StoryFnReturnType>;
    addParameters: (parameters: Parameters) => Addon_StoryApi<StoryFnReturnType>;
    [k: string]: string | Addon_ClientApiReturnFn<StoryFnReturnType>;
}
interface Addon_ClientStoryApi<StoryFnReturnType = unknown> {
    storiesOf(kind: StoryKind, module: any): Addon_StoryApi<StoryFnReturnType>;
}
declare type Addon_LoadFn = () => any;
declare type Addon_RequireContext = any;
declare type Addon_Loadable = Addon_RequireContext | [Addon_RequireContext] | Addon_LoadFn;
declare type Addon_BaseDecorators<StoryFnReturnType> = Array<(story: () => StoryFnReturnType, context: Addon_StoryContext) => StoryFnReturnType>;
interface Addon_BaseAnnotations<TArgs, StoryFnReturnType> {
    /**
     * Dynamic data that are provided (and possibly updated by) Storybook and its addons.
     * @see [Arg story inputs](https://storybook.js.org/docs/react/api/csf#args-story-inputs)
     */
    args?: Partial<TArgs>;
    /**
     * ArgTypes encode basic metadata for args, such as `name`, `description`, `defaultValue` for an arg. These get automatically filled in by Storybook Docs.
     * @see [Control annotations](https://github.com/storybookjs/storybook/blob/91e9dee33faa8eff0b342a366845de7100415367/addons/controls/README.md#control-annotations)
     */
    argTypes?: Addons_ArgTypes<TArgs>;
    /**
     * Custom metadata for a story.
     * @see [Parameters](https://storybook.js.org/docs/basics/writing-stories/#parameters)
     */
    parameters?: Parameters;
    /**
     * Wrapper components or Storybook decorators that wrap a story.
     *
     * Decorators defined in Meta will be applied to every story variation.
     * @see [Decorators](https://storybook.js.org/docs/addons/introduction/#1-decorators)
     */
    decorators?: Addon_BaseDecorators<StoryFnReturnType>;
    /**
     * Define a custom render function for the story(ies). If not passed, a default render function by the framework will be used.
     */
    render?: (args: TArgs, context: Addon_StoryContext) => StoryFnReturnType;
    /**
     * Function that is executed after the story is rendered.
     */
    play?: (context: Addon_StoryContext) => Promise<void> | void;
}
interface Addon_Annotations<TArgs, StoryFnReturnType> extends Addon_BaseAnnotations<TArgs, StoryFnReturnType> {
    /**
     * Used to only include certain named exports as stories. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * includeStories: ['SimpleStory', 'ComplexStory']
     * includeStories: /.*Story$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    includeStories?: string[] | RegExp;
    /**
     * Used to exclude certain named exports. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * excludeStories: ['simpleData', 'complexData']
     * excludeStories: /.*Data$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    excludeStories?: string[] | RegExp;
}
interface Addon_BaseMeta<ComponentType> {
    /**
     * Title of the story which will be presented in the navigation. **Should be unique.**
     *
     * Stories can be organized in a nested structure using "/" as a separator.
     *
     * Since CSF 3.0 this property is optional.
     *
     * @example
     * export default {
     *   ...
     *   title: 'Design System/Atoms/Button'
     * }
     *
     * @see [Story Hierarchy](https://storybook.js.org/docs/basics/writing-stories/#story-hierarchy)
     */
    title?: string;
    /**
     * Manually set the id of a story, which in particular is useful if you want to rename stories without breaking permalinks.
     *
     * Storybook will prioritize the id over the title for ID generation, if provided, and will prioritize the story.storyName over the export key for display.
     *
     * @see [Sidebar and URLs](https://storybook.js.org/docs/react/configure/sidebar-and-urls#permalinking-to-stories)
     */
    id?: string;
    /**
     * The primary component for your story.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     */
    component?: ComponentType;
    /**
     * Auxiliary subcomponents that are part of the stories.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     *
     * @example
     * import { Button, ButtonGroup } from './components';
     *
     * export default {
     *   ...
     *   subcomponents: { Button, ButtonGroup }
     * }
     *
     * By defining them each component will have its tab in the args table.
     */
    subcomponents?: Record<string, ComponentType>;
}
declare type Addon_BaseStoryObject<TArgs, StoryFnReturnType> = {
    /**
     * Override the display name in the UI
     */
    storyName?: string;
};
declare type Addon_BaseStoryFn<TArgs, StoryFnReturnType> = {
    (args: TArgs, context: Addon_StoryContext): StoryFnReturnType;
} & Addon_BaseStoryObject<TArgs, StoryFnReturnType>;
declare type BaseStory<TArgs, StoryFnReturnType> = Addon_BaseStoryFn<TArgs, StoryFnReturnType> | Addon_BaseStoryObject<TArgs, StoryFnReturnType>;
interface Addon_RenderOptions {
    active?: boolean;
    key?: string;
}
interface Addon_Type {
    title: (() => string) | string;
    type?: Addon_Types;
    id?: string;
    route?: (routeOptions: RenderData) => string;
    match?: (matchOptions: RenderData) => boolean;
    render: (renderOptions: Addon_RenderOptions) => any | null;
    paramKey?: string;
    disabled?: boolean;
    hidden?: boolean;
}
declare type Addon_Loader<API> = (api: API) => void;
interface Addon_Loaders<API> {
    [key: string]: Addon_Loader<API>;
}
interface Addon_Collection {
    [key: string]: Addon_Type;
}
interface Addon_Elements {
    [key: string]: Addon_Collection;
}
interface Addon_ToolbarConfig {
    hidden?: boolean;
}
interface Addon_Config {
    theme?: ThemeVars;
    toolbar?: {
        [id: string]: Addon_ToolbarConfig;
    };
    [key: string]: any;
}
declare enum Addon_TypesEnum {
    TAB = "tab",
    PANEL = "panel",
    TOOL = "tool",
    TOOLEXTRA = "toolextra",
    PREVIEW = "preview",
    NOTES_ELEMENT = "notes-element"
}

interface CSF_Meta {
    id?: string;
    title?: string;
    component?: string;
    includeStories?: string[] | RegExp;
    excludeStories?: string[] | RegExp;
    tags?: Tag[];
}
interface CSF_Story {
    id: string;
    name: string;
    parameters: Parameters;
    tags?: Tag[];
}
declare type ViewMode = ViewMode$1 | 'story' | 'info' | 'settings' | string | undefined;
declare type Layout = 'centered' | 'fullscreen' | 'padded' | 'none';
interface Parameters extends Parameters$1 {
    fileName?: string;
    options?: Addon_OptionsParameter;
    /** The layout property defines basic styles added to the preview body where the story is rendered. If you pass 'none', no styles are applied. */
    layout?: Layout;
    docsOnly?: boolean;
    [key: string]: any;
}
declare type Path = string;

type ValueOrPromiseOfValue<T> = T | PromiseLike<T>
type RejectedOutcome = {
  status: "rejected",
  reason: any
}
type FulfilledOutcome<T> = {
  status: "fulfilled",
  value: T
}
type SettledOutcome<T> = FulfilledOutcome<T> | RejectedOutcome

interface SynchronousPromiseConstructor {
  /**
    * A reference to the prototype.
    */
  prototype: SynchronousPromise<any>;

  /**
    * Creates a new Promise.
    * @param executor A callback used to initialize the promise. This callback is passed two arguments:
    * a resolve callback used resolve the promise with a value or the result of another promise,
    * and a reject callback used to reject the promise with a provided reason or error.
    */
  new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): SynchronousPromise<T>;

  /**
    * Creates a Promise that is resolved with an array of results when all of the provided Promises
    * resolve, or rejected when any Promise is rejected.
    * @param v1 An array of Promises
    * @returns A new Promise.
    */
  all<T>(v1: ValueOrPromiseOfValue<T>[]): SynchronousPromise<T[]>;
  /**
   * Creates a Promise that is resolved with an array of results when all of the provided Promises
   * resolve, or rejected when any Promise is rejected.
   * @param values Any number of Promises.
   * @returns A new Promise.
   */
  all<T>(...values: ValueOrPromiseOfValue<T>[]): SynchronousPromise<T[]>;

  /**
    * Creates a Promise that is resolved with an array of outcome objects after all of the provided Promises
    * have settled. Each outcome object has a .status of either "fulfilled" or "rejected" and corresponding
    * "value" or "reason" properties.
    * @param v1 An array of Promises.
    * @returns A new Promise.
    */
  allSettled<T>(v1: ValueOrPromiseOfValue<T>[]): SynchronousPromise<SettledOutcome<T>[]>;
  /**
   * Creates a Promise that is resolved with an array of outcome objects after all of the provided Promises
   * have settled. Each outcome object has a .status of either "fulfilled" or "rejected" and corresponding
   * "value" or "reason" properties.
   * @param values Any number of promises
   * @returns A new Promise.
   */
  allSettled<TAllSettled>(...values: ValueOrPromiseOfValue<TAllSettled>[]): SynchronousPromise<SettledOutcome<TAllSettled>[]>;

  /**
    * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
    * or rejected.
    * @param values An array of Promises.
    * @returns A new Promise.
    */
  // race<T>(values: IterableShim<T | PromiseLike<T>>): Promise<T>;

  /**
   * Creates a Promise that is resolved with the first value from the provided
   * Promises, or rejected when all provided Promises reject
    * @param v1 An array of Promises
   */
  any<T>(v1: ValueOrPromiseOfValue<T>[]): SynchronousPromise<T>;
  /**
   * Creates a Promise that is resolved with the first value from the provided
   * Promises, or rejected when all provided Promises reject
   * @param values Any number of Promises
   */
  any<T>(...values: ValueOrPromiseOfValue<T>[]): SynchronousPromise<T>;

  /**
    * Creates a new rejected promise for the provided reason.
    * @param reason The reason the promise was rejected.
    * @returns A new rejected Promise.
    */
  reject(reason: any): SynchronousPromise<void>;

  /**
    * Creates a new rejected promise for the provided reason.
    * @param reason The reason the promise was rejected.
    * @returns A new rejected Promise.
    */
  reject<T>(reason: any): SynchronousPromise<T>;

  /**
    * Creates a new resolved promise for the provided value.
    * @param value A promise.
    * @returns A promise whose internal state matches the provided promise.
    */
  resolve<T>(value: T | PromiseLike<T>): SynchronousPromise<T>;

  /**
    * Creates a new resolved promise .
    * @returns A resolved promise.
    */
  resolve(): SynchronousPromise<void>;

  /**
    * Creates a new unresolved promise with the `resolve` and `reject` methods exposed
    * @returns An unresolved promise with the `resolve` and `reject` methods exposed
    */
  unresolved<T>(): UnresolvedSynchronousPromise<T>;


  /**
    * Installs SynchronousPromise as the global Promise implementation.
    * When running from within typescript, you will need to use this to
    * patch the generated __awaiter to ensure it gets a _real_ Promise implementation
    * (see https://github.com/Microsoft/TypeScript/issues/19909).
    *
    * Use the following code:
    * declare var __awaiter: Function;
    * __awaiter = SynchronousPromise.installGlobally();
    *
    * This is non-destructive to the __awaiter: it simply wraps it in a closure
    * where the real implementation of Promise has already been captured.
    */
  installGlobally(__awaiter: Function): Function;

  /*
   * Uninstalls SynchronousPromise as the global Promise implementation,
   * if it is already installed.
   */
  uninstallGlobally(): void;
}

/**
 * Interface type only exposed when using the static unresolved() convenience method
 */
interface UnresolvedSynchronousPromise<T> extends SynchronousPromise<T>  {
  resolve<T>(data: T): void;
  resolve(): void;
  reject<T>(data: T): void;
}interface SynchronousPromise<T> extends Promise<T> {
  pause: () => SynchronousPromise<T>
  resume: () => SynchronousPromise<T>
}

declare var SynchronousPromise: SynchronousPromiseConstructor;

declare type Store_ModuleExport = any;
declare type Store_ModuleExports = Record<string, Store_ModuleExport>;
declare type Store_PromiseLike<T> = Promise<T> | SynchronousPromise<T>;
declare type Store_ModuleImportFn = (path: Path) => Store_PromiseLike<Store_ModuleExports>;
declare type Store_MaybePromise<T> = Promise<T> | T;
declare type Store_TeardownRenderToDOM = () => Store_MaybePromise<void>;
declare type Store_RenderToDOM<TFramework extends AnyFramework> = (context: Store_RenderContext<TFramework>, element: Element) => Store_MaybePromise<void | Store_TeardownRenderToDOM>;
declare type Store_WebProjectAnnotations<TFramework extends AnyFramework> = ProjectAnnotations<TFramework> & {
    renderToDOM?: Store_RenderToDOM<TFramework>;
};
declare type Store_NormalizedProjectAnnotations<TFramework extends AnyFramework = AnyFramework> = ProjectAnnotations<TFramework> & {
    argTypes?: StrictArgTypes;
    globalTypes?: StrictGlobalTypes;
};
declare type Store_NormalizedComponentAnnotations<TFramework extends AnyFramework = AnyFramework> = ComponentAnnotations<TFramework> & {
    id: ComponentId;
    title: ComponentTitle;
    argTypes?: StrictArgTypes;
};
declare type Store_NormalizedStoryAnnotations<TFramework extends AnyFramework = AnyFramework> = Omit<StoryAnnotations<TFramework>, 'storyName' | 'story'> & {
    moduleExport: Store_ModuleExport;
    id: StoryId;
    argTypes?: StrictArgTypes;
    name: StoryName;
    userStoryFn?: StoryFn<TFramework>;
};
declare type Store_CSFFile<TFramework extends AnyFramework = AnyFramework> = {
    meta: Store_NormalizedComponentAnnotations<TFramework>;
    stories: Record<StoryId, Store_NormalizedStoryAnnotations<TFramework>>;
};
declare type Store_Story<TFramework extends AnyFramework = AnyFramework> = StoryContextForEnhancers<TFramework> & {
    moduleExport: Store_ModuleExport;
    originalStoryFn: StoryFn<TFramework>;
    undecoratedStoryFn: LegacyStoryFn<TFramework>;
    unboundStoryFn: LegacyStoryFn<TFramework>;
    applyLoaders: (context: StoryContextForLoaders<TFramework>) => Promise<StoryContextForLoaders<TFramework> & {
        loaded: StoryContext<TFramework>['loaded'];
    }>;
    playFunction?: (context: StoryContext<TFramework>) => Promise<void> | void;
};
declare type Store_BoundStory<TFramework extends AnyFramework = AnyFramework> = Store_Story<TFramework> & {
    storyFn: PartialStoryFn<TFramework>;
};
declare type Store_RenderContext<TFramework extends AnyFramework = AnyFramework> = StoryIdentifier & {
    showMain: () => void;
    showError: (error: {
        title: string;
        description: string;
    }) => void;
    showException: (err: Error) => void;
    forceRemount: boolean;
    storyContext: StoryContext<TFramework>;
    storyFn: PartialStoryFn<TFramework>;
    unboundStoryFn: LegacyStoryFn<TFramework>;
};
interface Store_V2CompatIndexEntry extends Omit<Addon_StoryIndexEntry, 'type'> {
    kind: Addon_StoryIndexEntry['title'];
    story: Addon_StoryIndexEntry['name'];
    parameters: Parameters;
}
interface Store_StoryIndexV3 {
    v: number;
    stories: Record<StoryId, Store_V2CompatIndexEntry>;
}
interface Store_StoryIndex {
    v: number;
    entries: Record<StoryId, Addon_IndexEntry>;
}
declare type Store_StorySpecifier = StoryId | {
    name: StoryName;
    title: ComponentTitle;
} | '*';
interface Store_SelectionSpecifier {
    storySpecifier: Store_StorySpecifier;
    viewMode: ViewMode;
    args?: Args;
    globals?: Args;
}
interface Store_Selection {
    storyId: StoryId;
    viewMode: ViewMode;
}
declare type Store_DecoratorApplicator<TFramework extends AnyFramework = AnyFramework> = (storyFn: LegacyStoryFn<TFramework>, decorators: DecoratorFunction<TFramework>[]) => LegacyStoryFn<TFramework>;
interface Store_StoriesSpecifier {
    directory: string;
    titlePrefix?: string;
}
interface Store_NormalizedStoriesSpecifier {
    glob?: string;
    specifier?: Store_StoriesSpecifier;
}
declare type Store_ExtractOptions = {
    includeDocsOnly?: boolean;
};
interface Store_NormalizedStoriesSpecifierEntry {
    titlePrefix?: string;
    directory: string;
    files?: string;
    importPathMatcher: RegExp;
}
declare type Store_ContextStore<TFramework extends AnyFramework> = {
    value?: StoryContext<TFramework>;
};
declare type Store_PropDescriptor = string[] | RegExp;
declare type Store_CSFExports<TFramework extends AnyFramework = AnyFramework> = {
    default: ComponentAnnotations<TFramework, Args>;
    __esModule?: boolean;
    __namedExportsOrder?: string[];
};
declare type Store_ComposedStoryPlayContext = Partial<StoryContext> & Pick<StoryContext, 'canvasElement'>;
declare type Store_ComposedStoryPlayFn = (context: Store_ComposedStoryPlayContext) => Promise<void> | void;
declare type Store_StoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = AnnotatedStoryFn<TFramework, TArgs> & {
    play: Store_ComposedStoryPlayFn;
};
declare type Store_ComposedStory<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = StoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>;
/**
 * T represents the whole ES module of a stories file. K of T means named exports (basically the Story type)
 * 1. pick the keys K of T that have properties that are Story<AnyProps>
 * 2. infer the actual prop type for each Story
 * 3. reconstruct Story with Partial. Story<Props> -> Story<Partial<Props>>
 */
declare type Store_StoriesWithPartialProps<TFramework extends AnyFramework, TModule> = {
    [K in keyof TModule]: TModule[K] extends Store_ComposedStory<infer _, infer TProps> ? AnnotatedStoryFn<TFramework, Partial<TProps>> : unknown;
};
declare type Store_ControlsMatchers = {
    date: RegExp;
    color: RegExp;
};
interface Store_ComposeStory<TFramework extends AnyFramework = AnyFramework, TArgs extends Args = Args> {
    (storyAnnotations: AnnotatedStoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>, componentAnnotations: ComponentAnnotations<TFramework, TArgs>, projectAnnotations: ProjectAnnotations<TFramework>, exportsName?: string): {
        (extraArgs: Partial<TArgs>): TFramework['storyResult'];
        storyName: string;
        args: Args;
        play: Store_ComposedStoryPlayFn;
        parameters: Parameters;
    };
}

interface ClientAPI_ErrorLike {
    message: string;
    stack: string;
}
interface ClientAPI_StoryMetadata {
    parameters?: Parameters;
    decorators?: DecoratorFunction[];
    loaders?: LoaderFunction[];
}
declare type ClientAPI_ArgTypesEnhancer = (context: StoryContext) => ArgTypes;
declare type ClientAPI_ArgsEnhancer = (context: StoryContext) => Args;
declare type StorySpecifier = StoryId | {
    name: StoryName;
    kind: StoryKind;
} | '*';
interface ClientAPI_StoreSelectionSpecifier {
    storySpecifier: StorySpecifier;
    viewMode: ViewMode;
    singleStory?: boolean;
    args?: Args;
    globals?: Args;
}
interface ClientAPI_StoreSelection {
    storyId: StoryId;
    viewMode: ViewMode;
}
declare type ClientAPI_AddStoryArgs = StoryIdentifier & {
    storyFn: StoryFn<any>;
    parameters?: Parameters;
    decorators?: DecoratorFunction[];
    loaders?: LoaderFunction[];
};
declare type ClientAPI_ClientApiReturnFn<StoryFnReturnType> = (...args: any[]) => Addon_StoryApi<StoryFnReturnType>;
interface ClientAPI_ClientApiAddon<StoryFnReturnType = unknown> extends Addon_Type {
    apply: (a: Addon_StoryApi<StoryFnReturnType>, b: any[]) => any;
}
interface ClientAPI_ClientApiAddons<StoryFnReturnType> {
    [key: string]: ClientAPI_ClientApiAddon<StoryFnReturnType>;
}
declare type ClientAPI_RenderContextWithoutStoryContext = Omit<Store_RenderContext, 'storyContext'>;
interface ClientAPI_GetStorybookStory<TFramework extends AnyFramework> {
    name: string;
    render: LegacyStoryFn<TFramework>;
}
interface ClientAPI_GetStorybookKind<TFramework extends AnyFramework> {
    kind: string;
    fileName: string;
    stories: ClientAPI_GetStorybookStory<TFramework>[];
}

interface CoreClient_PreviewError {
    message?: string;
    stack?: string;
}
interface CoreClient_RequireContext {
    keys: () => string[];
    (id: string): any;
    resolve(id: string): string;
}
declare type CoreClient_LoaderFunction = () => void | any[];
declare type Loadable = CoreClient_RequireContext | CoreClient_RequireContext[] | CoreClient_LoaderFunction;

declare type CoreClient_RenderStoryFunction = (context: Store_RenderContext) => void;

interface Options$1 {
    allowRegExp: boolean;
    allowFunction: boolean;
    allowSymbol: boolean;
    allowDate: boolean;
    allowUndefined: boolean;
    allowClass: boolean;
    maxDepth: number;
    space: number | undefined;
    lazyEval: boolean;
}

/**
 * ⚠️ This file contains internal WIP types they MUST NOT be exported outside this package for now!
 */
declare type BuilderName = 'webpack5' | '@storybook/builder-webpack5' | string;
declare type RendererName = string;
interface CoreConfig {
    builder?: BuilderName | {
        name: BuilderName;
        options?: Record<string, any>;
    };
    renderer?: RendererName;
    disableWebpackDefaults?: boolean;
    channelOptions?: Partial<Options$1>;
    /**
     * Disables the generation of project.json, a file containing Storybook metadata
     */
    disableProjectJson?: boolean;
    /**
     * Disables Storybook telemetry
     * @see https://storybook.js.org/telemetry
     */
    disableTelemetry?: boolean;
    /**
     * Enable crash reports to be sent to Storybook telemetry
     * @see https://storybook.js.org/telemetry
     */
    enableCrashReports?: boolean;
    /**
     * enable CORS headings to run document in a "secure context"
     * see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#security_requirements
     * This enables these headers in development-mode:
     *   Cross-Origin-Opener-Policy: same-origin
     *   Cross-Origin-Embedder-Policy: require-corp
     */
    crossOriginIsolated?: boolean;
}
interface DirectoryMapping {
    from: string;
    to: string;
}
interface Presets {
    apply(extension: 'typescript', config: TypescriptOptions, args?: Options): Promise<TypescriptOptions>;
    apply(extension: 'framework', config?: {}, args?: any): Promise<Preset>;
    apply(extension: 'babel', config?: {}, args?: any): Promise<TransformOptions>;
    apply(extension: 'entries', config?: [], args?: any): Promise<unknown>;
    apply(extension: 'stories', config?: [], args?: any): Promise<CoreCommon_StoriesEntry[]>;
    apply(extension: 'managerEntries', config: [], args?: any): Promise<string[]>;
    apply(extension: 'refs', config?: [], args?: any): Promise<unknown>;
    apply(extension: 'core', config?: {}, args?: any): Promise<CoreConfig>;
    apply<T>(extension: string, config?: T, args?: unknown): Promise<T>;
}
interface LoadedPreset {
    name: string;
    preset: any;
    options: any;
}
declare type PresetConfig = string | {
    name: string;
    options?: unknown;
};
interface Ref {
    id: string;
    url: string;
    title: string;
    version: string;
    type?: string;
    disable?: boolean;
}
interface VersionCheck {
    success: boolean;
    cached: boolean;
    data?: any;
    error?: any;
    time: number;
}
interface ReleaseNotesData {
    success: boolean;
    currentVersion: string;
    showOnFirstLaunch: boolean;
}
interface Stats {
    toJson: () => any;
}
interface BuilderResult {
    totalTime?: ReturnType<typeof process.hrtime>;
    stats?: Stats;
}
declare type PackageJson = PackageJson$1 & Record<string, any>;
interface LoadOptions {
    packageJson: PackageJson;
    outputDir?: string;
    configDir?: string;
    ignorePreview?: boolean;
    extendServer?: (server: Server) => void;
}
interface CLIOptions {
    port?: number;
    ignorePreview?: boolean;
    previewUrl?: string;
    forceBuildPreview?: boolean;
    disableTelemetry?: boolean;
    enableCrashReports?: boolean;
    host?: string;
    /**
     * @deprecated Use 'staticDirs' Storybook Configuration option instead
     */
    staticDir?: string[];
    configDir?: string;
    https?: boolean;
    sslCa?: string[];
    sslCert?: string;
    sslKey?: string;
    smokeTest?: boolean;
    managerCache?: boolean;
    open?: boolean;
    ci?: boolean;
    loglevel?: string;
    quiet?: boolean;
    versionUpdates?: boolean;
    releaseNotes?: boolean;
    dll?: boolean;
    docs?: boolean;
    docsDll?: boolean;
    uiDll?: boolean;
    debugWebpack?: boolean;
    webpackStatsJson?: string | boolean;
    outputDir?: string;
}
interface BuilderOptions {
    configType?: 'DEVELOPMENT' | 'PRODUCTION';
    ignorePreview: boolean;
    cache: FileSystemCache;
    configDir: string;
    docsMode: boolean;
    features?: StorybookConfig['features'];
    versionCheck?: VersionCheck;
    releaseNotesData?: ReleaseNotesData;
    disableWebpackDefaults?: boolean;
    serverChannelUrl?: string;
}
interface StorybookConfigOptions {
    presets: Presets;
    presetsList?: LoadedPreset[];
}
declare type Options = LoadOptions & StorybookConfigOptions & CLIOptions & BuilderOptions;
interface Builder<Config, BuilderStats extends Stats = Stats> {
    getConfig: (options: Options) => Promise<Config>;
    start: (args: {
        options: Options;
        startTime: ReturnType<typeof process.hrtime>;
        router: Router;
        server: Server;
    }) => Promise<void | {
        stats?: BuilderStats;
        totalTime: ReturnType<typeof process.hrtime>;
        bail: (e?: Error) => Promise<void>;
    }>;
    build: (arg: {
        options: Options;
        startTime: ReturnType<typeof process.hrtime>;
    }) => Promise<void | BuilderStats>;
    bail: (e?: Error) => Promise<void>;
    corePresets?: string[];
    overridePresets?: string[];
}
interface CoreCommon_IndexerOptions {
    makeTitle: (userTitle?: string) => string;
}
interface CoreCommon_IndexedStory {
    id: string;
    name: string;
    tags?: Tag[];
    parameters?: Parameters;
}
interface CoreCommon_StoryIndex {
    meta: {
        title?: string;
        tags?: Tag[];
    };
    stories: CoreCommon_IndexedStory[];
}
interface CoreCommon_StoryIndexer {
    test: RegExp;
    indexer: (fileName: string, options: CoreCommon_IndexerOptions) => Promise<CoreCommon_StoryIndex>;
}
/**
 * Options for TypeScript usage within Storybook.
 */
interface TypescriptOptions {
    /**
     * Enables type checking within Storybook.
     *
     * @default `false`
     */
    check: boolean;
    /**
     * Disable parsing typescript files through babel.
     *
     * @default `false`
     */
    skipBabel: boolean;
}
interface CoreCommon_StoriesSpecifier {
    /**
     * When auto-titling, what to prefix all generated titles with (default: '')
     */
    titlePrefix?: string;
    /**
     * Where to start looking for story files
     */
    directory: string;
    /**
     * What does the filename of a story file look like?
     * (a glob, relative to directory, no leading `./`)
     * If unset, we use `** / *.stories.@(mdx|tsx|ts|jsx|js)` (no spaces)
     */
    files?: string;
}
declare type CoreCommon_StoriesEntry = string | CoreCommon_StoriesSpecifier;
declare type CoreCommon_NormalizedStoriesSpecifier = Required<CoreCommon_StoriesSpecifier> & {
    importPathMatcher: RegExp;
};
declare type Preset = string | {
    name: string;
    options?: any;
};
/**
 * An additional script that gets injected into the
 * preview or the manager,
 */
declare type Entry = string;
declare type CoreCommon_StorybookRefs = Record<string, {
    title: string;
    url: string;
} | {
    disable: boolean;
}>;
declare type DocsOptions = {
    /**
     * Should we generate docs entries at all under any circumstances? (i.e. can they be rendered)
     */
    enabled?: boolean;
    /**
     * What should we call the generated docs entries?
     */
    defaultName?: string;
    /**
     * Should we generate a docs entry per CSF file with the `docsPage` tag?
     * Set to 'automatic' to generate an entry irrespective of tag.
     */
    docsPage?: boolean | 'automatic';
    /**
     * Only show doc entries in the side bar (usually set with the `--docs` CLI flag)
     */
    docsMode?: boolean;
};
/**
 * The interface for Storybook configuration in `main.ts` files.
 */
interface StorybookConfig {
    /**
     * Sets the addons you want to use with Storybook.
     *
     * @example `['@storybook/addon-essentials']` or `[{ name: '@storybook/addon-essentials', options: { backgrounds: false } }]`
     */
    addons?: Preset[];
    core?: CoreConfig;
    /**
     * Sets a list of directories of static files to be loaded by Storybook server
     *
     * @example `['./public']` or `[{from: './public', 'to': '/assets'}]`
     */
    staticDirs?: (DirectoryMapping | string)[];
    logLevel?: string;
    features?: {
        /**
         * Allows to disable deprecated implicit PostCSS loader. (will be removed in 7.0)
         */
        postcss?: boolean;
        /**
         * Build stories.json automatically on start/build
         */
        buildStoriesJson?: boolean;
        /**
         * Activate preview of CSF v3.0
         *
         * @deprecated This is always on now from 6.4 regardless of the setting
         */
        previewCsfV3?: boolean;
        /**
         * Activate on demand story store
         */
        storyStoreV7?: boolean;
        /**
         * Enable a set of planned breaking changes for SB7.0
         */
        breakingChangesV7?: boolean;
        /**
         * Enable the step debugger functionality in Addon-interactions.
         */
        interactionsDebugger?: boolean;
        /**
         * Use Storybook 7.0 babel config scheme
         */
        babelModeV7?: boolean;
        /**
         * Filter args with a "target" on the type from the render function (EXPERIMENTAL)
         */
        argTypeTargetsV7?: boolean;
        /**
         * Warn when there is a pre-6.0 hierarchy separator ('.' / '|') in the story title.
         * Will be removed in 7.0.
         */
        warnOnLegacyHierarchySeparator?: boolean;
    };
    /**
     * Tells Storybook where to find stories.
     *
     * @example `['./src/*.stories.@(j|t)sx?']`
     */
    stories: CoreCommon_StoriesEntry[];
    /**
     * Framework, e.g. '@storybook/react', required in v7
     */
    framework?: Preset;
    /**
     * Controls how Storybook handles TypeScript files.
     */
    typescript?: Partial<TypescriptOptions>;
    /**
     * References external Storybooks
     */
    refs?: CoreCommon_StorybookRefs | ((config: any, options: Options) => CoreCommon_StorybookRefs);
    /**
     * Modify or return babel config.
     */
    babel?: (config: TransformOptions, options: Options) => TransformOptions | Promise<TransformOptions>;
    /**
     * Modify or return babel config.
     */
    babelDefault?: (config: TransformOptions, options: Options) => TransformOptions | Promise<TransformOptions>;
    /**
     * Add additional scripts to run in the preview a la `.storybook/preview.js`
     *
     * @deprecated use `previewAnnotations` or `/preview.js` file instead
     */
    config?: (entries: Entry[], options: Options) => Entry[];
    /**
     * Add additional scripts to run in the preview a la `.storybook/preview.js`
     */
    previewAnnotations?: (entries: Entry[], options: Options) => Entry[];
    /**
     * Process CSF files for the story index.
     */
    storyIndexers?: (indexers: CoreCommon_StoryIndexer[], options: Options) => CoreCommon_StoryIndexer[];
    /**
     * Docs related features in index generation
     */
    docs?: DocsOptions;
    /**
     * Programmatically modify the preview head/body HTML.
     * The previewHead and previewBody functions accept a string,
     * which is the existing head/body, and return a modified string.
     */
    previewHead?: (head: string, options: Options) => string;
    previewBody?: (body: string, options: Options) => string;
}
declare type PresetProperty<K, TStorybookConfig = StorybookConfig> = TStorybookConfig[K extends keyof TStorybookConfig ? K : never] | PresetPropertyFn<K, TStorybookConfig>;
declare type PresetPropertyFn<K, TStorybookConfig = StorybookConfig, TOptions = {}> = (config: TStorybookConfig[K extends keyof TStorybookConfig ? K : never], options: Options & TOptions) => TStorybookConfig[K extends keyof TStorybookConfig ? K : never] | Promise<TStorybookConfig[K extends keyof TStorybookConfig ? K : never]>;
interface CoreCommon_ResolvedAddonPreset {
    type: 'presets';
    name: string;
}
interface CoreCommon_ResolvedAddonVirtual {
    type: 'virtual';
    name: string;
    managerEntries?: string[];
    previewAnnotations?: string[];
    presets?: (string | {
        name: string;
        options?: any;
    })[];
}
declare type CoreCommon_OptionsEntry = {
    name: string;
};
declare type CoreCommon_AddonEntry = string | CoreCommon_OptionsEntry;
declare type CoreCommon_AddonInfo = {
    name: string;
    inEssentials: boolean;
};
interface CoreCommon_StorybookInfo {
    version: string;
    framework: string;
    frameworkPackage: string;
    renderer: string;
    rendererPackage: string;
    configDir?: string;
    mainConfig?: string;
    previewConfig?: string;
    managerConfig?: string;
}

interface BuilderStats {
    toJson: () => any;
}
declare type Builder_WithRequiredProperty<Type, Key extends keyof Type> = Type & {
    [Property in Key]-?: Type[Property];
};
declare type Builder_Unpromise<T extends Promise<any>> = T extends Promise<infer U> ? U : never;
declare type Builder_EnvsRaw = Record<string, string>;

declare type ChannelHandler = (event: ChannelEvent) => void;
interface ChannelTransport {
    send(event: ChannelEvent, options?: any): void;
    setHandler(handler: ChannelHandler): void;
}
interface ChannelEvent {
    type: string;
    from: string;
    args: any[];
}
interface Listener {
    (...args: any[]): void;
}
interface ChannelArgs {
    transport?: ChannelTransport;
    async?: boolean;
}
declare class Channel {
    readonly isAsync: boolean;
    private sender;
    private events;
    private data;
    private readonly transport;
    constructor({ transport, async }?: ChannelArgs);
    get hasTransport(): boolean;
    addListener(eventName: string, listener: Listener): void;
    emit(eventName: string, ...args: any): void;
    last(eventName: string): any;
    eventNames(): string[];
    listenerCount(eventName: string): number;
    listeners(eventName: string): Listener[] | undefined;
    once(eventName: string, listener: Listener): void;
    removeAllListeners(eventName?: string): void;
    removeListener(eventName: string, listener: Listener): void;
    on(eventName: string, listener: Listener): void;
    off(eventName: string, listener: Listener): void;
    private handleEvent;
    private onceListener;
}

interface API_BaseEntry {
    id: StoryId;
    depth: number;
    name: string;
    refId?: string;
    renderLabel?: (item: API_BaseEntry) => any;
    /** @deprecated */
    isRoot: boolean;
    /** @deprecated */
    isComponent: boolean;
    /** @deprecated */
    isLeaf: boolean;
}
interface API_RootEntry extends API_BaseEntry {
    type: 'root';
    startCollapsed?: boolean;
    children: StoryId[];
    /** @deprecated */
    isRoot: true;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: false;
}
interface API_GroupEntry extends API_BaseEntry {
    type: 'group';
    parent?: StoryId;
    children: StoryId[];
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: false;
}
interface API_ComponentEntry extends API_BaseEntry {
    type: 'component';
    parent?: StoryId;
    children: StoryId[];
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: true;
    /** @deprecated */
    isLeaf: false;
}
interface API_DocsEntry extends API_BaseEntry {
    type: 'docs';
    parent: StoryId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    importPath: Path;
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: true;
}
interface API_StoryEntry extends API_BaseEntry {
    type: 'story';
    parent: StoryId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    importPath: Path;
    tags: Tag[];
    prepared: boolean;
    parameters?: {
        [parameterName: string]: any;
    };
    args?: Args;
    argTypes?: ArgTypes;
    initialArgs?: Args;
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: true;
}
declare type API_LeafEntry = API_DocsEntry | API_StoryEntry;
declare type API_HashEntry = API_RootEntry | API_GroupEntry | API_ComponentEntry | API_DocsEntry | API_StoryEntry;
/** @deprecated */
declare type API_Root = API_RootEntry;
/** @deprecated */
declare type API_Group = API_GroupEntry | API_ComponentEntry;
/** @deprecated */
declare type API_Story = API_LeafEntry;
/**
 * The `StoriesHash` is our manager-side representation of the `StoryIndex`.
 * We create entries in the hash not only for each story or docs entry, but
 * also for each "group" of the component (split on '/'), as that's how things
 * are manipulated in the manager (i.e. in the sidebar)
 */
interface API_StoriesHash {
    [id: string]: API_HashEntry;
}
interface API_SetStoriesStory {
    id: StoryId;
    name: string;
    refId?: string;
    componentId?: ComponentId;
    kind: StoryKind;
    parameters: {
        fileName: string;
        options: {
            [optionName: string]: any;
        };
        docsOnly?: boolean;
        viewMode?: API_ViewMode;
        [parameterName: string]: any;
    };
    argTypes?: ArgTypes;
    args?: Args;
    initialArgs?: Args;
}
interface API_SetStoriesStoryData {
    [id: string]: API_SetStoriesStory;
}
interface API_StoryKey {
    id: StoryId;
    refId?: string;
}
declare type API_SetStoriesPayload = {
    v: 2;
    error?: Error;
    globals: Args;
    globalParameters: Parameters;
    stories: API_SetStoriesStoryData;
    kindParameters: {
        [kind: string]: Parameters;
    };
} | ({
    v?: number;
    stories: API_SetStoriesStoryData;
} & Record<string, never>);
interface API_BaseIndexEntry {
    id: StoryId;
    name: StoryName;
    title: ComponentTitle;
    importPath: Path;
}
declare type API_StoryIndexEntry = API_BaseIndexEntry & {
    type?: 'story';
};
interface API_V3IndexEntry extends API_BaseIndexEntry {
    parameters?: Parameters;
}
interface API_StoryIndexV3 {
    v: 3;
    stories: Record<StoryId, API_V3IndexEntry>;
}
declare type API_DocsIndexEntry = API_BaseIndexEntry & {
    storiesImports: Path[];
    type: 'docs';
};
declare type API_IndexEntry = API_StoryIndexEntry | API_DocsIndexEntry;
interface StoryIndex {
    v: number;
    entries: Record<StoryId, API_IndexEntry>;
}
declare type API_PreparedIndexEntry = API_IndexEntry & {
    parameters?: Parameters;
    argTypes?: ArgTypes;
    args?: Args;
    initialArgs?: Args;
};
interface API_PreparedStoryIndex {
    v: number;
    entries: Record<StoryId, API_PreparedIndexEntry>;
}
interface API_StoryIndex {
    v: number;
    entries: Record<StoryId, API_IndexEntry>;
}
declare type API_OptionsData = {
    docsOptions: DocsOptions;
};
interface API_Args {
    [key: string]: any;
}
interface API_ArgType {
    name?: string;
    description?: string;
    defaultValue?: any;
    if?: Conditional;
    [key: string]: any;
}
interface API_ArgTypes {
    [key: string]: API_ArgType;
}
interface API_ReleaseNotes {
    success?: boolean;
    currentVersion?: string;
    showOnFirstLaunch?: boolean;
}
interface API_Settings {
    lastTrackedStoryId: string;
}
interface API_SetGlobalsPayload {
    globals: Globals;
    globalTypes: GlobalTypes;
}
interface API_Version {
    version: string;
    info?: {
        plain: string;
    };
    [key: string]: any;
}
interface API_UnknownEntries {
    [key: string]: {
        [key: string]: any;
    };
}
interface API_Versions$1 {
    latest?: API_Version;
    next?: API_Version;
    current?: API_Version;
}

declare type API_ViewMode = 'story' | 'info' | 'settings' | 'page' | undefined | string;
interface API_RenderOptions {
    active: boolean;
    key: string;
}
interface API_RouteOptions {
    storyId: string;
    viewMode: API_ViewMode;
    location: RenderData['location'];
    path: string;
}
interface API_MatchOptions {
    storyId: string;
    viewMode: API_ViewMode;
    location: RenderData['location'];
    path: string;
}
interface API_Addon {
    title: string;
    type?: Addon_Types;
    id?: string;
    route?: (routeOptions: API_RouteOptions) => string;
    match?: (matchOptions: API_MatchOptions) => boolean;
    render: (renderOptions: API_RenderOptions) => any;
    paramKey?: string;
    disabled?: boolean;
    hidden?: boolean;
}
interface API_Collection<T = API_Addon> {
    [key: string]: T;
}
declare type API_Panels = API_Collection<API_Addon>;
declare type API_StateMerger<S> = (input: S) => S;
interface API_ProviderData<API> {
    provider: API_Provider<API>;
    docsOptions: DocsOptions;
}
interface API_Provider<API> {
    channel?: Channel;
    serverChannel?: Channel;
    renderPreview?: API_IframeRenderer;
    handleAPI(api: API): void;
    getConfig(): {
        sidebar?: API_SidebarOptions;
        theme?: ThemeVars;
        StoryMapper?: API_StoryMapper;
        [k: string]: any;
    } & Partial<API_UIOptions>;
    [key: string]: any;
}
declare type API_IframeRenderer = (storyId: string, viewMode: ViewMode, id: string, baseUrl: string, scale: number, queryParams: Record<string, any>) => any;
interface API_UIOptions {
    name?: string;
    url?: string;
    goFullScreen: boolean;
    showStoriesPanel: boolean;
    showAddonPanel: boolean;
    addonPanelInRight: boolean;
    theme?: ThemeVars;
    selectedPanel?: string;
}
interface API_Layout {
    initialActive: API_ActiveTabsType;
    isFullscreen: boolean;
    showPanel: boolean;
    panelPosition: API_PanelPositions;
    showNav: boolean;
    showTabs: boolean;
    showToolbar: boolean;
    /**
     * @deprecated
     */
    isToolshown?: boolean;
}
interface API_UI {
    name?: string;
    url?: string;
    enableShortcuts: boolean;
}
declare type API_PanelPositions = 'bottom' | 'right';
declare type API_ActiveTabsType = 'sidebar' | 'canvas' | 'addons';
interface API_SidebarOptions {
    showRoots?: boolean;
    collapsedRoots?: string[];
    renderLabel?: (item: API_HashEntry) => any;
}
interface API_Notification {
    id: string;
    link: string;
    content: {
        headline: string;
        subHeadline?: string | any;
    };
    icon?: {
        name: string;
        color?: string;
    };
    onClear?: () => void;
}
declare type API_Versions = Record<string, string>;
declare type API_SetRefData = Partial<API_ComposedRef & {
    setStoriesData: API_SetStoriesStoryData;
    storyIndex: API_StoryIndex;
}>;
declare type API_StoryMapper = (ref: API_ComposedRef, story: API_SetStoriesStory) => API_SetStoriesStory;
interface API_ComposedRef {
    id: string;
    title?: string;
    url: string;
    type?: 'auto-inject' | 'unknown' | 'lazy' | 'server-checked';
    expanded?: boolean;
    stories: API_StoriesHash;
    versions?: API_Versions;
    loginUrl?: string;
    version?: string;
    ready?: boolean;
    error?: any;
}
declare type API_ComposedRefUpdate = Partial<Pick<API_ComposedRef, 'title' | 'type' | 'expanded' | 'stories' | 'versions' | 'loginUrl' | 'version' | 'ready' | 'error'>>;
declare type API_Refs = Record<string, API_ComposedRef>;
declare type API_RefId = string;
declare type API_RefUrl = string;

export { API_ActiveTabsType, API_Addon, API_ArgType, API_ArgTypes, API_Args, API_BaseEntry, API_Collection, API_ComponentEntry, API_ComposedRef, API_ComposedRefUpdate, API_DocsEntry, API_DocsIndexEntry, API_Group, API_GroupEntry, API_HashEntry, API_IframeRenderer, API_IndexEntry, API_Layout, API_LeafEntry, API_MatchOptions, API_Notification, API_OptionsData, API_PanelPositions, API_Panels, API_PreparedStoryIndex, API_Provider, API_ProviderData, API_RefId, API_RefUrl, API_Refs, API_ReleaseNotes, API_RenderOptions, API_Root, API_RootEntry, API_RouteOptions, API_SetGlobalsPayload, API_SetRefData, API_SetStoriesPayload, API_SetStoriesStory, API_SetStoriesStoryData, API_Settings, API_SidebarOptions, API_StateMerger, API_StoriesHash, API_Story, API_StoryEntry, API_StoryIndex, API_StoryIndexEntry, API_StoryIndexV3, API_StoryKey, API_StoryMapper, API_UI, API_UIOptions, API_UnknownEntries, API_Version, API_Versions$1 as API_Versions, API_ViewMode, Addon_AddStoryArgs, Addon_Annotations, Addon_ArgType, Addon_ArgsStoryFn, Addon_BaseAnnotations, Addon_BaseDecorators, Addon_BaseIndexEntry, Addon_BaseMeta, Addon_BaseStoryFn, Addon_BaseStoryObject, Addon_ClientApiAddon, Addon_ClientApiAddons, Addon_ClientApiReturnFn, Addon_ClientStoryApi, Addon_Collection, Addon_Comparator, Addon_Config, Addon_DecoratorFunction, Addon_DocsIndexEntry, Addon_Elements, Addon_IndexEntry, Addon_IndexEntryLegacy, Addon_LegacyStoryFn, Addon_LoadFn, Addon_Loadable, Addon_Loader, Addon_LoaderFunction, Addon_Loaders, Addon_MakeDecoratorResult, Addon_OptionsParameter, Addon_PartialStoryFn, Addon_RenderOptions, Addon_RequireContext, Addon_StandaloneDocsIndexEntry, Addon_StoryApi, Addon_StoryContext, Addon_StoryContextUpdate, Addon_StoryFn, Addon_StoryIndexEntry, Addon_StorySortComparator, Addon_StorySortComparatorV7, Addon_StorySortMethod, Addon_StorySortObjectParameter, Addon_StorySortParameter, Addon_StorySortParameterV7, Addon_StoryWrapper, Addon_TemplateDocsIndexEntry, Addon_ToolbarConfig, Addon_Type, Addon_Types, Addon_TypesEnum, Addon_WrapperSettings, Addons_ArgTypes, AnnotatedStoryFn, AnyFramework, ArgTypes, ArgTypesEnhancer, Args, ArgsEnhancer, ArgsFromMeta, ArgsStoryFn, BaseAnnotations, BaseStory, Builder, BuilderName, BuilderOptions, BuilderResult, BuilderStats, Builder_EnvsRaw, Builder_Unpromise, Builder_WithRequiredProperty, CLIOptions, CSF_Meta, CSF_Story, ClientAPI_AddStoryArgs, ClientAPI_ArgTypesEnhancer, ClientAPI_ArgsEnhancer, ClientAPI_ClientApiAddon, ClientAPI_ClientApiAddons, ClientAPI_ClientApiReturnFn, ClientAPI_ErrorLike, ClientAPI_GetStorybookKind, ClientAPI_GetStorybookStory, ClientAPI_RenderContextWithoutStoryContext, ClientAPI_StoreSelection, ClientAPI_StoreSelectionSpecifier, ClientAPI_StoryMetadata, ComponentAnnotations, ComponentId, ComponentTitle, Conditional, CoreClient_LoaderFunction, CoreClient_PreviewError, CoreClient_RenderStoryFunction, CoreClient_RequireContext, CoreCommon_AddonEntry, CoreCommon_AddonInfo, CoreCommon_IndexedStory, CoreCommon_IndexerOptions, CoreCommon_NormalizedStoriesSpecifier, CoreCommon_OptionsEntry, CoreCommon_ResolvedAddonPreset, CoreCommon_ResolvedAddonVirtual, CoreCommon_StoriesEntry, CoreCommon_StoryIndex, CoreCommon_StoryIndexer, CoreCommon_StorybookInfo, CoreConfig, DecoratorApplicator, DecoratorFunction, DocsOptions, Entry, GlobalTypes, Globals, IncludeExcludeOptions, InputType, LegacyAnnotatedStoryFn, LegacyStoryAnnotationsOrFn, LegacyStoryFn, LoadOptions, Loadable, LoadedPreset, LoaderFunction, Options, PackageJson, Parameters, PartialStoryFn, Path, PlayFunction, PlayFunctionContext, Preset, PresetConfig, PresetProperty, PresetPropertyFn, Presets, ProjectAnnotations, Ref, ReleaseNotesData, Store_RenderContext as RenderContext, RendererName, SBArrayType, SBEnumType, SBIntersectionType, SBObjectType, SBOtherType, SBScalarType, SBType, SBUnionType, SeparatorOptions, Stats, StepFunction, StepLabel, StepRunner, Store_BoundStory, Store_CSFExports, Store_CSFFile, Store_ComposeStory, Store_ComposedStory, Store_ComposedStoryPlayContext, Store_ComposedStoryPlayFn, Store_ContextStore, Store_ControlsMatchers, Store_DecoratorApplicator, Store_ExtractOptions, Store_ModuleExport, Store_ModuleExports, Store_ModuleImportFn, Store_NormalizedComponentAnnotations, Store_NormalizedProjectAnnotations, Store_NormalizedStoriesSpecifier, Store_NormalizedStoriesSpecifierEntry, Store_NormalizedStoryAnnotations, Store_PromiseLike, Store_PropDescriptor, Store_RenderContext, Store_RenderToDOM, Store_Selection, Store_SelectionSpecifier, Store_StoriesSpecifier, Store_StoriesWithPartialProps, Store_Story, Store_StoryFn, Store_StoryIndex, Store_StoryIndexV3, Store_StorySpecifier, Store_TeardownRenderToDOM, Store_V2CompatIndexEntry, Store_WebProjectAnnotations, StoryAnnotations, StoryAnnotationsOrFn, StoryContext, StoryContextForEnhancers, StoryContextForLoaders, StoryContextUpdate, StoryFn, StoryId, StoryIdentifier, StoryIndex, StoryKind, StoryName, StorybookConfig, StorybookConfigOptions, StrictArgTypes, StrictGlobalTypes, StrictInputType, Tag, TypescriptOptions, VersionCheck, ViewMode };
