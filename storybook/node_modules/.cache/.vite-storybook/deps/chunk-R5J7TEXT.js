import {
  require_ansi_to_html
} from "./chunk-J564GROQ.js";
import {
  or
} from "./chunk-ZQ2CAHCN.js";
import {
  dedent
} from "./chunk-6P6QZ5GB.js";
import {
  require_synchronous_promise
} from "./chunk-N442H5QH.js";
import {
  require_isPlainObject
} from "./chunk-G7LAUJAA.js";
import {
  c as c2
} from "./chunk-UACHQL3Y.js";
import {
  require_lib
} from "./chunk-3OL5LWJI.js";
import {
  A,
  C,
  D,
  F,
  G,
  H,
  L,
  N,
  O,
  P,
  U,
  W,
  Y,
  a,
  b,
  c,
  d,
  f,
  g,
  h,
  i as i2,
  l,
  o,
  p,
  t,
  u,
  y
} from "./chunk-M3XCZAQ7.js";
import {
  i,
  n
} from "./chunk-3QDDUDC7.js";
import {
  require_window
} from "./chunk-Z3ID2O7F.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@storybook/preview-web/dist/index.mjs
var import_global = __toESM(require_window(), 1);
var import_synchronous_promise = __toESM(require_synchronous_promise(), 1);
var import_global2 = __toESM(require_window(), 1);
var import_global3 = __toESM(require_window(), 1);
var import_global4 = __toESM(require_window(), 1);
var import_qs = __toESM(require_lib(), 1);
var import_qs2 = __toESM(require_lib(), 1);
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
var import_global5 = __toESM(require_window(), 1);
var import_ansi_to_html = __toESM(require_ansi_to_html(), 1);
var import_qs3 = __toESM(require_lib(), 1);
var import_global6 = __toESM(require_window(), 1);
var w = new Error("prepareAborted");
var { AbortController: z } = import_global2.default;
function ye(o2) {
  try {
    let { name: e = "Error", message: r = String(o2), stack: t2 } = o2;
    return { name: e, message: r, stack: t2 };
  } catch {
    return { name: "Error", message: String(o2) };
  }
}
var R = class {
  constructor(e, r, t2, n2, s, i3, d2 = { autoplay: true }, l2) {
    this.channel = e;
    this.store = r;
    this.renderToScreen = t2;
    this.callbacks = n2;
    this.id = s;
    this.viewMode = i3;
    this.renderOptions = d2;
    this.type = "story";
    this.notYetRendered = true;
    this.disableKeyListeners = false;
    this.teardownRender = () => {
    };
    this.torndown = false;
    this.abortController = new z(), l2 && (this.story = l2, this.phase = "preparing");
  }
  async runPhase(e, r, t2) {
    this.phase = r, this.channel.emit(p, { newPhase: this.phase, storyId: this.id }), t2 && await t2(), e.aborted && (this.phase = "aborted", this.channel.emit(p, { newPhase: this.phase, storyId: this.id }));
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw this.store.cleanupStory(this.story), w;
  }
  isEqual(e) {
    return !!(this.id === e.id && this.story && this.story === e.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["rendering", "playing"].includes(this.phase);
  }
  async renderToElement(e) {
    return this.canvasElement = e, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    return this.store.getStoryContext(this.story);
  }
  async render({ initial: e = false, forceRemount: r = false } = {}) {
    let { canvasElement: t2 } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    if (!t2)
      throw new Error("cannot render when canvasElement is unset");
    let { id: n2, componentId: s, title: i3, name: d2, tags: l2, applyLoaders: a2, unboundStoryFn: A2, playFunction: p2 } = this.story;
    r && !e && (this.cancelRender(), this.abortController = new z());
    let c3 = this.abortController.signal;
    try {
      let h2;
      if (await this.runPhase(c3, "loading", async () => {
        h2 = await a2({ ...this.storyContext(), viewMode: this.viewMode });
      }), c3.aborted)
        return;
      let k = { ...h2, ...this.storyContext(), abortSignal: c3, canvasElement: t2 }, _ = { componentId: s, title: i3, kind: i3, id: n2, name: d2, story: d2, tags: l2, ...this.callbacks, showError: (m) => (this.phase = "errored", this.callbacks.showError(m)), showException: (m) => (this.phase = "errored", this.callbacks.showException(m)), forceRemount: r || this.notYetRendered, storyContext: k, storyFn: () => A2(k), unboundStoryFn: A2 };
      if (await this.runPhase(c3, "rendering", async () => {
        let m = await this.renderToScreen(_, t2);
        this.teardownRender = m || (() => {
        });
      }), this.notYetRendered = false, c3.aborted)
        return;
      if (this.renderOptions.autoplay && r && p2 && this.phase !== "errored") {
        this.disableKeyListeners = true;
        try {
          await this.runPhase(c3, "playing", async () => {
            await p2(_.storyContext);
          }), await this.runPhase(c3, "played");
        } catch (m) {
          if (i.error(m), await this.runPhase(c3, "errored", async () => {
            this.channel.emit(t, ye(m));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw m;
        }
        if (this.disableKeyListeners = false, c3.aborted)
          return;
      }
      await this.runPhase(c3, "completed", async () => this.channel.emit(U, n2));
    } catch (h2) {
      this.phase = "errored", this.callbacks.showException(h2);
    }
  }
  async rerender() {
    return this.render();
  }
  async remount() {
    return this.render({ forceRemount: true });
  }
  cancelRender() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && this.store.cleanupStory(this.story);
    for (let e = 0; e < 3; e += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((r) => setTimeout(r, 0));
    }
    import_global2.default.window.location.reload(), await new Promise(() => {
    });
  }
};
var { fetch: Pe } = import_global.default;
var Fe = "./index.json";
var T = class {
  constructor(e = c2.getChannel()) {
    var _a;
    this.channel = e;
    this.storyRenders = [];
    ((_a = import_global.default.FEATURES) == null ? void 0 : _a.storyStoreV7) && c2.hasServerChannel() && (this.serverChannel = c2.getServerChannel()), this.storyStore = new or();
  }
  initialize({ getStoryIndex: e, importFn: r, getProjectAnnotations: t2 }) {
    return this.getStoryIndex = e, this.importFn = r, this.setupListeners(), this.getProjectAnnotationsOrRenderError(t2).then((n2) => this.initializeWithProjectAnnotations(n2));
  }
  setupListeners() {
    var _a;
    (_a = this.serverChannel) == null ? void 0 : _a.on(O, this.onStoryIndexChanged.bind(this)), this.channel.on(u, this.onUpdateGlobals.bind(this)), this.channel.on(y, this.onUpdateArgs.bind(this)), this.channel.on(g, this.onResetArgs.bind(this)), this.channel.on(P, this.onForceReRender.bind(this)), this.channel.on(Y, this.onForceRemount.bind(this));
  }
  getProjectAnnotationsOrRenderError(e) {
    return import_synchronous_promise.SynchronousPromise.resolve().then(e).then((r) => {
      if (this.renderToDOM = r.renderToDOM, !this.renderToDOM)
        throw new Error(dedent`
            Expected your framework's preset to export a \`renderToDOM\` field.

            Perhaps it needs to be upgraded for Storybook 6.4?

            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field
          `);
      return r;
    }).catch((r) => {
      throw this.renderPreviewEntryError("Error reading preview.js:", r), r;
    });
  }
  initializeWithProjectAnnotations(e) {
    var _a;
    this.storyStore.setProjectAnnotations(e), this.setInitialGlobals();
    let r;
    if ((_a = import_global.default.FEATURES) == null ? void 0 : _a.storyStoreV7)
      r = this.getStoryIndexFromServer();
    else {
      if (!this.getStoryIndex)
        throw new Error("No `getStoryIndex` passed defined in v6 mode");
      r = import_synchronous_promise.SynchronousPromise.resolve().then(this.getStoryIndex);
    }
    return r.then((t2) => this.initializeWithStoryIndex(t2)).catch((t2) => {
      throw this.renderPreviewEntryError("Error loading story index:", t2), t2;
    });
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStore.globals || !this.storyStore.projectAnnotations)
      throw new Error("Cannot emit before initialization");
    this.channel.emit(F, { globals: this.storyStore.globals.get() || {}, globalTypes: this.storyStore.projectAnnotations.globalTypes || {} });
  }
  async getStoryIndexFromServer() {
    let e = await Pe(Fe);
    if (e.status === 200)
      return e.json();
    throw new Error(await e.text());
  }
  initializeWithStoryIndex(e) {
    var _a;
    if (!this.importFn)
      throw new Error("Cannot call initializeWithStoryIndex before initialization");
    return this.storyStore.initialize({ storyIndex: e, importFn: this.importFn, cache: !((_a = import_global.default.FEATURES) == null ? void 0 : _a.storyStoreV7) });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations: e }) {
    delete this.previewEntryError;
    let r = await this.getProjectAnnotationsOrRenderError(e);
    if (!this.storyStore.projectAnnotations) {
      await this.initializeWithProjectAnnotations(r);
      return;
    }
    await this.storyStore.setProjectAnnotations(r), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !!this.storyStore.projectAnnotations)
      try {
        let e = await this.getStoryIndexFromServer();
        this.storyStore.storyIndex || await this.initializeWithStoryIndex(e), await this.onStoriesChanged({ storyIndex: e });
      } catch (e) {
        throw this.renderPreviewEntryError("Error loading story index:", e), e;
      }
  }
  async onStoriesChanged({ importFn: e, storyIndex: r }) {
    await this.storyStore.onStoriesChanged({ importFn: e, storyIndex: r });
  }
  async onUpdateGlobals({ globals: e }) {
    if (!this.storyStore.globals)
      throw new Error("Cannot call onUpdateGlobals before initialization");
    this.storyStore.globals.update(e), await Promise.all(this.storyRenders.map((r) => r.rerender())), this.channel.emit(W, { globals: this.storyStore.globals.get(), initialGlobals: this.storyStore.globals.initialGlobals });
  }
  async onUpdateArgs({ storyId: e, updatedArgs: r }) {
    this.storyStore.args.update(e, r), await Promise.all(this.storyRenders.filter((t2) => t2.id === e).map((t2) => t2.rerender())), this.channel.emit(c, { storyId: e, args: this.storyStore.args.get(e) });
  }
  async onResetArgs({ storyId: e, argNames: r }) {
    var _a;
    let n2 = ((_a = this.storyRenders.find((d2) => d2.id === e)) == null ? void 0 : _a.story) || await this.storyStore.loadStory({ storyId: e }), i3 = (r || [.../* @__PURE__ */ new Set([...Object.keys(n2.initialArgs), ...Object.keys(this.storyStore.args.get(e))])]).reduce((d2, l2) => (d2[l2] = n2.initialArgs[l2], d2), {});
    await this.onUpdateArgs({ storyId: e, updatedArgs: i3 });
  }
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((e) => e.rerender()));
  }
  async onForceRemount({ storyId: e }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === e).map((r) => r.remount()));
  }
  renderStoryToElement(e, r, t2) {
    if (!this.renderToDOM)
      throw new Error("Cannot call renderStoryToElement before initialization");
    let n2 = new R(this.channel, this.storyStore, this.renderToDOM, this.inlineStoryCallbacks(e.id), e.id, "docs", t2, e);
    return n2.renderToElement(r), this.storyRenders.push(n2), async () => {
      await this.teardownRender(n2);
    };
  }
  async teardownRender(e, { viewModeChanged: r } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((t2) => t2 !== e), await ((_a = e == null ? void 0 : e.teardown) == null ? void 0 : _a.call(e, { viewModeChanged: r }));
  }
  async extract(e) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = import_global.default.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(e);
  }
  inlineStoryCallbacks(e) {
    return { showMain: () => {
    }, showError: (r) => i.error(`Error rendering docs story (${e})`, r), showException: (r) => i.error(`Error rendering docs story (${e})`, r) };
  }
  renderPreviewEntryError(e, r) {
    this.previewEntryError = r, i.error(e), i.error(r), this.channel.emit(A, r);
  }
};
var K = /^[a-zA-Z0-9 _-]*$/;
var Q = /^-?[0-9]+(\.[0-9]+)?$/;
var _e = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var X = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var O2 = (o2 = "", e) => o2 === null || o2 === "" || !K.test(o2) ? false : e == null || e instanceof Date || typeof e == "number" || typeof e == "boolean" ? true : typeof e == "string" ? K.test(e) || Q.test(e) || _e.test(e) || X.test(e) : Array.isArray(e) ? e.every((r) => O2(o2, r)) : (0, import_isPlainObject.default)(e) ? Object.entries(e).every(([r, t2]) => O2(r, t2)) : false;
var Ie = { delimiter: ";", allowDots: true, allowSparse: true, decoder(o2, e, r, t2) {
  if (t2 === "value" && o2.startsWith("!")) {
    if (o2 === "!undefined")
      return;
    if (o2 === "!null")
      return null;
    if (o2.startsWith("!date(") && o2.endsWith(")"))
      return new Date(o2.slice(6, -1));
    if (o2.startsWith("!hex(") && o2.endsWith(")"))
      return `#${o2.slice(5, -1)}`;
    let n2 = o2.slice(1).match(X);
    if (n2)
      return o2.startsWith("!rgba") ? `${n2[1]}(${n2[2]}, ${n2[3]}, ${n2[4]}, ${n2[5]})` : o2.startsWith("!hsla") ? `${n2[1]}(${n2[2]}, ${n2[3]}%, ${n2[4]}%, ${n2[5]})` : o2.startsWith("!rgb") ? `${n2[1]}(${n2[2]}, ${n2[3]}, ${n2[4]})` : `${n2[1]}(${n2[2]}, ${n2[3]}%, ${n2[4]}%)`;
  }
  return t2 === "value" && Q.test(o2) ? Number(o2) : e(o2, e, r);
} };
var L2 = (o2) => {
  let e = o2.split(";").map((r) => r.replace("=", "~").replace(":", "="));
  return Object.entries(import_qs2.default.parse(e.join(";"), Ie)).reduce((r, [t2, n2]) => O2(t2, n2) ? Object.assign(r, { [t2]: n2 }) : (n.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url
    `), r), {});
};
var { history: Z, document: u2 } = import_global4.default;
function De(o2) {
  let e = (o2 || "").match(/^\/story\/(.+)/);
  if (!e)
    throw new Error(`Invalid path '${o2}',  must start with '/story/'`);
  return e[1];
}
var J = ({ selection: o2, extraParams: e }) => {
  let { search: r = "" } = u2.location, { path: t2, selectedKind: n2, selectedStory: s, ...i3 } = import_qs.default.parse(r, { ignoreQueryPrefix: true });
  return import_qs.default.stringify({ ...i3, ...e, ...o2 && { id: o2.storyId, viewMode: o2.viewMode } }, { encode: false, addQueryPrefix: true });
};
var ve = (o2) => {
  if (!o2)
    return;
  let e = J({ selection: o2 }), { hash: r = "" } = u2.location;
  u2.title = o2.storyId, Z.replaceState({}, "", `${u2.location.pathname}${e}${r}`);
};
var Oe = (o2) => o2 != null && typeof o2 == "object" && Array.isArray(o2) === false;
var P2 = (o2) => {
  if (o2 !== void 0) {
    if (typeof o2 == "string")
      return o2;
    if (Array.isArray(o2))
      return P2(o2[0]);
    if (Oe(o2))
      return P2(Object.values(o2).filter(Boolean));
  }
};
var Le = () => {
  let o2 = import_qs.default.parse(u2.location.search, { ignoreQueryPrefix: true }), e = typeof o2.args == "string" ? L2(o2.args) : void 0, r = typeof o2.globals == "string" ? L2(o2.globals) : void 0, t2 = P2(o2.viewMode);
  (typeof t2 != "string" || !t2.match(/docs|story/)) && (t2 = "story");
  let n2 = P2(o2.path), s = n2 ? De(n2) : P2(o2.id);
  return s ? { storySpecifier: s, args: e, globals: r, viewMode: t2 } : null;
};
var M = class {
  constructor() {
    this.selectionSpecifier = Le();
  }
  setSelection(e) {
    this.selection = e, ve(this.selection);
  }
  setQueryParams(e) {
    let r = J({ extraParams: e }), { hash: t2 = "" } = u2.location;
    Z.replaceState({}, "", `${u2.location.pathname}${r}${t2}`);
  }
};
var { document: y2 } = import_global5.default;
var ee = 100;
var N2 = { centered: "sb-main-centered", fullscreen: "sb-main-fullscreen", padded: "sb-main-padded" };
var te = ((s) => (s.MAIN = "MAIN", s.NOPREVIEW = "NOPREVIEW", s.PREPARING_STORY = "PREPARING_STORY", s.PREPARING_DOCS = "PREPARING_DOCS", s.ERROR = "ERROR", s))(te || {});
var G2 = { PREPARING_STORY: "sb-show-preparing-story", PREPARING_DOCS: "sb-show-preparing-docs", MAIN: "sb-show-main", NOPREVIEW: "sb-show-nopreview", ERROR: "sb-show-errordisplay" };
var re = new import_ansi_to_html.default({ escapeXML: true });
var D2 = class {
  constructor() {
    this.testing = false;
    let { __SPECIAL_TEST_PARAMETER__: e } = import_qs3.default.parse(y2.location.search, { ignoreQueryPrefix: true });
    switch (e) {
      case "preparing-story": {
        this.showPreparingStory(), this.testing = true;
        break;
      }
      case "preparing-docs": {
        this.showPreparingDocs(), this.testing = true;
        break;
      }
      default:
    }
  }
  prepareForStory(e) {
    return this.showStory(), this.applyLayout(e.parameters.layout), y2.documentElement.scrollTop = 0, y2.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return y2.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), this.docsRoot();
  }
  docsRoot() {
    return y2.getElementById("storybook-docs");
  }
  applyLayout(e = "padded") {
    if (e === "none") {
      y2.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(e);
    let r = N2[e];
    y2.body.classList.remove(this.currentLayoutClass), y2.body.classList.add(r), this.currentLayoutClass = r;
  }
  checkIfLayoutExists(e) {
    N2[e] || i.warn(dedent`The desired layout: ${e} is not a valid option.
         The possible options are: ${Object.keys(N2).join(", ")}, none.`);
  }
  showMode(e) {
    clearTimeout(this.preparingTimeout), Object.keys(te).forEach((r) => {
      r === e ? y2.body.classList.add(G2[r]) : y2.body.classList.remove(G2[r]);
    });
  }
  showErrorDisplay({ message: e = "", stack: r = "" }) {
    let t2 = e, n2 = r, s = e.split(`
`);
    s.length > 1 && ([t2] = s, n2 = s.slice(1).join(`
`)), y2.getElementById("error-message").innerHTML = re.toHtml(t2), y2.getElementById("error-stack").innerHTML = re.toHtml(n2), this.showMode("ERROR");
  }
  showNoPreview() {
    var _a, _b;
    this.testing || (this.showMode("NOPREVIEW"), (_a = this.storyRoot()) == null ? void 0 : _a.setAttribute("hidden", "true"), (_b = this.docsRoot()) == null ? void 0 : _b.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: e = false } = {}) {
    clearTimeout(this.preparingTimeout), e ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_STORY"), ee);
  }
  showPreparingDocs() {
    clearTimeout(this.preparingTimeout), this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), ee);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    y2.body.classList.add(G2.MAIN);
  }
};
var f2 = class {
  constructor(e, r, t2, n2, s = true) {
    this.channel = e;
    this.store = r;
    this.renderStoryToElement = t2;
    this.storyIdByName = (e2) => {
      let r2 = this.nameToStoryId.get(e2);
      if (r2)
        return r2;
      throw new Error(`No story found with that name: ${e2}`);
    };
    this.componentStories = () => this.componentStoriesValue;
    this.storyById = (e2) => {
      if (!e2) {
        if (!this.primaryStory)
          throw new Error("No primary story defined for docs entry. Did you forget to use `<Meta>`?");
        return this.primaryStory;
      }
      let r2 = this.storyIdToCSFFile.get(e2);
      if (!r2)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${e2}`);
      return this.store.storyFromCSFFile({ storyId: e2, csfFile: r2 });
    };
    this.getStoryContext = (e2) => ({ ...this.store.getStoryContext(e2), viewMode: "docs" });
    this.loadStory = (e2) => this.store.loadStory({ storyId: e2 });
    this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStoryId = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.componentStoriesValue = [], n2.forEach((i3, d2) => {
      this.referenceCSFFile(i3, s || d2 === 0);
    });
  }
  referenceCSFFile(e, r) {
    Object.values(e.stories).forEach((t2) => {
      if (this.storyIdToCSFFile.set(t2.id, e), this.exportToStoryId.set(t2.moduleExport, t2.id), r) {
        this.nameToStoryId.set(t2.name, t2.id);
        let n2 = this.storyById(t2.id);
        this.componentStoriesValue.push(n2), this.primaryStory || (this.primaryStory = n2);
      }
    });
  }
  setMeta(e) {
  }
  storyIdByModuleExport(e, r) {
    let t2 = this.exportToStoryId.get(e);
    if (t2)
      return t2;
    throw new Error(`No story found with that export: ${e}`);
  }
};
var F2 = class {
  constructor(e, r, t2) {
    this.channel = e;
    this.store = r;
    this.entry = t2;
    this.type = "docs";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = t2.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e, csfFiles: r = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw w;
    let { importPath: t2, title: n2 } = this.entry, s = this.store.processCSFFileWithCache(e, t2, n2), i3 = Object.keys(s.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: i3, csfFile: s }), this.csfFiles = [s, ...r], this.preparing = false;
  }
  isEqual(e) {
    return !!(this.id === e.id && this.story && this.story === e.story);
  }
  async renderToElement(e, r) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let t2 = new f2(this.channel, this.store, r, this.csfFiles, true), { docs: n2 } = this.story.parameters || {};
    if (!n2)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let s = await n2.renderer(), { render: i3 } = s, d2 = async () => {
      await new Promise((l2) => i3(t2, n2, e, l2)), this.channel.emit(f, this.id);
    };
    return this.rerender = async () => d2(), this.teardownRender = async ({ viewModeChanged: l2 }) => {
      !l2 || !e || s.unmount(e);
    }, d2();
  }
  async teardown({ viewModeChanged: e } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged: e }), this.torndown = true;
  }
};
var x = class {
  constructor(e, r, t2) {
    this.channel = e;
    this.store = r;
    this.entry = t2;
    this.type = "docs";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = t2.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e, csfFiles: r = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw w;
    this.csfFiles = r, this.exports = e, this.preparing = false;
  }
  isEqual(e) {
    return !!(this.id === e.id && this.exports && this.exports === e.exports);
  }
  async renderToElement(e, r) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let t2 = new f2(this.channel, this.store, r, this.csfFiles, false), { docs: n2 } = this.store.projectAnnotations.parameters || {};
    if (!n2)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let s = { ...n2, page: this.exports.default }, i3 = await n2.renderer(), { render: d2 } = i3, l2 = async () => {
      await new Promise((a2) => d2(t2, s, e, a2)), this.channel.emit(f, this.id);
    };
    return this.rerender = async () => l2(), this.teardownRender = async ({ viewModeChanged: a2 } = {}) => {
      !a2 || !e || (i3.unmount(e), this.torndown = true);
    }, l2();
  }
  async teardown({ viewModeChanged: e } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged: e }), this.torndown = true;
  }
};
var { window: rr } = import_global3.default;
function tr(o2) {
  let e = o2.target;
  return /input|textarea/i.test(e.tagName) || e.getAttribute("contenteditable") !== null;
}
function $(o2) {
  return o2.type === "story";
}
var U2 = class extends T {
  constructor() {
    super();
    this.view = new D2(), this.urlStore = new M();
  }
  setupListeners() {
    super.setupListeners(), rr.onkeydown = this.onKeydown.bind(this), this.channel.on(C, this.onSetCurrentStory.bind(this)), this.channel.on(b, this.onUpdateQueryParams.bind(this)), this.channel.on(a, this.onPreloadStories.bind(this));
  }
  initializeWithProjectAnnotations(r) {
    return super.initializeWithProjectAnnotations(r).then(() => this.setInitialGlobals());
  }
  async setInitialGlobals() {
    if (!this.storyStore.globals)
      throw new Error("Cannot call setInitialGlobals before initialization");
    let { globals: r } = this.urlStore.selectionSpecifier || {};
    r && this.storyStore.globals.updateFromPersisted(r), this.emitGlobals();
  }
  initializeWithStoryIndex(r) {
    return super.initializeWithStoryIndex(r).then(() => {
      var _a;
      return ((_a = import_global3.default.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(N, this.storyStore.getSetIndexPayload()), this.selectSpecifiedStory();
    });
  }
  async selectSpecifiedStory() {
    if (!this.storyStore.storyIndex)
      throw new Error("Cannot call selectSpecifiedStory before initialization");
    if (!this.urlStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier: r, args: t2 } = this.urlStore.selectionSpecifier, n2 = this.storyStore.storyIndex.entryFromSpecifier(r);
    if (!n2) {
      r === "*" ? this.renderStoryLoadingException(r, new Error(dedent`
            Couldn't find any stories in your Storybook.
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `)) : this.renderStoryLoadingException(r, new Error(dedent`
            Couldn't find story matching '${r}'.
            - Are you sure a story with that id exists?
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `));
      return;
    }
    let { id: s, type: i3 } = n2;
    this.urlStore.setSelection({ storyId: s, viewMode: i3 }), this.channel.emit(D, this.urlStore.selection), this.channel.emit(o, this.urlStore.selection), await this.renderSelection({ persistedArgs: t2 });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations: r }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: r }), this.urlStore.selection && this.renderSelection();
  }
  async onStoriesChanged({ importFn: r, storyIndex: t2 }) {
    var _a;
    await super.onStoriesChanged({ importFn: r, storyIndex: t2 }), ((_a = import_global3.default.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(N, await this.storyStore.getSetIndexPayload()), this.urlStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(r) {
    if (!this.storyRenders.find((t2) => t2.disableKeyListeners) && !tr(r)) {
      let { altKey: t2, ctrlKey: n2, metaKey: s, shiftKey: i3, key: d2, code: l2, keyCode: a2 } = r;
      this.channel.emit(h, { event: { altKey: t2, ctrlKey: n2, metaKey: s, shiftKey: i3, key: d2, code: l2, keyCode: a2 } });
    }
  }
  async onSetCurrentStory(r) {
    await this.storyStore.initializationPromise, this.urlStore.setSelection({ viewMode: "story", ...r }), this.channel.emit(o, this.urlStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(r) {
    this.urlStore.setQueryParams(r);
  }
  async onUpdateGlobals({ globals: r }) {
    var _a, _b;
    super.onUpdateGlobals({ globals: r }), (this.currentRender instanceof x || this.currentRender instanceof F2) && await ((_b = (_a = this.currentRender).rerender) == null ? void 0 : _b.call(_a));
  }
  async onUpdateArgs({ storyId: r, updatedArgs: t2 }) {
    super.onUpdateArgs({ storyId: r, updatedArgs: t2 });
  }
  async onPreloadStories({ ids: r }) {
    await Promise.allSettled(r.map((t2) => this.storyStore.loadEntry(t2)));
  }
  async renderSelection({ persistedArgs: r } = {}) {
    var _a, _b, _c, _d;
    let { renderToDOM: t2 } = this;
    if (!t2)
      throw new Error("Cannot call renderSelection before initialization");
    let { selection: n2 } = this.urlStore;
    if (!n2)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId: s } = n2, i3;
    try {
      i3 = await this.storyStore.storyIdToEntry(s);
    } catch (h2) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(s, h2);
      return;
    }
    let d2 = ((_a = this.currentSelection) == null ? void 0 : _a.storyId) !== s, l2 = ((_b = this.currentRender) == null ? void 0 : _b.type) !== i3.type;
    i3.type === "story" ? this.view.showPreparingStory({ immediate: l2 }) : this.view.showPreparingDocs(), ((_c = this.currentRender) == null ? void 0 : _c.isPreparing()) && await this.teardownRender(this.currentRender);
    let a2;
    i3.type === "story" ? a2 = new R(this.channel, this.storyStore, (...h2) => (this.view.showStoryDuringRender(), t2(...h2)), this.mainStoryCallbacks(s), s, "story") : i3.standalone ? a2 = new x(this.channel, this.storyStore, i3) : a2 = new F2(this.channel, this.storyStore, i3);
    let A2 = this.currentSelection;
    this.currentSelection = n2;
    let p2 = this.currentRender;
    this.currentRender = a2;
    try {
      await a2.prepare();
    } catch (h2) {
      h2 !== w && (p2 && await this.teardownRender(p2), this.renderStoryLoadingException(s, h2));
      return;
    }
    let c3 = !d2 && p2 && !a2.isEqual(p2);
    if (r && $(a2)) {
      if (!a2.story)
        throw new Error("Render has not been prepared!");
      this.storyStore.args.updateFromPersisted(a2.story, r);
    }
    if (p2 && !p2.torndown && !d2 && !c3 && !l2) {
      this.currentRender = p2, this.channel.emit(G, s), this.view.showMain();
      return;
    }
    if (p2 && await this.teardownRender(p2, { viewModeChanged: l2 }), A2 && (d2 || l2) && this.channel.emit(d, s), $(a2)) {
      if (!a2.story)
        throw new Error("Render has not been prepared!");
      let { parameters: h2, initialArgs: k, argTypes: _, args: m } = this.storyStore.getStoryContext(a2.story);
      ((_d = import_global3.default.FEATURES) == null ? void 0 : _d.storyStoreV7) && this.channel.emit(L, { id: s, parameters: h2, initialArgs: k, argTypes: _, args: m }), (c3 || r) && this.channel.emit(c, { storyId: s, args: m });
    }
    if ($(a2)) {
      if (!a2.story)
        throw new Error("Render has not been prepared!");
      this.storyRenders.push(a2), this.currentRender.renderToElement(this.view.prepareForStory(a2.story));
    } else
      this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));
  }
  async teardownRender(r, { viewModeChanged: t2 = false } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((n2) => n2 !== r), await ((_a = r == null ? void 0 : r.teardown) == null ? void 0 : _a.call(r, { viewModeChanged: t2 }));
  }
  async extract(r) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = import_global3.default.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(r);
  }
  mainStoryCallbacks(r) {
    return { showMain: () => this.view.showMain(), showError: (t2) => this.renderError(r, t2), showException: (t2) => this.renderException(r, t2) };
  }
  inlineStoryCallbacks(r) {
    return { showMain: () => {
    }, showError: (t2) => i.error(`Error rendering docs story (${r})`, t2), showException: (t2) => i.error(`Error rendering docs story (${r})`, t2) };
  }
  renderPreviewEntryError(r, t2) {
    super.renderPreviewEntryError(r, t2), this.view.showErrorDisplay(t2);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(i2);
  }
  renderStoryLoadingException(r, t2) {
    i.error(t2), this.view.showErrorDisplay(t2), this.channel.emit(i2, r);
  }
  renderException(r, t2) {
    var _a;
    let { name: n2 = "Error", message: s = String(t2), stack: i3 } = t2;
    this.channel.emit(l, { name: n2, message: s, stack: i3 }), this.channel.emit(p, { newPhase: "errored", storyId: r }), ((_a = t2.message) == null ? void 0 : _a.startsWith("ignoredException")) || (this.view.showErrorDisplay(t2), i.error(`Error rendering story '${r}':`), i.error(t2));
  }
  renderError(r, { title: t2, description: n2 }) {
    i.error(`Error rendering story ${t2}: ${n2}`), this.channel.emit(H, { title: t2, description: n2 }), this.channel.emit(p, { newPhase: "errored", storyId: r }), this.view.showErrorDisplay({ message: t2, stack: n2 });
  }
};
var { document: E } = import_global6.default;
var nr = ["application/javascript", "application/ecmascript", "application/x-ecmascript", "application/x-javascript", "text/ecmascript", "text/javascript", "text/javascript1.0", "text/javascript1.1", "text/javascript1.2", "text/javascript1.3", "text/javascript1.4", "text/javascript1.5", "text/jscript", "text/livescript", "text/x-ecmascript", "text/x-javascript", "module"];
var sr = "script";
var ae = "scripts-root";
function Y2() {
  let o2 = E.createEvent("Event");
  o2.initEvent("DOMContentLoaded", true, true), E.dispatchEvent(o2);
}
function ir(o2, e, r) {
  let t2 = E.createElement("script");
  t2.type = o2.type === "module" ? "module" : "text/javascript", o2.src ? (t2.onload = e, t2.onerror = e, t2.src = o2.src) : t2.textContent = o2.innerText, r ? r.appendChild(t2) : E.head.appendChild(t2), o2.parentNode.removeChild(o2), o2.src || e();
}
function de(o2, e, r = 0) {
  o2[r](() => {
    r++, r === o2.length ? e() : de(o2, e, r);
  });
}
function ar(o2) {
  let e = E.getElementById(ae);
  e ? e.innerHTML = "" : (e = E.createElement("div"), e.id = ae, E.body.appendChild(e));
  let r = Array.from(o2.querySelectorAll(sr));
  if (r.length) {
    let t2 = [];
    r.forEach((n2) => {
      let s = n2.getAttribute("type");
      (!s || nr.includes(s)) && t2.push((i3) => ir(n2, i3, e));
    }), t2.length && de(t2, Y2, void 0);
  } else
    Y2();
}

export {
  T,
  f2 as f,
  U2 as U,
  Y2 as Y,
  ar
};
//# sourceMappingURL=chunk-R5J7TEXT.js.map
