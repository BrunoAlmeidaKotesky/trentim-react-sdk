import React, { ReactNode, Component, ReactElement, FC } from 'react';
import { API_Provider, Addon_Types, API_Collection, API_Panels, API_StateMerger, API_Notification, API_Settings, API_StoriesHash, StoryId, API_HashEntry, API_LeafEntry, API_PreparedStoryIndex, API_StoryEntry, API_Args, API_ComposedRef, API_Refs, API_SetRefData, API_ComposedRefUpdate, API_Layout, API_UI, API_PanelPositions, API_Versions, API_UnknownEntries, API_Version, Globals, GlobalTypes, API_ProviderData, API_OptionsData, Parameters, API_ArgTypes } from '@storybook/types';
export { API_ComponentEntry as ComponentEntry, API_ComposedRef as ComposedRef, API_DocsEntry as DocsEntry, API_GroupEntry as GroupEntry, API_HashEntry as HashEntry, API_LeafEntry as LeafEntry, API_Refs as Refs, API_RootEntry as RootEntry, API_StoriesHash as StoriesHash, API_StoryEntry as StoryEntry } from '@storybook/types';
import { NavigateOptions, RouterData } from '@storybook/router';
import { Listener } from '@storybook/channels';
export { Listener as ChannelListener } from '@storybook/channels';
import { toId } from '@storybook/csf';
import { ThemeVars } from '@storybook/theming';
import { S as SubState$9, a as SubAPI$c } from './shortcuts-1ba4dfd5.js';

declare type GetState = () => State;
declare type SetState = (a: any, b: any) => any;
interface Upstream {
    getState: GetState;
    setState: SetState;
}
declare type Patch = Partial<State>;
declare type InputFnPatch = (s: State) => Patch;
declare type InputPatch = Patch | InputFnPatch;
interface Options {
    persistence: 'none' | 'session' | string;
}
declare type CallBack = (s: State) => void;
declare class Store {
    upstreamGetState: GetState;
    upstreamSetState: SetState;
    constructor({ setState, getState }: Upstream);
    getInitialState(base: State): any;
    getState(): State;
    setState(inputPatch: InputPatch, options?: Options): Promise<State>;
    setState(inputPatch: InputPatch, callback?: CallBack, options?: Options): Promise<State>;
}

interface SubAPI$b {
    renderPreview?: API_Provider<API>['renderPreview'];
}

interface SubAPI$a {
    getElements: <T>(type: Addon_Types) => API_Collection<T>;
    getPanels: () => API_Panels;
    getStoryPanels: () => API_Panels;
    getSelectedPanel: () => string;
    setSelectedPanel: (panelName: string) => void;
    setAddonState<S>(addonId: string, newStateOrMerger: S | API_StateMerger<S>, options?: Options): Promise<S>;
    getAddonState<S>(addonId: string): S;
}

interface SubAPI$9 {
    getChannel: () => API_Provider<API>['channel'];
    on: (type: string, cb: Listener) => () => void;
    off: (type: string, cb: Listener) => void;
    emit: (type: string, ...args: any[]) => void;
    once: (type: string, cb: Listener) => void;
    collapseAll: () => void;
    expandAll: () => void;
}

interface SubState$8 {
    notifications: API_Notification[];
}
interface SubAPI$8 {
    addNotification: (notification: API_Notification) => void;
    clearNotification: (id: string) => void;
}

interface SubAPI$7 {
    changeSettingsTab: (tab: string) => void;
    closeSettings: () => void;
    isSettingsScreenActive: () => boolean;
    navigateToSettingsPage: (path: string) => Promise<void>;
}
interface SubState$7 {
    settings: API_Settings;
}

interface SubAPI$6 {
    releaseNotesVersion: () => string;
    setDidViewReleaseNotes: () => void;
    showReleaseNotesOnLaunch: () => boolean;
}
interface SubState$6 {
    releaseNotesViewed: string[];
}

declare type Direction = -1 | 1;
declare type ParameterName = string;
declare type ViewMode = 'story' | 'info' | 'settings' | string | undefined;
declare type StoryUpdate = Pick<API_StoryEntry, 'parameters' | 'initialArgs' | 'argTypes' | 'args'>;
interface SubState$5 {
    storiesHash: API_StoriesHash;
    storyId: StoryId;
    viewMode: ViewMode;
    storiesConfigured: boolean;
    storiesFailed?: Error;
}
interface SubAPI$5 {
    storyId: typeof toId;
    resolveStory: (storyId: StoryId, refsId?: string) => API_HashEntry;
    selectFirstStory: () => void;
    selectStory: (kindOrId?: string, story?: string, obj?: {
        ref?: string;
        viewMode?: ViewMode;
    }) => void;
    getCurrentStoryData: () => API_LeafEntry;
    setIndex: (index: API_PreparedStoryIndex) => Promise<void>;
    jumpToComponent: (direction: Direction) => void;
    jumpToStory: (direction: Direction) => void;
    getData: (storyId: StoryId, refId?: string) => API_LeafEntry;
    isPrepared: (storyId: StoryId, refId?: string) => boolean;
    getParameters: (storyId: StoryId | {
        storyId: StoryId;
        refId: string;
    }, parameterName?: ParameterName) => API_StoryEntry['parameters'] | any;
    getCurrentParameter<S>(parameterName?: ParameterName): S;
    updateStoryArgs(story: API_StoryEntry, newArgs: API_Args): void;
    resetStoryArgs: (story: API_StoryEntry, argNames?: string[]) => void;
    findLeafEntry(StoriesHash: API_StoriesHash, storyId: StoryId): API_LeafEntry;
    findLeafStoryId(StoriesHash: API_StoriesHash, storyId: StoryId): StoryId;
    findSiblingStoryId(storyId: StoryId, hash: API_StoriesHash, direction: Direction, toSiblingGroup: boolean): StoryId;
    fetchIndex: () => Promise<void>;
    updateStory: (storyId: StoryId, update: StoryUpdate, ref?: API_ComposedRef) => Promise<void>;
}

interface SubState$4 {
    refs: API_Refs;
}
interface SubAPI$4 {
    findRef: (source: string) => API_ComposedRef;
    setRef: (id: string, data: API_SetRefData, ready?: boolean) => void;
    updateRef: (id: string, ref: API_ComposedRefUpdate) => void;
    getRefs: () => API_Refs;
    checkRef: (ref: API_SetRefData) => Promise<void>;
    changeRefVersion: (id: string, url: string) => void;
    changeRefState: (id: string, ready: boolean) => void;
}

interface SubState$3 {
    layout: API_Layout;
    ui: API_UI;
    selectedPanel: string | undefined;
    theme: ThemeVars;
}
interface SubAPI$3 {
    toggleFullscreen: (toggled?: boolean) => void;
    togglePanel: (toggled?: boolean) => void;
    togglePanelPosition: (position?: API_PanelPositions) => void;
    toggleNav: (toggled?: boolean) => void;
    toggleToolbar: (toggled?: boolean) => void;
    setOptions: (options: any) => void;
}

interface SubState$2 {
    customQueryParams: QueryParams;
}
interface QueryParams {
    [key: string]: string | null;
}
interface SubAPI$2 {
    navigateUrl: (url: string, options: NavigateOptions) => void;
    getQueryParam: (key: string) => string | undefined;
    getUrlState: () => {
        queryParams: QueryParams;
        path: string;
        viewMode?: string;
        storyId?: string;
        url: string;
    };
    setQueryParams: (input: QueryParams) => void;
}

interface SubState$1 {
    versions: API_Versions & API_UnknownEntries;
    lastVersionCheck: number;
    dismissedVersionNotification: undefined | string;
}
interface SubAPI$1 {
    getCurrentVersion: () => API_Version;
    getLatestVersion: () => API_Version;
    versionUpdateAvailable: () => boolean;
}

interface SubState {
    globals?: Globals;
    globalTypes?: GlobalTypes;
}
interface SubAPI {
    getGlobals: () => Globals;
    getGlobalTypes: () => GlobalTypes;
    updateGlobals: (newGlobals: Globals) => void;
}

declare const _default: <TObj = any>(a: TObj, b: Partial<TObj>) => TObj & Partial<TObj>;

declare const ActiveTabs: {
    SIDEBAR: "sidebar";
    CANVAS: "canvas";
    ADDONS: "addons";
};

declare const ManagerContext: React.Context<{
    api: API;
    state: State;
}>;
declare type ModuleArgs = RouterData & API_ProviderData<API> & {
    mode?: 'production' | 'development';
    state: State;
    fullAPI: API;
    store: Store;
};
declare type State = SubState$3 & SubState$5 & SubState$4 & SubState$8 & SubState$1 & SubState$2 & SubState$9 & SubState$6 & SubState$7 & SubState & RouterData & API_OptionsData & Other;
declare type API = SubAPI$a & SubAPI$9 & SubAPI$b & SubAPI$5 & SubAPI$4 & SubAPI & SubAPI$3 & SubAPI$8 & SubAPI$c & SubAPI$6 & SubAPI$7 & SubAPI$1 & SubAPI$2 & Other;
interface Other {
    [key: string]: any;
}
interface Combo {
    api: API;
    state: State;
}
declare type ManagerProviderProps = RouterData & API_ProviderData<API> & {
    children: ReactNode | ((props: Combo) => ReactNode);
};
declare const combineParameters: (...parameterSets: Parameters[]) => any;
interface ModuleWithInit<APIType = unknown, StateType = unknown> {
    init: () => void | Promise<void>;
    api: APIType;
    state: StateType;
}
declare type ModuleWithoutInit<APIType = unknown, StateType = unknown> = Omit<ModuleWithInit<APIType, StateType>, 'init'>;
declare type ModuleFn<APIType = unknown, StateType = unknown, HasInit = false> = (m: ModuleArgs) => HasInit extends true ? ModuleWithInit<APIType, StateType> : ModuleWithoutInit<APIType, StateType>;
declare class ManagerProvider extends Component<ManagerProviderProps, State> {
    api: API;
    modules: (ModuleWithInit | ModuleWithoutInit)[];
    static displayName: string;
    constructor(props: ManagerProviderProps);
    static getDerivedStateFromProps(props: ManagerProviderProps, state: State): State;
    shouldComponentUpdate(nextProps: ManagerProviderProps, nextState: State): boolean;
    initModules: () => void;
    render(): JSX.Element;
}
interface ManagerConsumerProps<P = unknown> {
    filter?: (combo: Combo) => P;
    children: FC<P> | ReactNode;
}
declare function ManagerConsumer<P = Combo>({ filter, children, }: ManagerConsumerProps<P>): ReactElement;
declare function useStorybookState(): State;
declare function useStorybookApi(): API;

interface API_EventMap {
    [eventId: string]: Listener;
}
declare const useChannel: (eventMap: API_EventMap, deps?: any[]) => (type: string, ...args: any[]) => void;
declare function useStoryPrepared(storyId?: StoryId): boolean;
declare function useParameter<S>(parameterKey: string, defaultValue?: S): S;
declare function useSharedState<S>(stateId: string, defaultState?: S): [S, (newStateOrMerger: S | API_StateMerger<S>, options?: Options) => void];
declare function useAddonState<S>(addonId: string, defaultState?: S): [S, (newStateOrMerger: S | API_StateMerger<S>, options?: Options) => void];
declare function useArgs(): [API_Args, (newArgs: API_Args) => void, (argNames?: string[]) => void];
declare function useGlobals(): [API_Args, (newGlobals: API_Args) => void];
declare function useGlobalTypes(): API_ArgTypes;
declare function useArgTypes(): API_ArgTypes;

export { API, API_EventMap, ActiveTabs, Combo, ManagerConsumer as Consumer, ManagerContext, ManagerProviderProps, ModuleArgs, ModuleFn, ManagerProvider as Provider, State, Options as StoreOptions, combineParameters, _default as merge, useAddonState, useArgTypes, useArgs, useChannel, useGlobalTypes, useGlobals, useParameter, useSharedState, useStoryPrepared, useStorybookApi, useStorybookState };
