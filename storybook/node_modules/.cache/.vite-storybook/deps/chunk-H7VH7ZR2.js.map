{
  "version": 3,
  "sources": ["../../../lodash/isEqual.js", "../../../@storybook/csf/dist/index.mjs"],
  "sourcesContent": ["var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n", "// src/index.ts\nimport startCase from \"lodash/startCase\";\n\n// src/includeConditionalArg.ts\nimport isEqual from \"lodash/isEqual\";\nvar count = (vals) => vals.map((v) => typeof v !== \"undefined\").filter(Boolean).length;\nvar testValue = (cond, value) => {\n  const { exists, eq, neq, truthy } = cond;\n  if (count([exists, eq, neq, truthy]) > 1) {\n    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq, neq })}`);\n  }\n  if (typeof eq !== \"undefined\") {\n    return isEqual(value, eq);\n  }\n  if (typeof neq !== \"undefined\") {\n    return !isEqual(value, neq);\n  }\n  if (typeof exists !== \"undefined\") {\n    const valueExists = typeof value !== \"undefined\";\n    return exists ? valueExists : !valueExists;\n  }\n  const shouldBeTruthy = typeof truthy === \"undefined\" ? true : truthy;\n  return shouldBeTruthy ? !!value : !value;\n};\nvar includeConditionalArg = (argType, args, globals) => {\n  if (!argType.if)\n    return true;\n  const { arg, global } = argType.if;\n  if (count([arg, global]) !== 1) {\n    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global })}`);\n  }\n  const value = arg ? args[arg] : globals[global];\n  return testValue(argType.if, value);\n};\n\n// src/index.ts\nvar sanitize = (string) => {\n  return string.toLowerCase().replace(/[ \u2019\u2013\u2014\u2015\u2032\u00BF'`~!@#$%^&*()_|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\/]/gi, \"-\").replace(/-+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n};\nvar sanitizeSafe = (string, part) => {\n  const sanitized = sanitize(string);\n  if (sanitized === \"\") {\n    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);\n  }\n  return sanitized;\n};\nvar toId = (kind, name) => `${sanitizeSafe(kind, \"kind\")}${name ? `--${sanitizeSafe(name, \"name\")}` : \"\"}`;\nvar storyNameFromExport = (key) => startCase(key);\nfunction matches(storyKey, arrayOrRegex) {\n  if (Array.isArray(arrayOrRegex)) {\n    return arrayOrRegex.includes(storyKey);\n  }\n  return storyKey.match(arrayOrRegex);\n}\nfunction isExportStory(key, { includeStories, excludeStories }) {\n  return key !== \"__esModule\" && (!includeStories || matches(key, includeStories)) && (!excludeStories || !matches(key, excludeStories));\n}\nvar parseKind = (kind, { rootSeparator, groupSeparator }) => {\n  const [root, remainder] = kind.split(rootSeparator, 2);\n  const groups = (remainder || kind).split(groupSeparator).filter((i) => !!i);\n  return {\n    root: remainder ? root : null,\n    groups\n  };\n};\nexport {\n  includeConditionalArg,\n  isExportStory,\n  parseKind,\n  sanitize,\n  storyNameFromExport,\n  toId\n};\n"],
  "mappings": ";;;;;;;;;;;;AAAA;AAAA;AAAA,QAAI,cAAc;AA8BlB,aAASA,SAAQ,OAAO,OAAO;AAC7B,aAAO,YAAY,OAAO,KAAK;AAAA,IACjC;AAEA,WAAO,UAAUA;AAAA;AAAA;;;ACjCjB,uBAAsB;AAGtB,qBAAoB;AACpB,IAAI,QAAQ,CAAC,SAAS,KAAK,IAAI,CAAC,MAAM,OAAO,MAAM,WAAW,EAAE,OAAO,OAAO,EAAE;AAChF,IAAI,YAAY,CAAC,MAAM,UAAU;AAC/B,QAAM,EAAE,QAAQ,IAAI,KAAK,OAAO,IAAI;AACpC,MAAI,MAAM,CAAC,QAAQ,IAAI,KAAK,MAAM,CAAC,IAAI,GAAG;AACxC,UAAM,IAAI,MAAM,4BAA4B,KAAK,UAAU,EAAE,QAAQ,IAAI,IAAI,CAAC,GAAG;AAAA,EACnF;AACA,MAAI,OAAO,OAAO,aAAa;AAC7B,eAAO,eAAAC,SAAQ,OAAO,EAAE;AAAA,EAC1B;AACA,MAAI,OAAO,QAAQ,aAAa;AAC9B,WAAO,KAAC,eAAAA,SAAQ,OAAO,GAAG;AAAA,EAC5B;AACA,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,cAAc,OAAO,UAAU;AACrC,WAAO,SAAS,cAAc,CAAC;AAAA,EACjC;AACA,QAAM,iBAAiB,OAAO,WAAW,cAAc,OAAO;AAC9D,SAAO,iBAAiB,CAAC,CAAC,QAAQ,CAAC;AACrC;AACA,IAAI,wBAAwB,CAAC,SAAS,MAAM,YAAY;AACtD,MAAI,CAAC,QAAQ;AACX,WAAO;AACT,QAAM,EAAE,KAAK,OAAO,IAAI,QAAQ;AAChC,MAAI,MAAM,CAAC,KAAK,MAAM,CAAC,MAAM,GAAG;AAC9B,UAAM,IAAI,MAAM,6BAA6B,KAAK,UAAU,EAAE,KAAK,OAAO,CAAC,GAAG;AAAA,EAChF;AACA,QAAM,QAAQ,MAAM,KAAK,OAAO,QAAQ;AACxC,SAAO,UAAU,QAAQ,IAAI,KAAK;AACpC;AAGA,IAAI,WAAW,CAAC,WAAW;AACzB,SAAO,OAAO,YAAY,EAAE,QAAQ,uDAAuD,GAAG,EAAE,QAAQ,OAAO,GAAG,EAAE,QAAQ,OAAO,EAAE,EAAE,QAAQ,OAAO,EAAE;AAC1J;AACA,IAAI,eAAe,CAAC,QAAQ,SAAS;AACnC,QAAM,YAAY,SAAS,MAAM;AACjC,MAAI,cAAc,IAAI;AACpB,UAAM,IAAI,MAAM,WAAW,SAAS,+CAA+C;AAAA,EACrF;AACA,SAAO;AACT;AACA,IAAI,OAAO,CAAC,MAAM,SAAS,GAAG,aAAa,MAAM,MAAM,IAAI,OAAO,KAAK,aAAa,MAAM,MAAM,MAAM;AACtG,IAAI,sBAAsB,CAAC,YAAQ,iBAAAC,SAAU,GAAG;AAChD,SAAS,QAAQ,UAAU,cAAc;AACvC,MAAI,MAAM,QAAQ,YAAY,GAAG;AAC/B,WAAO,aAAa,SAAS,QAAQ;AAAA,EACvC;AACA,SAAO,SAAS,MAAM,YAAY;AACpC;AACA,SAAS,cAAc,KAAK,EAAE,gBAAgB,eAAe,GAAG;AAC9D,SAAO,QAAQ,iBAAiB,CAAC,kBAAkB,QAAQ,KAAK,cAAc,OAAO,CAAC,kBAAkB,CAAC,QAAQ,KAAK,cAAc;AACtI;",
  "names": ["isEqual", "isEqual", "startCase"]
}
