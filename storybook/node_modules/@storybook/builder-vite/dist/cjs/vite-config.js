"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commonConfig = commonConfig;
exports.pluginConfig = pluginConfig;

var path = _interopRequireWildcard(require("path"));

var _vite = require("vite");

var _pluginReact = _interopRequireDefault(require("@vitejs/plugin-react"));

var _coreCommon = require("@storybook/core-common");

var _envs = require("./envs");

var _plugins = require("./plugins");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const configEnvServe = {
  mode: 'development',
  command: 'serve',
  ssrBuild: false
};
const configEnvBuild = {
  mode: 'production',
  command: 'build',
  ssrBuild: false
}; // Vite config that is common to development and production mode

async function commonConfig(options, _type) {
  const {
    presets
  } = options;
  const configEnv = _type === 'development' ? configEnvServe : configEnvBuild;
  const {
    config: userConfig = {}
  } = (await (0, _vite.loadConfigFromFile)(configEnv)) ?? {};
  const sbConfig = {
    configFile: false,
    cacheDir: 'node_modules/.cache/.vite-storybook',
    root: path.resolve(options.configDir, '..'),
    // Allow storybook deployed as subfolder.  See https://github.com/storybookjs/builder-vite/issues/238
    base: './',
    plugins: await pluginConfig(options),
    resolve: {
      preserveSymlinks: (0, _coreCommon.isPreservingSymlinks)(),
      alias: {
        assert: require.resolve('browser-assert')
      }
    },
    // If an envPrefix is specified in the vite config, add STORYBOOK_ to it,
    // otherwise, add VITE_ and STORYBOOK_ so that vite doesn't lose its default.
    envPrefix: userConfig.envPrefix ? 'STORYBOOK_' : ['VITE_', 'STORYBOOK_']
  };
  const config = (0, _vite.mergeConfig)(userConfig, sbConfig); // Sanitize environment variables if needed

  const envsRaw = await presets.apply('env');

  if (Object.keys(envsRaw).length) {
    // Stringify env variables after getting `envPrefix` from the  config
    const envs = (0, _envs.stringifyProcessEnvs)(envsRaw, config.envPrefix);
    config.define = Object.assign({}, config.define, envs);
  }

  return config;
}

async function pluginConfig(options) {
  const frameworkName = await (0, _coreCommon.getFrameworkName)(options);
  const plugins = [(0, _plugins.codeGeneratorPlugin)(options), // sourceLoaderPlugin(options),
  (0, _plugins.mdxPlugin)(), _plugins.injectExportOrderPlugin, (0, _plugins.stripStoryHMRBoundary)(), {
    name: 'storybook:allow-storybook-dir',
    enforce: 'post',

    config(config) {
      var _config$server, _config$server$fs;

      // if there is NO allow list then Vite allows anything in the root directory
      // if there is an allow list then Vite only allows anything in the listed directories
      // add storybook specific directories only if there's an allow list so that we don't end up
      // disallowing the root unless root is already disallowed
      if (config !== null && config !== void 0 && (_config$server = config.server) !== null && _config$server !== void 0 && (_config$server$fs = _config$server.fs) !== null && _config$server$fs !== void 0 && _config$server$fs.allow) {
        config.server.fs.allow.push('.storybook');
      }
    }

  }]; // We need the react plugin here to support MDX in non-react projects.

  if (frameworkName !== '@storybook/react-vite') {
    plugins.push((0, _pluginReact.default)({
      exclude: [/\.stories\.([tj])sx?$/, /node_modules/, /\.([tj])sx?$/]
    }));
  } // TODO: framework doesn't exist, should move into framework when/if built


  if (frameworkName === '@storybook/preact-vite') {
    // eslint-disable-next-line global-require
    plugins.push(require('@preact/preset-vite').default());
  } // TODO: framework doesn't exist, should move into framework when/if built


  if (frameworkName === '@storybook/glimmerx-vite') {
    // eslint-disable-next-line global-require, import/extensions
    const plugin = require('vite-plugin-glimmerx/index.cjs');

    plugins.push(plugin.default());
  }

  return plugins;
}