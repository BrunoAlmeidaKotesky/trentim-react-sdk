import type { Paths, TypeFrom } from 'bakutils-types';
/**Get a value from a deep nested object.
 *
 * @param obj The object to search in.
 * @param path The path to the value, as an array of keys, separated by dots.
 * @returns The value, if found.
 *
 * @example
 *
 * ```ts
 * const obj = {a: {b: {c: {d: 2}}}};
 * const value = getDeepValue(obj, 'a.b.c.d'); //2 - And inferred as a number
 * ```
 */
export declare function getDeepValue<
/**Inferred string path from the given object  */
Path extends Paths<Obj, 8>, ReturnV extends any = unknown, Obj extends Record<any, any> = Record<any, any>>(nestedObj: Obj, path: Path): ReturnV;
/**
 * Change the value of a property in a deep nested object, mutating the original object.
 * @param obj The object to search in.
 * @param path The path to the value, as an array of keys, separated by dots.
 * @param value The new value to bet set.
 * @returns a new object with the value set, however the original object is **also modified**.
 *
 * @example
 * ```ts
 * const obj = {a: {b: {c: 1}}};
 * setDeepValue(obj, 'a.b.c', 2);
 * ```
 */
export declare const setDeepValue: <Obj extends Record<any, any>, Path extends string = Obj extends object ? (Obj extends infer T ? { [K in keyof T]-?: K extends string | number ? `${K}` | import("bakutils-types").Join<K, Obj[K] extends infer T_1 ? T_1 extends Obj[K] ? T_1 extends object ? (T_1 extends infer T_2 ? { [K_1 in keyof T_2]-?: K_1 extends string | number ? `${K_1}` | import("bakutils-types").Join<K_1, T_1[K_1] extends infer T_3 ? T_3 extends T_1[K_1] ? T_3 extends object ? (T_3 extends infer T_4 ? { [K_2 in keyof T_4]-?: K_2 extends string | number ? `${K_2}` | import("bakutils-types").Join<K_2, T_3[K_2] extends infer T_5 ? T_5 extends T_3[K_2] ? T_5 extends object ? (T_5 extends infer T_6 ? { [K_3 in keyof T_6]-?: K_3 extends string | number ? `${K_3}` | import("bakutils-types").Join<K_3, T_5[K_3] extends infer T_7 ? T_7 extends T_5[K_3] ? T_7 extends object ? (T_7 extends infer T_8 ? { [K_4 in keyof T_8]-?: K_4 extends string | number ? `${K_4}` | import("bakutils-types").Join<K_4, never> : never; } : never)[keyof T_7] : "" : never : never> : never; } : never)[keyof T_5] : "" : never : never> : never; } : never)[keyof T_3] : "" : never : never> : never; } : never)[keyof T_1] : "" : never : never> : never; } : never)[keyof Obj] : "">(obj: Obj, path: Path, value: TypeFrom<Obj, Path>) => Obj;
/**
 * This is similar to `Object.keys`, but it traverses through the whole object hierarchy and separates the nested keys by dots.
 * @param obj The object to get the keys from.
 * @return The array of all the existing keys.
 *
 * @example
 * ```ts
 * const obj = {a: {b: {c: 1}}};
 * const keys = getDeepKeys(obj); //['a', 'a.b', 'a.b.c'] - string[] | ("a" | "a.b" | "a.b.c")[]
 * ```
 */
export declare function getDeepKeys<ResultKeys extends Array<Paths<Obj, 8>>, Obj extends Record<any, any> = Record<any, any>>(obj: Obj): ResultKeys | string[];
/**
 * Get the search parameters from the URL as an object.
 * You can type the possible search parameters as it's first type parameter.
 * @param asLowerCase If true, the keys of the returned object will be lowercased.
 *
 * @returns The search parameters as an object.
 *
 * @example
 * ```typescript
 * const searchParams = getSearchParams<'projectid'|'username'>(true); //Record<'projectid' | 'username', string>
 * ```
 */
export declare function getSearchParamsAsObject<Keys extends string, AsLowerCase extends boolean = false | true>(asLowerCase: AsLowerCase): Record<AsLowerCase extends true ? Lowercase<Keys> : Keys, string>;
/**The same method as `JSON.parse`, but it handles it when it fails, automatically returning null (If fallback value is not set).
 * @param json The json string
 * @param fallbackValue A value if the parse fails
 * @returns the parsed json, or the fallback value if the parse fails.*/
export declare const tryJSONParse: <Result, Fallback = null>(json: string, fallbackValue?: Fallback) => (Result | Fallback | null);
