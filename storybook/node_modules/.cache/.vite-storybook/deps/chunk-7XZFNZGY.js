import {
  isJSON,
  parse,
  stringify
} from "./chunk-3R5MGDK7.js";
import {
  require_lib
} from "./chunk-3OL5LWJI.js";
import {
  dist_exports
} from "./chunk-M3XCZAQ7.js";
import {
  r
} from "./chunk-EF2YLWYO.js";
import {
  i,
  o
} from "./chunk-3QDDUDC7.js";
import {
  require_window
} from "./chunk-Z3ID2O7F.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@storybook/channel-postmessage/dist/index.mjs
var import_global = __toESM(require_window(), 1);
var import_qs = __toESM(require_lib(), 1);
var { window: n, document: l, location: d } = import_global.default;
var y = "storybook-channel";
var N = { allowFunction: true, maxDepth: 25 };
var h = class {
  constructor(r2) {
    this.config = r2;
    if (this.buffer = [], this.handler = null, n && n.addEventListener("message", this.handleEvent.bind(this), false), r2.page !== "manager" && r2.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${r2.page}"`);
  }
  setHandler(r2) {
    this.handler = (...e) => {
      r2.apply(this, e), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = true);
    };
  }
  send(r2, e) {
    let { target: o2, allowRegExp: t, allowFunction: a, allowSymbol: s, allowDate: i2, allowUndefined: f, allowClass: w, maxDepth: E, space: C, lazyEval: F } = e || {}, k = Object.fromEntries(Object.entries({ allowRegExp: t, allowFunction: a, allowSymbol: s, allowDate: i2, allowUndefined: f, allowClass: w, maxDepth: E, space: C, lazyEval: F }).filter(([p, u]) => typeof u < "u")), $ = { ...N, ...import_global.default.CHANNEL_OPTIONS || {}, ...k }, m = this.getFrames(o2), S = import_qs.default.parse(d.search, { ignoreQueryPrefix: true }), O = stringify({ key: y, event: r2, refId: S.refId }, $);
    return m.length ? (this.buffer.length && this.flush(), m.forEach((p) => {
      try {
        p.postMessage(O, "*");
      } catch {
        console.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((p, u) => {
      this.buffer.push({ event: r2, resolve: p, reject: u });
    });
  }
  flush() {
    let { buffer: r2 } = this;
    this.buffer = [], r2.forEach((e) => {
      this.send(e.event).then(e.resolve).catch(e.reject);
    });
  }
  getFrames(r2) {
    if (this.config.page === "manager") {
      let o2 = [...l.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")].filter((t) => {
        try {
          return !!t.contentWindow && t.dataset.isStorybook !== void 0 && t.id === r2;
        } catch {
          return false;
        }
      }).map((t) => t.contentWindow);
      return o2.length ? o2 : this.getCurrentFrames();
    }
    return n && n.parent && n.parent !== n ? [n.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? [...l.querySelectorAll('[data-is-storybook="true"]')].map((e) => e.contentWindow) : n && n.parent ? [n.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? [...l.querySelectorAll("#storybook-preview-iframe")].map((e) => e.contentWindow) : n && n.parent ? [n.parent] : [];
  }
  handleEvent(r2) {
    try {
      let { data: e } = r2, { key: o2, event: t, refId: a } = typeof e == "string" && isJSON(e) ? parse(e, import_global.default.CHANNEL_OPTIONS || {}) : e;
      if (o2 === y) {
        let s = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', i2 = Object.values(dist_exports).includes(t.type) ? `<span style="color: #FF4785">${t.type}</span>` : `<span style="color: #FFAE00">${t.type}</span>`;
        if (a && (t.refId = a), t.source = this.config.page === "preview" ? r2.origin : q(r2), !t.source) {
          o.error(`${s} received ${i2} but was unable to determine the source of the event`);
          return;
        }
        let f = `${s} received ${i2} (${e.length})`;
        o.debug(d.origin !== t.source ? f : `${f} <span style="color: gray">(on ${d.origin} from ${t.source})</span>`, ...t.args), this.handler(t);
      }
    } catch (e) {
      i.error(e);
    }
  }
};
var q = (c) => {
  let r2 = [...l.querySelectorAll("iframe[data-is-storybook]")], [e, ...o2] = r2.filter((t) => {
    try {
      return t.contentWindow === c.source;
    } catch {
    }
    let a = t.getAttribute("src"), s;
    try {
      ({ origin: s } = new URL(a, l.location));
    } catch {
      return false;
    }
    return s === c.origin;
  });
  if (e && o2.length === 0) {
    let t = e.getAttribute("src"), { protocol: a, host: s, pathname: i2 } = new URL(t, l.location);
    return `${a}//${s}${i2}`;
  }
  return o2.length > 0 && i.error("found multiple candidates for event source"), null;
};
function D({ page: c }) {
  let r2 = new h({ page: c });
  return new r({ transport: r2 });
}
var B = D;

export {
  y,
  h,
  D,
  B
};
//# sourceMappingURL=chunk-7XZFNZGY.js.map
