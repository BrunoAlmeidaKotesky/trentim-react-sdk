import * as t from '@babel/types';
import { CSF_Meta, CSF_Story } from '@storybook/types';

interface CsfOptions {
    fileName?: string;
    makeTitle: (userTitle: string) => string;
}
declare class NoMetaError extends Error {
    constructor(ast: t.Node, fileName?: string);
}
declare class CsfFile {
    _ast: t.File;
    _fileName: string;
    _makeTitle: (title: string) => string;
    _meta?: CSF_Meta;
    _stories: Record<string, CSF_Story>;
    _metaAnnotations: Record<string, t.Node>;
    _storyExports: Record<string, t.VariableDeclarator | t.FunctionDeclaration>;
    _storyStatements: Record<string, t.ExportNamedDeclaration>;
    _storyAnnotations: Record<string, Record<string, t.Node>>;
    _templates: Record<string, t.Expression>;
    _namedExportsOrder?: string[];
    imports: string[];
    constructor(ast: t.File, { fileName, makeTitle }: CsfOptions);
    _parseTitle(value: t.Node): string;
    _parseMeta(declaration: t.ObjectExpression, program: t.Program): void;
    getStoryExport(key: string): t.File | t.AnyTypeAnnotation | t.ArgumentPlaceholder | t.ArrayExpression | t.ArrayPattern | t.ArrayTypeAnnotation | t.ArrowFunctionExpression | t.AssignmentExpression | t.AssignmentPattern | t.AwaitExpression | t.BigIntLiteral | t.BinaryExpression | t.BindExpression | t.BlockStatement | t.BooleanLiteral | t.BooleanLiteralTypeAnnotation | t.BooleanTypeAnnotation | t.BreakStatement | t.CallExpression | t.CatchClause | t.ClassAccessorProperty | t.ClassBody | t.ClassDeclaration | t.ClassExpression | t.ClassImplements | t.ClassMethod | t.ClassPrivateMethod | t.ClassPrivateProperty | t.ClassProperty | t.ConditionalExpression | t.ContinueStatement | t.DebuggerStatement | t.DecimalLiteral | t.DeclareClass | t.DeclareExportAllDeclaration | t.DeclareExportDeclaration | t.DeclareFunction | t.DeclareInterface | t.DeclareModule | t.DeclareModuleExports | t.DeclareOpaqueType | t.DeclareTypeAlias | t.DeclareVariable | t.DeclaredPredicate | t.Decorator | t.Directive | t.DirectiveLiteral | t.DoExpression | t.DoWhileStatement | t.EmptyStatement | t.EmptyTypeAnnotation | t.EnumBooleanBody | t.EnumBooleanMember | t.EnumDeclaration | t.EnumDefaultedMember | t.EnumNumberBody | t.EnumNumberMember | t.EnumStringBody | t.EnumStringMember | t.EnumSymbolBody | t.ExistsTypeAnnotation | t.ExportAllDeclaration | t.ExportDefaultDeclaration | t.ExportDefaultSpecifier | t.ExportNamedDeclaration | t.ExportNamespaceSpecifier | t.ExportSpecifier | t.ExpressionStatement | t.ForInStatement | t.ForOfStatement | t.ForStatement | t.FunctionDeclaration | t.FunctionExpression | t.FunctionTypeAnnotation | t.FunctionTypeParam | t.GenericTypeAnnotation | t.Identifier | t.IfStatement | t.Import | t.ImportAttribute | t.ImportDeclaration | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier | t.ImportSpecifier | t.IndexedAccessType | t.InferredPredicate | t.InterfaceDeclaration | t.InterfaceExtends | t.InterfaceTypeAnnotation | t.InterpreterDirective | t.IntersectionTypeAnnotation | t.JSXAttribute | t.JSXClosingElement | t.JSXClosingFragment | t.JSXElement | t.JSXEmptyExpression | t.JSXExpressionContainer | t.JSXFragment | t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName | t.JSXOpeningElement | t.JSXOpeningFragment | t.JSXSpreadAttribute | t.JSXSpreadChild | t.JSXText | t.LabeledStatement | t.LogicalExpression | t.MemberExpression | t.MetaProperty | t.MixedTypeAnnotation | t.ModuleExpression | t.NewExpression | t.Noop | t.NullLiteral | t.NullLiteralTypeAnnotation | t.NullableTypeAnnotation | t.NumberLiteral | t.NumberLiteralTypeAnnotation | t.NumberTypeAnnotation | t.NumericLiteral | t.ObjectExpression | t.ObjectMethod | t.ObjectPattern | t.ObjectProperty | t.ObjectTypeAnnotation | t.ObjectTypeCallProperty | t.ObjectTypeIndexer | t.ObjectTypeInternalSlot | t.ObjectTypeProperty | t.ObjectTypeSpreadProperty | t.OpaqueType | t.OptionalCallExpression | t.OptionalIndexedAccessType | t.OptionalMemberExpression | t.ParenthesizedExpression | t.PipelineBareFunction | t.PipelinePrimaryTopicReference | t.PipelineTopicExpression | t.Placeholder | t.PrivateName | t.Program | t.QualifiedTypeIdentifier | t.RecordExpression | t.RegExpLiteral | t.RegexLiteral | t.RestElement | t.RestProperty | t.ReturnStatement | t.SequenceExpression | t.SpreadElement | t.SpreadProperty | t.StaticBlock | t.StringLiteral | t.StringLiteralTypeAnnotation | t.StringTypeAnnotation | t.Super | t.SwitchCase | t.SwitchStatement | t.SymbolTypeAnnotation | t.TSAnyKeyword | t.TSArrayType | t.TSAsExpression | t.TSBigIntKeyword | t.TSBooleanKeyword | t.TSCallSignatureDeclaration | t.TSConditionalType | t.TSConstructSignatureDeclaration | t.TSConstructorType | t.TSDeclareFunction | t.TSDeclareMethod | t.TSEnumDeclaration | t.TSEnumMember | t.TSExportAssignment | t.TSExpressionWithTypeArguments | t.TSExternalModuleReference | t.TSFunctionType | t.TSImportEqualsDeclaration | t.TSImportType | t.TSIndexSignature | t.TSIndexedAccessType | t.TSInferType | t.TSInstantiationExpression | t.TSInterfaceBody | t.TSInterfaceDeclaration | t.TSIntersectionType | t.TSIntrinsicKeyword | t.TSLiteralType | t.TSMappedType | t.TSMethodSignature | t.TSModuleBlock | t.TSModuleDeclaration | t.TSNamedTupleMember | t.TSNamespaceExportDeclaration | t.TSNeverKeyword | t.TSNonNullExpression | t.TSNullKeyword | t.TSNumberKeyword | t.TSObjectKeyword | t.TSOptionalType | t.TSParameterProperty | t.TSParenthesizedType | t.TSPropertySignature | t.TSQualifiedName | t.TSRestType | t.TSStringKeyword | t.TSSymbolKeyword | t.TSThisType | t.TSTupleType | t.TSTypeAliasDeclaration | t.TSTypeAnnotation | t.TSTypeAssertion | t.TSTypeLiteral | t.TSTypeOperator | t.TSTypeParameter | t.TSTypeParameterDeclaration | t.TSTypeParameterInstantiation | t.TSTypePredicate | t.TSTypeQuery | t.TSTypeReference | t.TSUndefinedKeyword | t.TSUnionType | t.TSUnknownKeyword | t.TSVoidKeyword | t.TaggedTemplateExpression | t.TemplateElement | t.TemplateLiteral | t.ThisExpression | t.ThisTypeAnnotation | t.ThrowStatement | t.TopicReference | t.TryStatement | t.TupleExpression | t.TupleTypeAnnotation | t.TypeAlias | t.TypeAnnotation | t.TypeCastExpression | t.TypeParameter | t.TypeParameterDeclaration | t.TypeParameterInstantiation | t.TypeofTypeAnnotation | t.UnaryExpression | t.UnionTypeAnnotation | t.UpdateExpression | t.V8IntrinsicIdentifier | t.VariableDeclaration | t.Variance | t.VoidTypeAnnotation | t.WhileStatement | t.WithStatement | t.YieldExpression;
    parse(): this;
    get meta(): CSF_Meta;
    get stories(): CSF_Story[];
}
declare const loadCsf: (code: string, options: CsfOptions) => CsfFile;
declare const formatCsf: (csf: CsfFile) => string;
declare const readCsf: (fileName: string, options: CsfOptions) => Promise<CsfFile>;
declare const writeCsf: (csf: CsfFile, fileName?: string) => Promise<void>;

declare class ConfigFile {
    _ast: t.File;
    _code: string;
    _exports: Record<string, t.Expression>;
    _exportsObject: t.ObjectExpression;
    _quotes: 'single' | 'double' | undefined;
    fileName?: string;
    constructor(ast: t.File, code: string, fileName?: string);
    parse(): this;
    getFieldNode(path: string[]): t.Node;
    getFieldValue(path: string[]): any;
    setFieldNode(path: string[], expr: t.Expression): void;
    _inferQuotes(): "single" | "double";
    setFieldValue(path: string[], value: any): void;
}
declare const loadConfig: (code: string, fileName?: string) => ConfigFile;
declare const formatConfig: (config: ConfigFile) => string;
declare const readConfig: (fileName: string) => Promise<ConfigFile>;
declare const writeConfig: (config: ConfigFile, fileName?: string) => Promise<void>;

declare const getStorySortParameter: (previewCode: string) => any;

interface EnrichCsfOptions {
    disableSource?: boolean;
    disableDescription?: boolean;
}
declare const enrichCsf: (csf: CsfFile, options?: EnrichCsfOptions) => void;
declare const extractSource: (node: t.Node) => string;
declare const extractDescription: (node?: t.Node) => string;

export { ConfigFile, CsfFile, CsfOptions, EnrichCsfOptions, NoMetaError, enrichCsf, extractDescription, extractSource, formatConfig, formatCsf, getStorySortParameter, loadConfig, loadCsf, readConfig, readCsf, writeConfig, writeCsf };
