import {
  require_build
} from "./chunk-CPJIKRDZ.js";
import {
  c
} from "./chunk-UACHQL3Y.js";
import "./chunk-VN7B5P5J.js";
import {
  C,
  Y,
  e,
  p
} from "./chunk-M3XCZAQ7.js";
import "./chunk-EF2YLWYO.js";
import {
  i,
  n
} from "./chunk-3QDDUDC7.js";
import {
  require_window
} from "./chunk-Z3ID2O7F.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@storybook/instrumenter/dist/index.mjs
var import_global = __toESM(require_window(), 1);
var x = ((l2) => (l2.DONE = "done", l2.ERROR = "error", l2.ACTIVE = "active", l2.WAITING = "waiting", l2))(x || {});
var y = { CALL: "storybook/instrumenter/call", SYNC: "storybook/instrumenter/sync", START: "storybook/instrumenter/start", BACK: "storybook/instrumenter/back", GOTO: "storybook/instrumenter/goto", NEXT: "storybook/instrumenter/next", END: "storybook/instrumenter/end" };
var _a;
var A = ((_a = import_global.default.FEATURES) == null ? void 0 : _a.interactionsDebugger) !== true;
var C2 = { debugger: !A, start: false, back: false, goto: false, next: false, end: false };
var E = new Error("This function ran after the play function completed. Did you forget to `await` it?");
var N = (u) => Object.prototype.toString.call(u) === "[object Object]";
var B = (u) => Object.prototype.toString.call(u) === "[object Module]";
var M = (u) => {
  if (!N(u) && !B(u))
    return false;
  if (u.constructor === void 0)
    return true;
  let s2 = u.constructor.prototype;
  return !(!N(s2) || Object.prototype.hasOwnProperty.call(s2, "isPrototypeOf") === false);
};
var Y2 = (u) => {
  try {
    return new u.constructor();
  } catch {
    return {};
  }
};
var m = () => ({ renderPhase: void 0, isDebugging: false, isPlaying: false, isLocked: false, cursor: 0, calls: [], shadowCalls: [], callRefsByResult: /* @__PURE__ */ new Map(), chainedCallIds: /* @__PURE__ */ new Set(), ancestors: [], playUntil: void 0, resolvers: {}, syncTimeout: void 0 });
var w = (u, s2 = false) => {
  let t = (s2 ? u.shadowCalls : u.calls).filter((l2) => l2.retain);
  if (!t.length)
    return;
  let d2 = new Map(Array.from(u.callRefsByResult.entries()).filter(([, l2]) => l2.retain));
  return { cursor: t.length, calls: t, callRefsByResult: d2 };
};
var O = class {
  constructor() {
    this.initialized = false;
    this.channel = c.getChannel(), this.state = import_global.default.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
    let s2 = ({ storyId: n2, isPlaying: r = true, isDebugging: e2 = false }) => {
      let a2 = this.getState(n2);
      this.setState(n2, { ...m(), ...w(a2, e2), shadowCalls: e2 ? a2.shadowCalls : [], chainedCallIds: e2 ? a2.chainedCallIds : /* @__PURE__ */ new Set(), playUntil: e2 ? a2.playUntil : void 0, isPlaying: r, isDebugging: e2 }), this.sync(n2);
    };
    this.channel.on(Y, s2), this.channel.on(p, ({ storyId: n2, newPhase: r }) => {
      let { isDebugging: e2 } = this.getState(n2);
      this.setState(n2, { renderPhase: r }), r === "preparing" && e2 && s2({ storyId: n2 }), r === "playing" && s2({ storyId: n2, isDebugging: e2 }), r === "played" && this.setState(n2, { isLocked: false, isPlaying: false, isDebugging: false }), r === "errored" && this.setState(n2, { isLocked: false, isPlaying: false });
    }), this.channel.on(C, () => {
      this.initialized ? this.cleanup() : this.initialized = true;
    });
    let t = ({ storyId: n2, playUntil: r }) => {
      this.getState(n2).isDebugging || this.setState(n2, ({ calls: a2 }) => ({ calls: [], shadowCalls: a2.map((i3) => ({ ...i3, status: "waiting" })), isDebugging: true }));
      let e2 = this.getLog(n2);
      this.setState(n2, ({ shadowCalls: a2 }) => {
        var _a2;
        if (r || !e2.length)
          return { playUntil: r };
        let i3 = a2.findIndex((f2) => f2.id === e2[0].callId);
        return { playUntil: (_a2 = a2.slice(0, i3).filter((f2) => f2.interceptable && !f2.ancestors.length).slice(-1)[0]) == null ? void 0 : _a2.id };
      }), this.channel.emit(Y, { storyId: n2, isDebugging: true });
    }, d2 = ({ storyId: n2 }) => {
      var _a2;
      let r = this.getLog(n2).filter((a2) => !a2.ancestors.length), e2 = r.reduceRight((a2, i3, f2) => a2 >= 0 || i3.status === "waiting" ? a2 : f2, -1);
      t({ storyId: n2, playUntil: (_a2 = r[e2 - 1]) == null ? void 0 : _a2.callId });
    }, l2 = ({ storyId: n2, callId: r }) => {
      var _a2;
      let { calls: e2, shadowCalls: a2, resolvers: i3 } = this.getState(n2), f2 = e2.find(({ id: _2 }) => _2 === r), g = a2.find(({ id: _2 }) => _2 === r);
      if (!f2 && g && Object.values(i3).length > 0) {
        let _2 = (_a2 = this.getLog(n2).find((p2) => p2.status === "waiting")) == null ? void 0 : _a2.callId;
        g.id !== _2 && this.setState(n2, { playUntil: g.id }), Object.values(i3).forEach((p2) => p2());
      } else
        t({ storyId: n2, playUntil: r });
    }, o = ({ storyId: n2 }) => {
      var _a2;
      let { resolvers: r } = this.getState(n2);
      if (Object.values(r).length > 0)
        Object.values(r).forEach((e2) => e2());
      else {
        let e2 = (_a2 = this.getLog(n2).find((a2) => a2.status === "waiting")) == null ? void 0 : _a2.callId;
        e2 ? t({ storyId: n2, playUntil: e2 }) : c3({ storyId: n2 });
      }
    }, c3 = ({ storyId: n2 }) => {
      this.setState(n2, { playUntil: void 0, isDebugging: false }), Object.values(this.getState(n2).resolvers).forEach((r) => r());
    };
    this.channel.on(y.START, t), this.channel.on(y.BACK, d2), this.channel.on(y.GOTO, l2), this.channel.on(y.NEXT, o), this.channel.on(y.END, c3);
  }
  getState(s2) {
    return this.state[s2] || m();
  }
  setState(s2, t) {
    let d2 = this.getState(s2), l2 = typeof t == "function" ? t(d2) : t;
    this.state = { ...this.state, [s2]: { ...d2, ...l2 } }, import_global.default.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce((t, [d2, l2]) => {
      let o = w(l2);
      return o && (t[d2] = Object.assign(m(), o)), t;
    }, {});
    let s2 = { controlStates: C2, logItems: [] };
    this.channel.emit(y.SYNC, s2), import_global.default.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
  }
  getLog(s2) {
    let { calls: t, shadowCalls: d2 } = this.getState(s2), l2 = [...d2];
    t.forEach((c3, n2) => {
      l2[n2] = c3;
    });
    let o = /* @__PURE__ */ new Set();
    return l2.reduceRight((c3, n2) => (n2.args.forEach((r) => {
      (r == null ? void 0 : r.__callId__) && o.add(r.__callId__);
    }), n2.path.forEach((r) => {
      r.__callId__ && o.add(r.__callId__);
    }), (n2.interceptable || n2.exception) && !o.has(n2.id) && (c3.unshift({ callId: n2.id, status: n2.status, ancestors: n2.ancestors }), o.add(n2.id)), c3), []);
  }
  instrument(s2, t) {
    if (!M(s2))
      return s2;
    let { mutate: d2 = false, path: l2 = [] } = t;
    return Object.keys(s2).reduce((o, c3) => {
      let n2 = s2[c3];
      return typeof n2 != "function" ? (o[c3] = this.instrument(n2, { ...t, path: l2.concat(c3) }), o) : typeof n2.__originalFn__ == "function" ? (o[c3] = n2, o) : (o[c3] = (...r) => this.track(c3, n2, r, t), o[c3].__originalFn__ = n2, Object.defineProperty(o[c3], "name", { value: c3, writable: false }), Object.keys(n2).length > 0 && Object.assign(o[c3], this.instrument({ ...n2 }, { ...t, path: l2.concat(c3) })), o);
    }, d2 ? s2 : Y2(s2));
  }
  track(s2, t, d2, l2) {
    var _a2, _b, _c, _d;
    let o = ((_a2 = d2 == null ? void 0 : d2[0]) == null ? void 0 : _a2.__storyId__) || ((_d = (_c = (_b = import_global.default.window.__STORYBOOK_PREVIEW__) == null ? void 0 : _b.urlStore) == null ? void 0 : _c.selection) == null ? void 0 : _d.storyId), { cursor: c3, ancestors: n2 } = this.getState(o);
    this.setState(o, { cursor: c3 + 1 });
    let r = `${n2.slice(-1)[0] || o} [${c3}] ${s2}`, { path: e2 = [], intercept: a2 = false, retain: i3 = false } = l2, f2 = typeof a2 == "function" ? a2(s2, e2) : a2, g = { id: r, cursor: c3, storyId: o, ancestors: n2, path: e2, method: s2, args: d2, interceptable: f2, retain: i3 }, p2 = (f2 && !n2.length ? this.intercept : this.invoke).call(this, t, g, l2);
    return this.instrument(p2, { ...l2, mutate: true, path: [{ __callId__: g.id }] });
  }
  intercept(s2, t, d2) {
    let { chainedCallIds: l2, isDebugging: o, playUntil: c3 } = this.getState(t.storyId), n2 = l2.has(t.id);
    return !o || n2 || c3 ? (c3 === t.id && this.setState(t.storyId, { playUntil: void 0 }), this.invoke(s2, t, d2)) : new Promise((r) => {
      this.setState(t.storyId, ({ resolvers: e2 }) => ({ isLocked: false, resolvers: { ...e2, [t.id]: r } }));
    }).then(() => (this.setState(t.storyId, (r) => {
      let { [t.id]: e2, ...a2 } = r.resolvers;
      return { isLocked: true, resolvers: a2 };
    }), this.invoke(s2, t, d2)));
  }
  invoke(s2, t, d2) {
    let { callRefsByResult: l2, renderPhase: o } = this.getState(t.storyId), c3 = (e2) => {
      var _a2, _b;
      if (l2.has(e2))
        return l2.get(e2);
      if (e2 instanceof Array)
        return e2.map(c3);
      if (e2 instanceof Date)
        return { __date__: { value: e2.toISOString() } };
      if (e2 instanceof Error) {
        let { name: a2, message: i3, stack: f2 } = e2;
        return { __error__: { name: a2, message: i3, stack: f2 } };
      }
      if (e2 instanceof RegExp) {
        let { flags: a2, source: i3 } = e2;
        return { __regexp__: { flags: a2, source: i3 } };
      }
      if (e2 instanceof import_global.default.window.HTMLElement) {
        let { prefix: a2, localName: i3, id: f2, classList: g, innerText: _2 } = e2, p2 = Array.from(g);
        return { __element__: { prefix: a2, localName: i3, id: f2, classNames: p2, innerText: _2 } };
      }
      return typeof e2 == "function" ? { __function__: { name: e2.name } } : typeof e2 == "symbol" ? { __symbol__: { description: e2.description } } : typeof e2 == "object" && ((_a2 = e2 == null ? void 0 : e2.constructor) == null ? void 0 : _a2.name) && ((_b = e2 == null ? void 0 : e2.constructor) == null ? void 0 : _b.name) !== "Object" ? { __class__: { name: e2.constructor.name } } : Object.prototype.toString.call(e2) === "[object Object]" ? Object.fromEntries(Object.entries(e2).map(([a2, i3]) => [a2, c3(i3)])) : e2;
    }, n2 = { ...t, args: t.args.map(c3) };
    t.path.forEach((e2) => {
      (e2 == null ? void 0 : e2.__callId__) && this.setState(t.storyId, ({ chainedCallIds: a2 }) => ({ chainedCallIds: new Set(Array.from(a2).concat(e2.__callId__)) }));
    });
    let r = (e2) => {
      if (e2 instanceof Error) {
        let { name: a2, message: i3, stack: f2, callId: g = t.id } = e2, _2 = { name: a2, message: i3, stack: f2, callId: g };
        if (this.update({ ...n2, status: "error", exception: _2 }), this.setState(t.storyId, (p2) => ({ callRefsByResult: new Map([...Array.from(p2.callRefsByResult.entries()), [e2, { __callId__: t.id, retain: t.retain }]]) })), t.ancestors.length)
          throw Object.prototype.hasOwnProperty.call(e2, "callId") || Object.defineProperty(e2, "callId", { value: t.id }), e2;
        if (e2 !== E)
          throw i.warn(e2), e;
      }
      throw e2;
    };
    try {
      if (o === "played" && !t.retain)
        throw E;
      let a2 = (d2.getArgs ? d2.getArgs(t, this.getState(t.storyId)) : t.args).map((f2) => typeof f2 != "function" || Object.keys(f2).length ? f2 : (...g) => {
        let { cursor: _2, ancestors: p2 } = this.getState(t.storyId);
        this.setState(t.storyId, { cursor: 0, ancestors: [...p2, t.id] });
        let I = () => this.setState(t.storyId, { cursor: _2, ancestors: p2 }), b2 = false;
        try {
          let S2 = f2(...g);
          return S2 instanceof Promise ? (b2 = true, S2.finally(I)) : S2;
        } finally {
          b2 || I();
        }
      }), i3 = s2(...a2);
      return i3 && ["object", "function", "symbol"].includes(typeof i3) && this.setState(t.storyId, (f2) => ({ callRefsByResult: new Map([...Array.from(f2.callRefsByResult.entries()), [i3, { __callId__: t.id, retain: t.retain }]]) })), this.update({ ...n2, status: i3 instanceof Promise ? "active" : "done" }), i3 instanceof Promise ? i3.then((f2) => (this.update({ ...n2, status: "done" }), f2), r) : i3;
    } catch (e2) {
      return r(e2);
    }
  }
  update(s2) {
    this.channel.emit(y.CALL, s2), this.setState(s2.storyId, ({ calls: t }) => {
      let d2 = t.concat(s2).reduce((l2, o) => Object.assign(l2, { [o.id]: o }), {});
      return { calls: Object.values(d2).sort((l2, o) => l2.id.localeCompare(o.id, void 0, { numeric: true })) };
    }), this.sync(s2.storyId);
  }
  sync(s2) {
    let t = () => {
      var _a2;
      let { isLocked: d2, isPlaying: l2 } = this.getState(s2), o = this.getLog(s2), c3 = (_a2 = o.filter(({ ancestors: i3 }) => !i3.length).find((i3) => i3.status === "waiting")) == null ? void 0 : _a2.callId, n2 = o.some((i3) => i3.status === "active");
      if (A || d2 || n2 || o.length === 0) {
        let i3 = { controlStates: C2, logItems: o };
        this.channel.emit(y.SYNC, i3);
        return;
      }
      let r = o.some((i3) => ["done", "error"].includes(i3.status)), a2 = { controlStates: { debugger: true, start: r, back: r, goto: true, next: l2, end: l2 }, logItems: o, pausedAt: c3 };
      this.channel.emit(y.SYNC, a2);
    };
    this.setState(s2, ({ syncTimeout: d2 }) => (clearTimeout(d2), { syncTimeout: setTimeout(t, 0) }));
  }
};
function G(u, s2 = {}) {
  var _a2, _b, _c, _d;
  try {
    let t = false, d2 = false;
    return ((_b = (_a2 = import_global.default.window.location) == null ? void 0 : _a2.search) == null ? void 0 : _b.includes("instrument=true")) ? t = true : ((_d = (_c = import_global.default.window.location) == null ? void 0 : _c.search) == null ? void 0 : _d.includes("instrument=false")) && (d2 = true), import_global.default.window.parent === import_global.default.window && !t || d2 ? u : (import_global.default.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ || (import_global.default.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new O()), import_global.default.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__.instrument(u, s2));
  } catch (t) {
    return n.warn(t), u;
  }
}

// node_modules/@storybook/addon-interactions/dist/preset/preview.mjs
var import_jest_mock = __toESM(require_build(), 1);
var i2 = new import_jest_mock.ModuleMocker(window);
var d = i2.fn.bind(i2);
var { action: l } = G({ action: d }, { retain: true });
var f = c.getChannel();
var a = /* @__PURE__ */ new Set();
var s = [];
f.on(Y, () => s.forEach((n2) => {
  var _a2;
  return (_a2 = n2 == null ? void 0 : n2.mockClear) == null ? void 0 : _a2.call(n2);
}));
f.on(p, ({ newPhase: n2 }) => {
  n2 === "loading" && s.forEach((t) => {
    var _a2;
    return (_a2 = t == null ? void 0 : t.mockClear) == null ? void 0 : _a2.call(t);
  });
});
var c2 = (n2, t, o) => {
  if (a.has(t))
    return t;
  a.add(t);
  try {
    if (Object.prototype.toString.call(t) === "[object Object]") {
      for (let [e2, r] of Object.entries(t))
        t[e2] = c2(n2, r, e2);
      return t;
    }
    if (Array.isArray(t))
      return t.map((e2, r) => c2(n2, e2, `${o}[${r}]`));
    if (typeof t == "function" && t.isAction) {
      Object.defineProperty(t, "name", { value: o, writable: false }), Object.defineProperty(t, "__storyId__", { value: n2, writable: false });
      let e2 = l(t);
      return s.push(e2), e2;
    }
  } catch {
  }
  return t;
};
var E2 = ({ id: n2, initialArgs: t }) => c2(n2, t);
var P = [E2];
var { step: S } = G({ step: (n2, t, o) => t(o) }, { intercept: true });
var _ = { throwPlayFunctionExceptions: false };
export {
  P as argsEnhancers,
  _ as parameters,
  S as runStep
};
//# sourceMappingURL=@storybook_addon-interactions_preview.js.map
