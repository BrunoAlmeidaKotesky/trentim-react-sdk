import { StoryStore } from '@storybook/store';
export { composeConfigs } from '@storybook/store';
import * as _storybook_types from '@storybook/types';
import { AnyFramework, StoryId, ViewMode, Store_Story, Store_RenderToDOM, Store_RenderContext, Store_ModuleExports, Store_ModuleExport, StoryName, StoryContextForLoaders, Addon_IndexEntry, Store_StoryIndex, Store_ModuleImportFn, Store_WebProjectAnnotations, Store_PromiseLike, ProjectAnnotations, Globals, Args, Store_SelectionSpecifier, Store_Selection, Store_StorySpecifier, Store_CSFFile, Parameters } from '@storybook/types';
export { Store_WebProjectAnnotations as WebProjectAnnotations } from '@storybook/types';
import { Channel } from '@storybook/channels';
import qs from 'qs';

declare type RenderType = 'story' | 'docs';
/**
 * A "Render" represents the rendering of a single entry to a single location
 *
 * The implemenations of render are used for two key purposes:
 *  - Tracking the state of the rendering as it moves between preparing, rendering and tearing down.
 *  - Tracking what is rendered to know if a change requires re-rendering or teardown + recreation.
 */
interface Render<TFramework extends AnyFramework> {
    type: RenderType;
    id: StoryId;
    isPreparing: () => boolean;
    isEqual: (other: Render<TFramework>) => boolean;
    disableKeyListeners: boolean;
    teardown?: (options: {
        viewModeChanged: boolean;
    }) => Promise<void>;
    torndown: boolean;
    renderToElement: (canvasElement: HTMLElement, renderStoryToElement?: any, options?: StoryRenderOptions) => Promise<void>;
}

declare type RenderPhase = 'preparing' | 'loading' | 'rendering' | 'playing' | 'played' | 'completed' | 'aborted' | 'errored';
declare type RenderContextCallbacks<TFramework extends AnyFramework> = Pick<Store_RenderContext<TFramework>, 'showMain' | 'showError' | 'showException'>;
declare type StoryRenderOptions = {
    autoplay?: boolean;
};
declare class StoryRender<TFramework extends AnyFramework> implements Render<TFramework> {
    channel: Channel;
    store: StoryStore<TFramework>;
    private renderToScreen;
    private callbacks;
    id: StoryId;
    viewMode: ViewMode;
    renderOptions: StoryRenderOptions;
    type: RenderType;
    story?: Store_Story<TFramework>;
    phase?: RenderPhase;
    private abortController?;
    private canvasElement?;
    private notYetRendered;
    disableKeyListeners: boolean;
    private teardownRender;
    torndown: boolean;
    constructor(channel: Channel, store: StoryStore<TFramework>, renderToScreen: Store_RenderToDOM<TFramework>, callbacks: RenderContextCallbacks<TFramework>, id: StoryId, viewMode: ViewMode, renderOptions?: StoryRenderOptions, story?: Store_Story<TFramework>);
    private runPhase;
    prepare(): Promise<void>;
    isEqual(other: Render<TFramework>): boolean;
    isPreparing(): boolean;
    isPending(): boolean;
    renderToElement(canvasElement: HTMLElement): Promise<void>;
    private storyContext;
    render({ initial, forceRemount, }?: {
        initial?: boolean;
        forceRemount?: boolean;
    }): Promise<void>;
    rerender(): Promise<void>;
    remount(): Promise<void>;
    cancelRender(): void;
    teardown(): Promise<void>;
}

interface DocsContextProps<TFramework extends AnyFramework = AnyFramework> {
    /**
     * Register the CSF file that this docs entry represents.
     * Used by the `<Meta of={} />` block.
     */
    setMeta: (metaExports: Store_ModuleExports) => void;
    /**
     * Find a story's id from the direct export from the CSF file.
     * This is primarily used by the `<Story of={} /> block.
     */
    storyIdByModuleExport: (storyExport: Store_ModuleExport, metaExports?: Store_ModuleExports) => StoryId;
    /**
     * Find a story's id from the name of the story.
     * This is primarily used by the `<Story name={} /> block.
     * Note that the story must be part of the primary CSF file of the docs entry.
     */
    storyIdByName: (storyName: StoryName) => StoryId;
    /**
     * Syncronously find a story by id (if the id is not provided, this will look up the primary
     * story in the CSF file, if such a file exists).
     */
    storyById: (id?: StoryId) => Store_Story<TFramework>;
    /**
     * Syncronously find all stories of the component referenced by the CSF file.
     */
    componentStories: () => Store_Story<TFramework>[];
    /**
     * Get the story context of the referenced story.
     */
    getStoryContext: (story: Store_Story<TFramework>) => StoryContextForLoaders<TFramework>;
    /**
     * Asyncronously load an arbitrary story by id.
     */
    loadStory: (id: StoryId) => Promise<Store_Story<TFramework>>;
    /**
     * Render a story to a given HTML element and keep it up to date across context changes
     */
    renderStoryToElement: (story: Store_Story<TFramework>, element: HTMLElement, options: StoryRenderOptions) => () => Promise<void>;
    /**
     * Storybook channel -- use for low level event watching/emitting
     */
    channel: Channel;
}

/**
 * A TemplateDocsRender is a render of a docs entry that is rendered with (an) attached CSF file(s).
 *
 * The expectation is the primary CSF file which is the `importPath` for the entry will
 * define a story which may contain the actual rendered JSX code for the template in the
 * `docs.page` parameter.
 *
 * Use cases:
 *  - Docs Page, where there is no parameter, and we fall back to the globally defined template.
 *  - *.stories.mdx files, where the MDX compiler produces a CSF file with a `.parameter.docs.page`
 *      parameter containing the compiled content of the MDX file.
 */
declare class TemplateDocsRender<TFramework extends AnyFramework> implements Render<TFramework> {
    protected channel: Channel;
    protected store: StoryStore<TFramework>;
    entry: Addon_IndexEntry;
    readonly type: RenderType;
    readonly id: StoryId;
    story?: Store_Story<TFramework>;
    rerender?: () => Promise<void>;
    teardownRender?: (options: {
        viewModeChanged?: boolean;
    }) => Promise<void>;
    torndown: boolean;
    readonly disableKeyListeners = false;
    preparing: boolean;
    private csfFiles?;
    constructor(channel: Channel, store: StoryStore<TFramework>, entry: Addon_IndexEntry);
    isPreparing(): boolean;
    prepare(): Promise<void>;
    isEqual(other: Render<TFramework>): boolean;
    renderToElement(canvasElement: HTMLElement, renderStoryToElement: DocsContextProps['renderStoryToElement']): Promise<void>;
    teardown({ viewModeChanged }?: {
        viewModeChanged?: boolean;
    }): Promise<void>;
}

/**
 * A StandaloneDocsRender is a render of a docs entry that doesn't directly come from a CSF file.
 *
 * A standalone render can reference zero or more CSF files that contain stories.
 *
 * Use cases:
 *  - *.mdx file that may or may not reference a specific CSF file with `<Meta of={} />`
 */
declare class StandaloneDocsRender<TFramework extends AnyFramework> implements Render<TFramework> {
    protected channel: Channel;
    protected store: StoryStore<TFramework>;
    entry: Addon_IndexEntry;
    readonly type: RenderType;
    readonly id: StoryId;
    private exports?;
    rerender?: () => Promise<void>;
    teardownRender?: (options: {
        viewModeChanged?: boolean;
    }) => Promise<void>;
    torndown: boolean;
    readonly disableKeyListeners = false;
    preparing: boolean;
    private csfFiles?;
    constructor(channel: Channel, store: StoryStore<TFramework>, entry: Addon_IndexEntry);
    isPreparing(): boolean;
    prepare(): Promise<void>;
    isEqual(other: Render<TFramework>): boolean;
    renderToElement(canvasElement: HTMLElement, renderStoryToElement: DocsContextProps['renderStoryToElement']): Promise<void>;
    teardown({ viewModeChanged }?: {
        viewModeChanged?: boolean;
    }): Promise<void>;
}

declare type MaybePromise<T> = Promise<T> | T;
declare class Preview<TFramework extends AnyFramework> {
    protected channel: Channel;
    serverChannel?: Channel;
    storyStore: StoryStore<TFramework>;
    getStoryIndex?: () => Store_StoryIndex;
    importFn?: Store_ModuleImportFn;
    renderToDOM?: Store_RenderToDOM<TFramework>;
    storyRenders: StoryRender<TFramework>[];
    previewEntryError?: Error;
    constructor(channel?: Channel);
    initialize({ getStoryIndex, importFn, getProjectAnnotations, }: {
        getStoryIndex?: () => Store_StoryIndex;
        importFn: Store_ModuleImportFn;
        getProjectAnnotations: () => MaybePromise<Store_WebProjectAnnotations<TFramework>>;
    }): Promise<void>;
    setupListeners(): void;
    getProjectAnnotationsOrRenderError(getProjectAnnotations: () => MaybePromise<Store_WebProjectAnnotations<TFramework>>): Store_PromiseLike<ProjectAnnotations<TFramework>>;
    initializeWithProjectAnnotations(projectAnnotations: Store_WebProjectAnnotations<TFramework>): Promise<void>;
    setInitialGlobals(): Promise<void>;
    emitGlobals(): void;
    getStoryIndexFromServer(): Promise<Store_StoryIndex>;
    initializeWithStoryIndex(storyIndex: Store_StoryIndex): PromiseLike<void>;
    onGetProjectAnnotationsChanged({ getProjectAnnotations, }: {
        getProjectAnnotations: () => MaybePromise<ProjectAnnotations<TFramework>>;
    }): Promise<void>;
    onStoryIndexChanged(): Promise<void>;
    onStoriesChanged({ importFn, storyIndex, }: {
        importFn?: Store_ModuleImportFn;
        storyIndex?: Store_StoryIndex;
    }): Promise<void>;
    onUpdateGlobals({ globals }: {
        globals: Globals;
    }): Promise<void>;
    onUpdateArgs({ storyId, updatedArgs }: {
        storyId: StoryId;
        updatedArgs: Args;
    }): Promise<void>;
    onResetArgs({ storyId, argNames }: {
        storyId: string;
        argNames?: string[];
    }): Promise<void>;
    onForceReRender(): Promise<void>;
    onForceRemount({ storyId }: {
        storyId: StoryId;
    }): Promise<void>;
    renderStoryToElement(story: Store_Story<TFramework>, element: HTMLElement, options: StoryRenderOptions): () => Promise<void>;
    teardownRender(render: StoryRender<TFramework> | TemplateDocsRender<TFramework> | StandaloneDocsRender<TFramework>, { viewModeChanged }?: {
        viewModeChanged?: boolean;
    }): Promise<void>;
    extract(options?: {
        includeDocsOnly: boolean;
    }): Promise<Record<string, _storybook_types.StoryContextForEnhancers<TFramework, Args>>>;
    inlineStoryCallbacks(storyId: StoryId): {
        showMain: () => void;
        showError: (err: {
            title: string;
            description: string;
        }) => void;
        showException: (err: Error) => void;
    };
    renderPreviewEntryError(reason: string, err: Error): void;
}

declare class UrlStore {
    selectionSpecifier: Store_SelectionSpecifier | null;
    selection?: Store_Selection;
    constructor();
    setSelection(selection: Store_Selection): void;
    setQueryParams(queryParams: qs.ParsedQs): void;
}

declare const layoutClassMap: {
    readonly centered: "sb-main-centered";
    readonly fullscreen: "sb-main-fullscreen";
    readonly padded: "sb-main-padded";
};
declare type Layout = keyof typeof layoutClassMap | 'none';
declare enum Mode {
    'MAIN' = "MAIN",
    'NOPREVIEW' = "NOPREVIEW",
    'PREPARING_STORY' = "PREPARING_STORY",
    'PREPARING_DOCS' = "PREPARING_DOCS",
    'ERROR' = "ERROR"
}
declare class WebView {
    currentLayoutClass?: typeof layoutClassMap[keyof typeof layoutClassMap] | null;
    testing: boolean;
    preparingTimeout?: ReturnType<typeof setTimeout>;
    constructor();
    prepareForStory(story: Store_Story<any>): HTMLElement;
    storyRoot(): HTMLElement;
    prepareForDocs(): HTMLElement;
    docsRoot(): HTMLElement;
    applyLayout(layout?: Layout): void;
    checkIfLayoutExists(layout: keyof typeof layoutClassMap): void;
    showMode(mode: Mode): void;
    showErrorDisplay({ message, stack }: {
        message?: string | undefined;
        stack?: string | undefined;
    }): void;
    showNoPreview(): void;
    showPreparingStory({ immediate }?: {
        immediate?: boolean | undefined;
    }): void;
    showPreparingDocs(): void;
    showMain(): void;
    showDocs(): void;
    showStory(): void;
    showStoryDuringRender(): void;
}

declare type PossibleRender<TFramework extends AnyFramework> = StoryRender<TFramework> | TemplateDocsRender<TFramework> | StandaloneDocsRender<TFramework>;
declare class PreviewWeb<TFramework extends AnyFramework> extends Preview<TFramework> {
    urlStore: UrlStore;
    view: WebView;
    currentSelection?: Store_Selection;
    currentRender?: PossibleRender<TFramework>;
    constructor();
    setupListeners(): void;
    initializeWithProjectAnnotations(projectAnnotations: Store_WebProjectAnnotations<TFramework>): Promise<void>;
    setInitialGlobals(): Promise<void>;
    initializeWithStoryIndex(storyIndex: Store_StoryIndex): PromiseLike<void>;
    selectSpecifiedStory(): Promise<void>;
    onGetProjectAnnotationsChanged({ getProjectAnnotations, }: {
        getProjectAnnotations: () => MaybePromise<ProjectAnnotations<TFramework>>;
    }): Promise<void>;
    onStoriesChanged({ importFn, storyIndex, }: {
        importFn?: Store_ModuleImportFn;
        storyIndex?: Store_StoryIndex;
    }): Promise<void>;
    onKeydown(event: KeyboardEvent): void;
    onSetCurrentStory(selection: {
        storyId: StoryId;
        viewMode?: ViewMode;
    }): Promise<void>;
    onUpdateQueryParams(queryParams: any): void;
    onUpdateGlobals({ globals }: {
        globals: Globals;
    }): Promise<void>;
    onUpdateArgs({ storyId, updatedArgs }: {
        storyId: StoryId;
        updatedArgs: Args;
    }): Promise<void>;
    onPreloadStories({ ids }: {
        ids: string[];
    }): Promise<void>;
    renderSelection({ persistedArgs }?: {
        persistedArgs?: Args;
    }): Promise<void>;
    teardownRender(render: PossibleRender<TFramework>, { viewModeChanged }?: {
        viewModeChanged?: boolean;
    }): Promise<void>;
    extract(options?: {
        includeDocsOnly: boolean;
    }): Promise<Record<string, _storybook_types.StoryContextForEnhancers<TFramework, Args>>>;
    mainStoryCallbacks(storyId: StoryId): {
        showMain: () => void;
        showError: (err: {
            title: string;
            description: string;
        }) => void;
        showException: (err: Error) => void;
    };
    inlineStoryCallbacks(storyId: StoryId): {
        showMain: () => void;
        showError: (err: {
            title: string;
            description: string;
        }) => void;
        showException: (err: Error) => void;
    };
    renderPreviewEntryError(reason: string, err: Error): void;
    renderMissingStory(): void;
    renderStoryLoadingException(storySpecifier: Store_StorySpecifier, err: Error): void;
    renderException(storyId: StoryId, error: Error): void;
    renderError(storyId: StoryId, { title, description }: {
        title: string;
        description: string;
    }): void;
}

declare function simulateDOMContentLoaded(): void;
declare function simulatePageLoad($container: any): void;

declare class DocsContext<TFramework extends AnyFramework> implements DocsContextProps<TFramework> {
    channel: Channel;
    protected store: StoryStore<TFramework>;
    renderStoryToElement: DocsContextProps['renderStoryToElement'];
    private componentStoriesValue;
    private storyIdToCSFFile;
    private exportToStoryId;
    private nameToStoryId;
    private primaryStory?;
    constructor(channel: Channel, store: StoryStore<TFramework>, renderStoryToElement: DocsContextProps['renderStoryToElement'], 
    /** The CSF files known (via the index) to be refererenced by this docs file */
    csfFiles: Store_CSFFile<TFramework>[], componentStoriesFromAllCsfFiles?: boolean);
    referenceCSFFile(csfFile: Store_CSFFile<TFramework>, addToComponentStories: boolean): void;
    setMeta(metaExports: Store_ModuleExports): void;
    storyIdByModuleExport(storyExport: Store_ModuleExport, metaExports?: Store_ModuleExports): string;
    storyIdByName: (storyName: StoryName) => string;
    componentStories: () => Store_Story<TFramework>[];
    storyById: (storyId?: string | undefined) => Store_Story<TFramework>;
    getStoryContext: (story: Store_Story<TFramework>) => StoryContextForLoaders<TFramework, _storybook_types.Args>;
    loadStory: (id: StoryId) => Promise<Store_Story<TFramework>>;
}

declare type DocsRenderFunction<TFramework extends AnyFramework> = (docsContext: DocsContextProps<TFramework>, docsParameters: Parameters, element: HTMLElement, callback: () => void) => void;

export { DocsContext, DocsContextProps, DocsRenderFunction, Preview, PreviewWeb, simulateDOMContentLoaded, simulatePageLoad };
