import * as _storybook_types from '@storybook/types';
import { Store_StoryIndex, Store_StorySpecifier, Addon_IndexEntry, StoryId, Path, Args, Store_Story, Globals, GlobalTypes, InputType, StrictInputType, ArgTypes, StrictArgTypes, StrictGlobalTypes, AnyFramework, LegacyStoryAnnotationsOrFn, Store_NormalizedComponentAnnotations, Store_NormalizedStoryAnnotations, Store_ModuleExports, ComponentTitle, Store_CSFFile, Store_NormalizedProjectAnnotations, ProjectAnnotations, Store_WebProjectAnnotations, StepRunner, ComponentAnnotations, Store_ComposedStoryPlayFn, Store_CSFExports, Store_ComposeStory, Store_ModuleImportFn, Store_PromiseLike, StoryContextForLoaders, Store_ExtractOptions, StoryContextForEnhancers, Parameters, Store_StoryIndexV3, API_PreparedStoryIndex, Store_BoundStory, Store_PropDescriptor, ArgTypesEnhancer, LegacyStoryFn, DecoratorFunction, PartialStoryFn, StoryContextUpdate, StoryContext, Store_NormalizedStoriesSpecifierEntry, Addon_StorySortParameterV7, Addon_StorySortParameter } from '@storybook/types';
import { SynchronousPromise } from 'synchronous-promise';
import { HooksContext } from '@storybook/addons';
export { HooksContext, applyHooks, useArgs, useCallback, useChannel, useEffect, useGlobals, useMemo, useParameter, useReducer, useRef, useState, useStoryContext } from '@storybook/addons';

declare class StoryIndexStore {
    entries: Store_StoryIndex['entries'];
    constructor({ entries }?: Store_StoryIndex);
    entryFromSpecifier(specifier: Store_StorySpecifier): Addon_IndexEntry | undefined;
    storyIdToEntry(storyId: StoryId): Addon_IndexEntry;
    importPathToEntry(importPath: Path): Addon_IndexEntry;
}

declare class ArgsStore {
    initialArgsByStoryId: Record<StoryId, Args>;
    argsByStoryId: Record<StoryId, Args>;
    get(storyId: StoryId): Args;
    setInitial(story: Store_Story<any>): void;
    updateFromDelta(story: Store_Story<any>, delta: Args): void;
    updateFromPersisted(story: Store_Story<any>, persisted: Args): void;
    update(storyId: StoryId, argsUpdate: Partial<Args>): void;
}

declare class GlobalsStore {
    allowedGlobalNames: Set<string>;
    initialGlobals: Globals;
    globals: Globals;
    constructor({ globals, globalTypes, }: {
        globals?: Globals;
        globalTypes?: GlobalTypes;
    });
    set({ globals, globalTypes }: {
        globals?: Globals;
        globalTypes?: GlobalTypes;
    }): void;
    filterAllowedGlobals(globals: Globals): Globals;
    updateFromPersisted(persisted: Globals): void;
    get(): Globals;
    update(newGlobals: Globals): void;
}

declare const normalizeInputType: (inputType: InputType, key: string) => StrictInputType;
declare const normalizeInputTypes: (inputTypes: ArgTypes | GlobalTypes) => StrictArgTypes | StrictGlobalTypes;

declare function normalizeStory<TFramework extends AnyFramework>(key: StoryId, storyAnnotations: LegacyStoryAnnotationsOrFn<TFramework>, meta: Store_NormalizedComponentAnnotations<TFramework>): Store_NormalizedStoryAnnotations<TFramework>;

declare function processCSFFile<TFramework extends AnyFramework>(moduleExports: Store_ModuleExports, importPath: Path, title: ComponentTitle): Store_CSFFile<TFramework>;

declare function prepareStory<TFramework extends AnyFramework>(storyAnnotations: Store_NormalizedStoryAnnotations<TFramework>, componentAnnotations: Store_NormalizedComponentAnnotations<TFramework>, projectAnnotations: Store_NormalizedProjectAnnotations<TFramework>): Store_Story<TFramework>;

declare function normalizeComponentAnnotations<TFramework extends AnyFramework>(defaultExport: Store_ModuleExports['default'], title?: string, importPath?: string): Store_NormalizedComponentAnnotations<TFramework>;

declare function normalizeProjectAnnotations<TFramework extends AnyFramework>({ argTypes, globalTypes, argTypesEnhancers, ...annotations }: ProjectAnnotations<TFramework>): Store_NormalizedProjectAnnotations<TFramework>;

declare const getValuesFromArgTypes: (argTypes?: ArgTypes) => ArgTypes<_storybook_types.Args>;

declare function getField<TFieldType = any>(moduleExportList: Store_ModuleExports[], field: string): TFieldType | TFieldType[];
declare function getArrayField<TFieldType = any>(moduleExportList: Store_ModuleExports[], field: string): TFieldType[];
declare function getObjectField<TFieldType = Record<string, any>>(moduleExportList: Store_ModuleExports[], field: string): TFieldType;
declare function getSingletonField<TFieldType = any>(moduleExportList: Store_ModuleExports[], field: string): TFieldType;
declare function composeConfigs<TFramework extends AnyFramework>(moduleExportList: Store_ModuleExports[]): Store_WebProjectAnnotations<TFramework>;

/**
 * Compose step runners to create a single step runner that applies each step runner in order.
 *
 * A step runner is a a function that takes a defined step: `step('label', () => { ... })`
 * and runs it. The prototypical example is from `@storybook/addon-interactions` where the
 * step runner will decorate all instrumented code inside the step with information about the
 * label.
 *
 * In theory it is possible to have more than one addon that wants to run steps; they can be
 * composed together in a similar fashion to decorators. In some ways step runners are like
 * decorators except it is not intended that they change the context or the play function.
 *
 * The basic implementation of a step runner is `async (label, play, context) => play(context)`
 *  -- in fact this is what `composeStepRunners([])` will do.
 *
 * @param stepRunners an array of StepRunner
 * @returns a StepRunner that is the composition of the arguments
 */
declare function composeStepRunners<TFramework extends AnyFramework>(stepRunners: StepRunner<TFramework>[]): StepRunner<TFramework>;

declare function setProjectAnnotations<TFramework extends AnyFramework = AnyFramework>(projectAnnotations: ProjectAnnotations<TFramework> | ProjectAnnotations<TFramework>[]): void;
declare function composeStory<TFramework extends AnyFramework = AnyFramework, TArgs extends Args = Args>(storyAnnotations: LegacyStoryAnnotationsOrFn<TFramework>, componentAnnotations: ComponentAnnotations<TFramework, TArgs>, projectAnnotations?: ProjectAnnotations<TFramework>, defaultConfig?: ProjectAnnotations<TFramework>, exportsName?: string): {
    (extraArgs: Partial<TArgs>): TFramework["storyResult"];
    storyName: string;
    args: Args;
    play: Store_ComposedStoryPlayFn;
    parameters: {
        [name: string]: any;
    };
};
declare function composeStories<TModule extends Store_CSFExports>(storiesImport: TModule, globalConfig: ProjectAnnotations<AnyFramework>, composeStoryFn: Store_ComposeStory): {};

declare class StoryStore<TFramework extends AnyFramework> {
    storyIndex?: StoryIndexStore;
    importFn?: Store_ModuleImportFn;
    projectAnnotations?: Store_NormalizedProjectAnnotations<TFramework>;
    globals?: GlobalsStore;
    args: ArgsStore;
    hooks: Record<StoryId, HooksContext<TFramework>>;
    cachedCSFFiles?: Record<Path, Store_CSFFile<TFramework>>;
    processCSFFileWithCache: typeof processCSFFile;
    prepareStoryWithCache: typeof prepareStory;
    initializationPromise: SynchronousPromise<void>;
    resolveInitializationPromise: () => void;
    constructor();
    setProjectAnnotations(projectAnnotations: ProjectAnnotations<TFramework>): void;
    initialize({ storyIndex, importFn, cache, }: {
        storyIndex?: Store_StoryIndex;
        importFn: Store_ModuleImportFn;
        cache?: boolean;
    }): Store_PromiseLike<void>;
    onStoriesChanged({ importFn, storyIndex, }: {
        importFn?: Store_ModuleImportFn;
        storyIndex?: Store_StoryIndex;
    }): Promise<void>;
    storyIdToEntry(storyId: StoryId): Promise<Addon_IndexEntry>;
    loadCSFFileByStoryId(storyId: StoryId): Store_PromiseLike<Store_CSFFile<TFramework>>;
    loadAllCSFFiles(): Store_PromiseLike<StoryStore<TFramework>['cachedCSFFiles']>;
    cacheAllCSFFiles(): Store_PromiseLike<void>;
    loadStory({ storyId }: {
        storyId: StoryId;
    }): Promise<Store_Story<TFramework>>;
    storyFromCSFFile({ storyId, csfFile, }: {
        storyId: StoryId;
        csfFile: Store_CSFFile<TFramework>;
    }): Store_Story<TFramework>;
    componentStoriesFromCSFFile({ csfFile, }: {
        csfFile: Store_CSFFile<TFramework>;
    }): Store_Story<TFramework>[];
    loadEntry(id: StoryId): Promise<{
        entryExports: Store_ModuleExports;
        csfFiles: Store_CSFFile<TFramework>[];
    }>;
    getStoryContext(story: Store_Story<TFramework>): Omit<StoryContextForLoaders<TFramework>, 'viewMode'>;
    cleanupStory(story: Store_Story<TFramework>): void;
    extract(options?: Store_ExtractOptions): Record<StoryId, StoryContextForEnhancers<TFramework>>;
    getSetStoriesPayload(): {
        v: number;
        globals: _storybook_types.Globals;
        globalParameters: {};
        kindParameters: Parameters;
        stories: Record<string, StoryContextForEnhancers<TFramework, _storybook_types.Args>>;
    };
    getStoriesJsonData: () => Store_StoryIndexV3;
    getSetIndexPayload(): API_PreparedStoryIndex;
    raw(): Store_BoundStory<TFramework>[];
    fromId(storyId: StoryId): Store_BoundStory<TFramework> | null;
}

/**
 * Safely combine parameters recursively. Only copy objects when needed.
 * Algorithm = always overwrite the existing value UNLESS both values
 * are plain objects. In this case flag the key as "special" and handle
 * it with a heuristic.
 */
declare const combineParameters: (...parameterSets: (Parameters | undefined)[]) => Parameters;

declare const filterArgTypes: (argTypes: StrictArgTypes, include?: Store_PropDescriptor | undefined, exclude?: Store_PropDescriptor | undefined) => StrictArgTypes<_storybook_types.Args>;

declare const inferControls: ArgTypesEnhancer<AnyFramework>;

declare function useSharedState<S>(sharedId: string, defaultState?: S): [S, (s: S) => void];
declare function useAddonState<S>(addonId: string, defaultState?: S): [S, (s: S) => void];

declare function decorateStory<TFramework extends AnyFramework>(storyFn: LegacyStoryFn<TFramework>, decorator: DecoratorFunction<TFramework>, bindWithContext: (storyFn: LegacyStoryFn<TFramework>) => PartialStoryFn<TFramework>): LegacyStoryFn<TFramework>;
/**
 * Currently StoryContextUpdates are allowed to have any key in the type.
 * However, you cannot overwrite any of the build-it "static" keys.
 *
 * @param inputContextUpdate StoryContextUpdate
 * @returns StoryContextUpdate
 */
declare function sanitizeStoryContextUpdate({ componentId, title, kind, id, name, story, parameters, initialArgs, argTypes, ...update }?: StoryContextUpdate): StoryContextUpdate;
declare function defaultDecorateStory<TFramework extends AnyFramework>(storyFn: LegacyStoryFn<TFramework>, decorators: DecoratorFunction<TFramework>[]): LegacyStoryFn<TFramework>;

declare const mapArgsToTypes: (args: Args, argTypes: ArgTypes) => Args;
declare const combineArgs: (value: any, update: any) => Args;
declare const validateOptions: (args: Args, argTypes: ArgTypes) => Args;
declare const DEEPLY_EQUAL: unique symbol;
declare const deepDiff: (value: any, update: any) => any;
declare const NO_TARGET_NAME = "";
declare function groupArgsByTarget<TArgs = Args>({ args, argTypes, }: StoryContext<AnyFramework, TArgs>): Record<string, Partial<TArgs>>;
declare function noTargetArgs<TArgs = Args>(context: StoryContext<AnyFramework, TArgs>): Partial<TArgs>;

declare const userOrAutoTitleFromSpecifier: (fileName: string | number, entry: Store_NormalizedStoriesSpecifierEntry, userTitle?: string | undefined) => string | undefined;
declare const userOrAutoTitle: (fileName: string, storiesEntries: Store_NormalizedStoriesSpecifierEntry[], userTitle?: string | undefined) => string | undefined;

declare const sortStoriesV7: (stories: Addon_IndexEntry[], storySortParameter: Addon_StorySortParameterV7, fileNameOrder: Path[]) => Addon_IndexEntry[];
declare const sortStoriesV6: (stories: [string, Store_Story, Parameters, Parameters][], storySortParameter: Addon_StorySortParameter, fileNameOrder: Path[]) => Addon_IndexEntry[];

export { DEEPLY_EQUAL, NO_TARGET_NAME, StoryStore, combineArgs, combineParameters, composeConfigs, composeStepRunners, composeStories, composeStory, decorateStory, deepDiff, defaultDecorateStory, filterArgTypes, getArrayField, getField, getObjectField, getSingletonField, getValuesFromArgTypes, groupArgsByTarget, inferControls, mapArgsToTypes, noTargetArgs, normalizeComponentAnnotations, normalizeInputType, normalizeInputTypes, normalizeProjectAnnotations, normalizeStory, prepareStory, processCSFFile, sanitizeStoryContextUpdate, setProjectAnnotations, sortStoriesV6, sortStoriesV7, useAddonState, useSharedState, userOrAutoTitle, userOrAutoTitleFromSpecifier, validateOptions };
