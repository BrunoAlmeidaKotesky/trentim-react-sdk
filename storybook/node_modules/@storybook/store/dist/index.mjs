import wr from"memoizerific";import Fe from"lodash/mapValues";import xr from"lodash/pick";import{SynchronousPromise as tr}from"synchronous-promise";import{HooksContext as he}from"@storybook/addons";import{dedent as Rr}from"ts-dedent";import Gr from"memoizerific";var Dr=Gr(1)(e=>Object.values(e).reduce((r,t)=>(r[t.importPath]=r[t.importPath]||t,r),{})),z=class{constructor({entries:r}={v:4,entries:{}}){this.entries=r}entryFromSpecifier(r){let t=Object.values(this.entries);if(r==="*")return t[0];if(typeof r=="string")return this.entries[r]?this.entries[r]:t.find(s=>s.id.startsWith(r));let{name:o,title:n}=r;return t.find(s=>s.name===o&&s.title===n)}storyIdToEntry(r){let t=this.entries[r];if(!t)throw new Error(Rr`Couldn't find story matching '${r}' after HMR.
      - Did you remove it from your CSF file?
      - Are you sure a story with that id exists?
      - Please check your entries field of your main.js config.
      - Also check the browser console and terminal for error messages.`);return t}importPathToEntry(r){return Dr(this.entries)[r]}};import{dequal as Mr}from"dequal";import{once as J}from"@storybook/client-logger";import N from"lodash/isPlainObject";import{dedent as pr}from"ts-dedent";var x=Symbol("incompatible"),Y=(e,r)=>{let t=r.type;if(e==null||!t||r.mapping)return e;switch(t.name){case"string":return String(e);case"enum":return e;case"number":return Number(e);case"boolean":return e==="true";case"array":return!t.value||!Array.isArray(e)?x:e.reduce((o,n,s)=>{let i=Y(n,{type:t.value});return i!==x&&(o[s]=i),o},new Array(e.length));case"object":return typeof e=="string"||typeof e=="number"?e:!t.value||typeof e!="object"?x:Object.entries(e).reduce((o,[n,s])=>{let i=Y(s,{type:t.value[n]});return i===x?o:Object.assign(o,{[n]:i})},{});default:return x}},cr=(e,r)=>Object.entries(e).reduce((t,[o,n])=>{if(!r[o])return t;let s=Y(n,r[o]);return s===x?t:Object.assign(t,{[o]:s})},{}),B=(e,r)=>Array.isArray(e)&&Array.isArray(r)?r.reduce((t,o,n)=>(t[n]=B(e[n],r[n]),t),[...e]).filter(t=>t!==void 0):!N(e)||!N(r)?r:Object.keys({...e,...r}).reduce((t,o)=>{if(o in r){let n=B(e[o],r[o]);n!==void 0&&(t[o]=n)}else t[o]=e[o];return t},{}),dr=(e,r)=>Object.entries(r).reduce((t,[o,{options:n}])=>{function s(){return o in e&&(t[o]=e[o]),t}if(!n)return s();if(!Array.isArray(n))return J.error(pr`
        Invalid argType: '${o}.options' should be an array.

        More info: https://storybook.js.org/docs/react/api/argtypes
      `),s();if(n.some(m=>m&&["object","function"].includes(typeof m)))return J.error(pr`
        Invalid argType: '${o}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
      `),s();let i=Array.isArray(e[o]),a=i&&e[o].findIndex(m=>!n.includes(m)),l=i&&a===-1;if(e[o]===void 0||n.includes(e[o])||l)return s();let y=i?`${o}[${a}]`:o,d=n.map(m=>typeof m=="string"?`'${m}'`:String(m)).join(", ");return J.warn(`Received illegal value for '${y}'. Supported options: ${d}`),t},{}),b=Symbol("Deeply equal"),_=(e,r)=>{if(typeof e!=typeof r)return r;if(Mr(e,r))return b;if(Array.isArray(e)&&Array.isArray(r)){let t=r.reduce((o,n,s)=>{let i=_(e[s],n);return i!==b&&(o[s]=i),o},new Array(r.length));return r.length>=e.length?t:t.concat(new Array(e.length-r.length).fill(void 0))}return N(e)&&N(r)?Object.keys({...e,...r}).reduce((t,o)=>{let n=_(e?.[o],r?.[o]);return n===b?t:Object.assign(t,{[o]:n})},{}):r},R="";function q({args:e,argTypes:r}){let t={};return Object.entries(e).forEach(([o,n])=>{let{target:s=R}=r[o]||{};t[s]=t[s]||{},t[s][o]=n}),t}function ve(e){return q(e)[R]}function $r(e){return Object.keys(e).forEach(r=>e[r]===void 0&&delete e[r]),e}var G=class{constructor(){this.initialArgsByStoryId={};this.argsByStoryId={}}get(r){if(!(r in this.argsByStoryId))throw new Error(`No args known for ${r} -- has it been rendered yet?`);return this.argsByStoryId[r]}setInitial(r){if(!this.initialArgsByStoryId[r.id])this.initialArgsByStoryId[r.id]=r.initialArgs,this.argsByStoryId[r.id]=r.initialArgs;else if(this.initialArgsByStoryId[r.id]!==r.initialArgs){let t=_(this.initialArgsByStoryId[r.id],this.argsByStoryId[r.id]);this.initialArgsByStoryId[r.id]=r.initialArgs,this.argsByStoryId[r.id]=r.initialArgs,t!==b&&this.updateFromDelta(r,t)}}updateFromDelta(r,t){let o=dr(t,r.argTypes);this.argsByStoryId[r.id]=B(this.argsByStoryId[r.id],o)}updateFromPersisted(r,t){let o=cr(t,r.argTypes);return this.updateFromDelta(r,o)}update(r,t){if(!(r in this.argsByStoryId))throw new Error(`No args known for ${r} -- has it been rendered yet?`);this.argsByStoryId[r]=$r({...this.argsByStoryId[r],...t})}};import{logger as Vr}from"@storybook/client-logger";var k=(e={})=>Object.entries(e).reduce((r,[t,{defaultValue:o}])=>(typeof o<"u"&&(r[t]=o),r),{});var D=class{constructor({globals:r={},globalTypes:t={}}){this.set({globals:r,globalTypes:t})}set({globals:r={},globalTypes:t={}}){let o=this.initialGlobals&&_(this.initialGlobals,this.globals);this.allowedGlobalNames=new Set([...Object.keys(r),...Object.keys(t)]);let n=k(t);this.initialGlobals={...n,...r},this.globals=this.initialGlobals,o&&o!==b&&this.updateFromPersisted(o)}filterAllowedGlobals(r){return Object.entries(r).reduce((t,[o,n])=>(this.allowedGlobalNames.has(o)?t[o]=n:Vr.warn(`Attempted to set a global (${o}) that is not defined in initial globals or globalTypes`),t),{})}updateFromPersisted(r){let t=this.filterAllowedGlobals(r);this.globals={...this.globals,...t}}get(){return this.globals}update(r){this.globals={...this.globals,...this.filterAllowedGlobals(r)}}};import Lr from"lodash/mapValues";var vr=e=>typeof e=="string"?{name:e}:e,Wr=e=>typeof e=="string"?{type:e}:e,Hr=(e,r)=>{let{type:t,control:o,...n}=e,s={name:r,...n};return t&&(s.type=vr(t)),o?s.control=Wr(o):o===!1&&(s.control={disable:!0}),s},w=e=>Lr(e,Hr);import{storyNameFromExport as Ur,toId as Jr}from"@storybook/csf";import{dedent as Yr}from"ts-dedent";import{logger as qr}from"@storybook/client-logger";import Kr from"util-deprecate";var Qr=Yr`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`,Zr=Kr(()=>{},Qr);function M(e,r,t){let o=r,n=typeof r=="function"?r:null,{story:s}=o;s&&(qr.debug("deprecated story",s),Zr());let i=Ur(e),a=typeof o!="function"&&o.name||o.storyName||s?.name||i,l=[...o.decorators||[],...s?.decorators||[]],y={...s?.parameters,...o.parameters},d={...s?.args,...o.args},m={...s?.argTypes,...o.argTypes},f=[...o.loaders||[],...s?.loaders||[]],{render:u,play:j,tags:T=[]}=o,U=y.__id||Jr(t.id,i);return{moduleExport:r,id:U,name:a,tags:T,decorators:l,parameters:y,args:d,argTypes:w(m),loaders:f,...u&&{render:u},...n&&{userStoryFn:n},...j&&{play:j}}}import{isExportStory as re}from"@storybook/csf";import{logger as fr}from"@storybook/client-logger";import{sanitize as Xr}from"@storybook/csf";function $(e,r=e.title,t){let{id:o,argTypes:n}=e;return{id:Xr(o||r),...e,title:r,...n&&{argTypes:w(n)},parameters:{fileName:t,...e.parameters}}}var ee=e=>{let{globals:r,globalTypes:t}=e;(r||t)&&fr.error("Global args/argTypes can only be set globally",JSON.stringify({globals:r,globalTypes:t}))},te=e=>{let{options:r}=e;r?.storySort&&fr.error("The storySort option parameter can only be set globally")},Sr=e=>{!e||(ee(e),te(e))};function ur(e,r,t){let{default:o,__namedExportsOrder:n,...s}=e,i=$(o,t,r);Sr(i.parameters);let a={meta:i,stories:{}};return Object.keys(s).forEach(l=>{if(re(l,i)){let y=M(l,s[l],i);Sr(y.parameters),a.stories[y.id]=y}}),a}import{dedent as se}from"ts-dedent";import ie from"util-deprecate";import Fr from"global";import{includeConditionalArg as ae}from"@storybook/csf";import{applyHooks as le}from"@storybook/addons";import K from"lodash/isPlainObject";var F=(...e)=>{let r={},t=e.filter(Boolean),o=t.reduce((n,s)=>(Object.entries(s).forEach(([i,a])=>{let l=n[i];Array.isArray(a)||typeof l>"u"?n[i]=a:K(a)&&K(l)?r[i]=!0:typeof a<"u"&&(n[i]=a)}),n),{});return Object.keys(r).forEach(n=>{let s=t.filter(Boolean).map(i=>i[n]).filter(i=>typeof i<"u");s.every(i=>K(i))?o[n]=F(...s):o[n]=s[s.length-1]}),o};function oe(e,r,t){let o=t(e);return n=>r(o,n)}function ne({componentId:e,title:r,kind:t,id:o,name:n,story:s,parameters:i,initialArgs:a,argTypes:l,...y}={}){return y}function gr(e,r){let t={},o=s=>i=>{if(!t.value)throw new Error("Decorated function called without init");return t.value={...t.value,...ne(i)},s(t.value)},n=r.reduce((s,i)=>oe(s,i,o),e);return s=>(t.value=s,n(s))}var ye=ie(()=>{},se`
  \`argType.defaultValue\` is deprecated and will be removed in Storybook 7.0.

  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`);function V(e,r,t){let{moduleExport:o,id:n,name:s}=e,{title:i}=r,a=[...e.tags||r.tags||[],"story"],l=F(t.parameters,r.parameters,e.parameters),y=[...e.decorators||[],...r.decorators||[],...t.decorators||[]],{applyDecorators:d=gr,argTypesEnhancers:m=[],argsEnhancers:f=[],runStep:u}=t,j=[...t.loaders||[],...r.loaders||[],...e.loaders||[]],T=e.userStoryFn||e.render||r.render||t.render;if(!T)throw new Error(`No render function available for storyId '${n}'`);let U=F(t.argTypes,r.argTypes,e.argTypes),{passArgsFirst:Er=!0}=l;l.__isArgsStory=Er&&T.length>0;let ar={...t.args,...r.args,...e.args},g={componentId:r.id,title:i,kind:i,id:n,name:s,story:s,component:r.component,subcomponents:r.subcomponents,tags:a,parameters:l,initialArgs:ar,argTypes:U};g.argTypes=m.reduce((c,S)=>S({...g,argTypes:c}),g.argTypes);let lr=k(g.argTypes);Object.keys(lr).length>0&&ye();let Or={...lr,...ar};g.initialArgs=f.reduce((c,S)=>({...c,...S({...g,initialArgs:c})}),Or),Fr.FEATURES?.breakingChangesV7||(g.parameters={...g.parameters,__id:n,globals:t.globals,globalTypes:t.globalTypes,args:g.initialArgs,argTypes:g.argTypes});let jr=async c=>{let S=await Promise.all(j.map(A=>A(c))),h=Object.assign({},...S);return{...c,loaded:h}},yr=c=>{let S=Object.entries(c.args).reduce((C,[P,I])=>{let E=c.argTypes[P]?.mapping;return C[P]=E&&I in E?E[I]:I,C},{}),h=Object.entries(S).reduce((C,[P,I])=>{let E=c.argTypes[P]||{};return ae(E,S,c.globals)&&(C[P]=I),C},{}),A={...c,args:h},{passArgsFirst:Br=!0}=c.parameters;return Br?T(A.args,A):T(A)},zr=le(d)(yr,y),Nr=c=>{let S=c;if(Fr.FEATURES?.argTypeTargetsV7){let h=q(c);S={...c,allArgs:c.args,argsByTarget:h,args:h[R]||{}}}return zr(S)},{play:mr}=e;return Object.freeze({...g,moduleExport:o,originalStoryFn:T,undecoratedStoryFn:yr,unboundStoryFn:Nr,applyLoaders:jr,playFunction:mr&&(async c=>{let S={...c,step:(h,A)=>u(h,A,S)};return mr(S)})})}import Q from"lodash/mapValues";import{dedent as me}from"ts-dedent";import{logger as pe}from"@storybook/client-logger";var Z=(e,r,t)=>{let o=typeof e;switch(o){case"boolean":case"string":case"number":case"function":case"symbol":return{name:o};default:break}if(e){if(t.has(e))return pe.warn(me`
        We've detected a cycle in arg '${r}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args
      `),{name:"other",value:"cyclic object"};if(t.add(e),Array.isArray(e)){let s=e.length>0?Z(e[0],r,new Set(t)):{name:"other",value:"unknown"};return{name:"array",value:s}}let n=Q(e,s=>Z(s,r,new Set(t)));return{name:"object",value:n}}return{name:"object",value:{}}},X=e=>{let{id:r,argTypes:t={},initialArgs:o={}}=e,n=Q(o,(i,a)=>({name:a,type:Z(i,`${r}.${a}`,new Set)})),s=Q(t,(i,a)=>({name:a}));return F(n,s,t)};X.secondPass=!0;import de from"lodash/mapValues";import{logger as Se}from"@storybook/client-logger";import ce from"lodash/pickBy";var hr=(e,r)=>Array.isArray(r)?r.includes(e):e.match(r),rr=(e,r,t)=>!r&&!t?e:e&&ce(e,(o,n)=>{let s=o.name||n;return(!r||hr(s,r))&&(!t||!hr(s,t))});var fe=(e,r,t)=>{let{type:o,options:n}=e;if(!!o){if(t.color&&t.color.test(r)){let s=o.name;if(s==="string")return{control:{type:"color"}};s!=="enum"&&Se.warn(`Addon controls: Control of type color only supports string, received "${s}" instead`)}if(t.date&&t.date.test(r))return{control:{type:"date"}};switch(o.name){case"array":return{control:{type:"object"}};case"boolean":return{control:{type:"boolean"}};case"string":return{control:{type:"text"}};case"number":return{control:{type:"number"}};case"enum":{let{value:s}=o;return{control:{type:s?.length<=5?"radio":"select"},options:s}}case"function":case"symbol":return null;default:return{control:{type:n?"select":"object"}}}}},L=e=>{let{argTypes:r,parameters:{__isArgsStory:t,controls:{include:o=null,exclude:n=null,matchers:s={}}={}}}=e;if(!t)return r;let i=rr(r,o,n),a=de(i,(l,y)=>l?.type&&fe(l,y,s));return F(a,i)};L.secondPass=!0;function v({argTypes:e,globalTypes:r,argTypesEnhancers:t,...o}){return{...e&&{argTypes:w(e)},...r&&{globalTypes:w(r)},argTypesEnhancers:[...t||[],X,L],...o}}function Tr(e){return async(r,t,o)=>{await e.reduceRight((s,i)=>async()=>i(r,s,o),async()=>t(o))()}}function O(e,r){return e.map(t=>t[r]).filter(Boolean)}function W(e,r){return O(e,r).reduce((t,o)=>[...t,...o],[])}function H(e,r){return Object.assign({},...O(e,r))}function er(e,r){return O(e,r).pop()}function Ar(e){let r=W(e,"argTypesEnhancers"),t=O(e,"runStep");return{parameters:F(...O(e,"parameters")),decorators:W(e,"decorators"),args:H(e,"args"),argsEnhancers:W(e,"argsEnhancers"),argTypes:H(e,"argTypes"),argTypesEnhancers:[...r.filter(o=>!o.secondPass),...r.filter(o=>o.secondPass)],globals:H(e,"globals"),globalTypes:H(e,"globalTypes"),loaders:W(e,"loaders"),render:er(e,"render"),renderToDOM:er(e,"renderToDOM"),applyDecorators:er(e,"applyDecorators"),runStep:Tr(t)}}import{isExportStory as ue}from"@storybook/csf";import{HooksContext as ge}from"@storybook/addons";var br={};function eo(e){let r=Array.isArray(e)?e:[e];br=Ar(r)}function to(e,r,t=br,o={},n){if(e===void 0)throw new Error("Expected a story but received undefined.");r.title=r.title??"ComposedStory";let s=$(r),i=n||e.storyName||e.story?.name||e.name||"unknown",a=M(i,e,s),l=v({...t,...o}),y=V(a,s,l),d=k(t.globalTypes),m=f=>{let u={...y,hooks:new ge,globals:d,args:{...y.initialArgs,...f}};return y.unboundStoryFn(u)};return m.storyName=i,m.args=y.initialArgs,m.play=y.playFunction,m.parameters=y.parameters,m}function oo(e,r,t){let{default:o,__esModule:n,__namedExportsOrder:s,...i}=e;return Object.entries(i).reduce((l,[y,d])=>ue(y,o)?Object.assign(l,{[y]:t(d,o,r,y)}):l,{})}var Te=1e3,Ae=1e4,or=class{constructor(){this.getStoriesJsonData=()=>{let{storyIndex:r}=this;if(!r)throw new Error("getStoriesJsonData called before initialization");let t=this.getSetStoriesPayload(),o=["fileName","docsOnly","framework","__id","__isArgsStory"],n=Fe(t.stories,s=>{let{importPath:i}=r.entries[s.id];return{...xr(s,["id","name","title"]),importPath:i,kind:s.title,story:s.name,parameters:{...xr(s.parameters,o),fileName:i}}});return{v:3,stories:n}};this.args=new G,this.hooks={},this.processCSFFileWithCache=wr(Te)(ur),this.prepareStoryWithCache=wr(Ae)(V),this.initializationPromise=new tr(r=>{this.resolveInitializationPromise=r})}setProjectAnnotations(r){this.projectAnnotations=v(r);let{globals:t,globalTypes:o}=r;this.globals?this.globals.set({globals:t,globalTypes:o}):this.globals=new D({globals:t,globalTypes:o})}initialize({storyIndex:r,importFn:t,cache:o=!1}){return this.storyIndex=new z(r),this.importFn=t,this.resolveInitializationPromise(),o?this.cacheAllCSFFiles():tr.resolve()}async onStoriesChanged({importFn:r,storyIndex:t}){await this.initializationPromise,r&&(this.importFn=r),t&&(this.storyIndex.entries=t.entries),this.cachedCSFFiles&&await this.cacheAllCSFFiles()}async storyIdToEntry(r){return await this.initializationPromise,this.storyIndex.storyIdToEntry(r)}loadCSFFileByStoryId(r){if(!this.storyIndex||!this.importFn)throw new Error("loadCSFFileByStoryId called before initialization");let{importPath:t,title:o}=this.storyIndex.storyIdToEntry(r);return this.importFn(t).then(n=>this.processCSFFileWithCache(n,t,o))}loadAllCSFFiles(){if(!this.storyIndex)throw new Error("loadAllCSFFiles called before initialization");let r={};Object.entries(this.storyIndex.entries).forEach(([o,{importPath:n}])=>{r[n]=o});let t=Object.entries(r).map(([o,n])=>this.loadCSFFileByStoryId(n).then(s=>({importPath:o,csfFile:s})));return tr.all(t).then(o=>o.reduce((n,{importPath:s,csfFile:i})=>(n[s]=i,n),{}))}cacheAllCSFFiles(){return this.initializationPromise.then(()=>this.loadAllCSFFiles().then(r=>{this.cachedCSFFiles=r}))}async loadStory({storyId:r}){await this.initializationPromise;let t=await this.loadCSFFileByStoryId(r);return this.storyFromCSFFile({storyId:r,csfFile:t})}storyFromCSFFile({storyId:r,csfFile:t}){if(!this.projectAnnotations)throw new Error("storyFromCSFFile called before initialization");let o=t.stories[r];if(!o)throw new Error(`Didn't find '${r}' in CSF file, this is unexpected`);let n=t.meta,s=this.prepareStoryWithCache(o,n,this.projectAnnotations);return this.args.setInitial(s),this.hooks[s.id]=this.hooks[s.id]||new he,s}componentStoriesFromCSFFile({csfFile:r}){if(!this.storyIndex)throw new Error("componentStoriesFromCSFFile called before initialization");return Object.keys(this.storyIndex.entries).filter(t=>!!r.stories[t]).map(t=>this.storyFromCSFFile({storyId:t,csfFile:r}))}async loadEntry(r){let t=await this.storyIdToEntry(r),{importFn:o,storyIndex:n}=this;if(!n||!o)throw new Error("loadEntry called before initialization");let s=t.type==="docs"?t.storiesImports:[],[i,...a]=await Promise.all([o(t.importPath),...s.map(l=>{let y=n.importPathToEntry(l);return this.loadCSFFileByStoryId(y.id)})]);return{entryExports:i,csfFiles:a}}getStoryContext(r){if(!this.globals)throw new Error("getStoryContext called before initialization");return{...r,args:this.args.get(r.id),globals:this.globals.get(),hooks:this.hooks[r.id]}}cleanupStory(r){this.hooks[r.id].clean()}extract(r={includeDocsOnly:!1}){if(!this.storyIndex)throw new Error("extract called before initialization");let{cachedCSFFiles:t}=this;if(!t)throw new Error("Cannot call extract() unless you call cacheAllCSFFiles() first.");return Object.entries(this.storyIndex.entries).reduce((o,[n,{type:s,importPath:i}])=>{if(s==="docs")return o;let a=t[i],l=this.storyFromCSFFile({storyId:n,csfFile:a});return!r.includeDocsOnly&&l.parameters.docsOnly||(o[n]=Object.entries(l).reduce((y,[d,m])=>d==="moduleExport"||typeof m=="function"?y:Array.isArray(m)?Object.assign(y,{[d]:m.slice().sort()}):Object.assign(y,{[d]:m}),{args:l.initialArgs})),o},{})}getSetStoriesPayload(){if(!this.globals)throw new Error("getSetStoriesPayload called before initialization");let r=this.extract({includeDocsOnly:!0}),t=Object.values(r).reduce((o,{title:n})=>(o[n]={},o),{});return{v:2,globals:this.globals.get(),globalParameters:{},kindParameters:t,stories:r}}getSetIndexPayload(){if(!this.storyIndex)throw new Error("getSetIndexPayload called before initialization");let r=this.extract({includeDocsOnly:!0});return{v:4,entries:Object.fromEntries(Object.entries(this.storyIndex.entries).map(([t,o])=>[t,r[t]?{...o,args:r[t].initialArgs,initialArgs:r[t].initialArgs,argTypes:r[t].argTypes,parameters:r[t].parameters}:o]))}}raw(){return Object.values(this.extract()).map(({id:r})=>this.fromId(r)).filter(Boolean)}fromId(r){if(!this.storyIndex)throw new Error("fromId called before initialization");if(!this.cachedCSFFiles)throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");let t;try{({importPath:t}=this.storyIndex.storyIdToEntry(r))}catch{return null}let o=this.cachedCSFFiles[t],n=this.storyFromCSFFile({storyId:r,csfFile:o});return{...n,storyFn:s=>{let i={...this.getStoryContext(n),viewMode:"story"};return n.unboundStoryFn({...i,...s})}}}};import{SHARED_STATE_CHANGED as nr,SHARED_STATE_SET as sr}from"@storybook/core-events";import{addons as be,HooksContext as Fo,applyHooks as ho,useMemo as we,useCallback as To,useRef as Ao,useState as xe,useReducer as bo,useEffect as _e,useChannel as ke,useStoryContext as wo,useParameter as xo,useArgs as _o,useGlobals as ko}from"@storybook/addons";function Ce(e,r){let t=be.getChannel(),[o]=t.last(`${nr}-manager-${e}`)||t.last(`${sr}-manager-${e}`)||[],[n,s]=xe(o||r),i=we(()=>({[`${nr}-manager-${e}`]:l=>s(l),[`${sr}-manager-${e}`]:l=>s(l)}),[e]),a=ke(i,[e]);return _e(()=>{r!==void 0&&!o&&a(`${sr}-client-${e}`,r)},[e]),[n,l=>{s(l),a(`${nr}-client-${e}`,l)}]}function Co(e,r){return Ce(e,r)}import ir from"slash";import{dedent as Pe}from"ts-dedent";import{once as Ie}from"@storybook/client-logger";var Ee=e=>{let r=[...e],t=r[r.length-1],o=t.indexOf("."),n=o>0?t.substr(0,o):t;r[r.length-1]=n;let[s,...i]=r;return s===""&&(r=i),r},Oe=/^index$/i,je=e=>{let r;return e.filter((t,o)=>o===e.length-1&&(t===r||Oe.test(t))?!1:(r=t,!0))};function _r(e){let r=new RegExp("/{1,}","g");return e.join("/").replace(r,"/")}var ze=(e,r,t)=>{let{directory:o,importPathMatcher:n,titlePrefix:s=""}=r||{};typeof e=="number"&&Ie.warn(Pe`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);let i=ir(String(e));if(n.exec(i)){if(!t){let a=i.replace(o,""),y=ir(_r([s,a])).split("/");return y=Ee(y),y=je(y),y.join("/")}return s?ir(_r([s,t])):t}},jo=(e,r,t)=>{for(let o=0;o<r.length;o+=1){let n=ze(e,r[o],t);if(n)return n}return t||void 0};import{dedent as Ne}from"ts-dedent";var kr=/\s*\/\s*/,Cr=(e={})=>(r,t)=>{if(r.title===t.title&&!e.includeNames)return 0;let o=e.method||"configure",n=e.order||[],s=r.title.trim().split(kr),i=t.title.trim().split(kr);e.includeNames&&(s.push(r.name),i.push(t.name));let a=0;for(;s[a]||i[a];){if(!s[a])return-1;if(!i[a])return 1;let l=s[a],y=i[a];if(l!==y){let m=n.indexOf(l),f=n.indexOf(y),u=n.indexOf("*");return m!==-1||f!==-1?(m===-1&&(u!==-1?m=u:m=n.length),f===-1&&(u!==-1?f=u:f=n.length),m-f):o==="configure"?0:l.localeCompare(y,e.locales?e.locales:void 0,{numeric:!0,sensitivity:"accent"})}let d=n.indexOf(l);d===-1&&(d=n.indexOf("*")),n=d!==-1&&Array.isArray(n[d+1])?n[d+1]:[],a+=1}return 0};var Ir=(e,r,t)=>{if(r){let o;typeof r=="function"?o=r:o=Cr(r),e.sort(o)}else e.sort((o,n)=>t.indexOf(o.importPath)-t.indexOf(n.importPath));return e},Go=(e,r,t)=>{try{return Ir(e,r,t)}catch(o){throw new Error(Ne`
    Error sorting stories with sort parameter ${r}:

    > ${o.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `)}},Pr=e=>{let{id:r,title:t,name:o,parameters:n,type:s}=e;return{id:r,title:t,name:o,importPath:n.fileName,type:s}},Do=(e,r,t)=>{if(r&&typeof r=="function")return e.sort(r),e.map(n=>Pr(n[1]));let o=e.map(n=>Pr(n[1]));return Ir(o,r,t)};export{b as DEEPLY_EQUAL,Fo as HooksContext,R as NO_TARGET_NAME,or as StoryStore,ho as applyHooks,B as combineArgs,F as combineParameters,Ar as composeConfigs,Tr as composeStepRunners,oo as composeStories,to as composeStory,oe as decorateStory,_ as deepDiff,gr as defaultDecorateStory,rr as filterArgTypes,W as getArrayField,O as getField,H as getObjectField,er as getSingletonField,k as getValuesFromArgTypes,q as groupArgsByTarget,L as inferControls,cr as mapArgsToTypes,ve as noTargetArgs,$ as normalizeComponentAnnotations,Hr as normalizeInputType,w as normalizeInputTypes,v as normalizeProjectAnnotations,M as normalizeStory,V as prepareStory,ur as processCSFFile,ne as sanitizeStoryContextUpdate,eo as setProjectAnnotations,Do as sortStoriesV6,Go as sortStoriesV7,Co as useAddonState,_o as useArgs,To as useCallback,ke as useChannel,_e as useEffect,ko as useGlobals,we as useMemo,xo as useParameter,bo as useReducer,Ao as useRef,Ce as useSharedState,xe as useState,wo as useStoryContext,jo as userOrAutoTitle,ze as userOrAutoTitleFromSpecifier,dr as validateOptions};
