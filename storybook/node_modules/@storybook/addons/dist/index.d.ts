import { Channel } from '@storybook/channels';
import { API } from '@storybook/api';
import { Addon_Types, Addon_Collection, Addon_Type, Addon_Config, Addon_StoryWrapper, AnyFramework, StoryContext, StoryId, DecoratorApplicator, Args } from '@storybook/types';
export { Addon_Type as Addon, Addon_TypesEnum as types } from '@storybook/types';

declare function isSupportedType(type: Addon_Types): boolean;
declare class AddonStore {
    constructor();
    private loaders;
    private elements;
    private config;
    private channel;
    private serverChannel;
    private promise;
    private resolve;
    getChannel: () => Channel;
    getServerChannel: () => Channel;
    ready: () => Promise<Channel>;
    hasChannel: () => boolean;
    hasServerChannel: () => boolean;
    setChannel: (channel: Channel) => void;
    setServerChannel: (channel: Channel) => void;
    getElements: (type: Addon_Types) => Addon_Collection;
    addPanel: (name: string, options: Addon_Type) => void;
    add: (name: string, addon: Addon_Type) => void;
    setConfig: (value: Addon_Config) => void;
    getConfig: () => Addon_Config;
    register: (name: string, registerCallback: (api: API) => void) => void;
    loadAddons: (api: any) => void;
}
declare const addons: AddonStore;

declare type MakeDecoratorResult = (...args: any) => any;
interface MakeDecoratorOptions {
    name: string;
    parameterName: string;
    skipIfNoParametersOrOptions?: boolean;
    wrapper: Addon_StoryWrapper;
}
declare const makeDecorator: ({ name, parameterName, wrapper, skipIfNoParametersOrOptions, }: MakeDecoratorOptions) => MakeDecoratorResult;

declare function mockChannel(): Channel;

interface Hook {
    name: string;
    memoizedState?: any;
    deps?: any[] | undefined;
}
interface Effect {
    create: () => (() => void) | void;
    destroy?: (() => void) | void;
}
declare type AbstractFunction = (...args: any[]) => any;
declare class HooksContext<TFramework extends AnyFramework> {
    hookListsMap: WeakMap<AbstractFunction, Hook[]>;
    mountedDecorators: Set<AbstractFunction>;
    prevMountedDecorators: Set<AbstractFunction>;
    currentHooks: Hook[];
    nextHookIndex: number;
    currentPhase: 'MOUNT' | 'UPDATE' | 'NONE';
    currentEffects: Effect[];
    prevEffects: Effect[];
    currentDecoratorName: string | null;
    hasUpdates: boolean;
    currentContext: StoryContext<TFramework> | null;
    renderListener: (storyId: StoryId) => void;
    constructor();
    init(): void;
    clean(): void;
    getNextHook(): Hook;
    triggerEffects(): void;
    addRenderListeners(): void;
    removeRenderListeners(): void;
}
declare const applyHooks: <TFramework extends AnyFramework>(applyDecorators: DecoratorApplicator<TFramework, Args>) => DecoratorApplicator<TFramework, Args>;
declare function useMemo<T>(nextCreate: () => T, deps?: any[]): T;
declare function useCallback<T>(callback: T, deps?: any[]): T;
declare function useRef<T>(initialValue: T): {
    current: T;
};
declare function useState<S>(initialState: (() => S) | S): [S, (update: ((prevState: S) => S) | S) => void];
declare function useReducer<S, A>(reducer: (state: S, action: A) => S, initialState: S): [S, (action: A) => void];
declare function useReducer<S, I, A>(reducer: (state: S, action: A) => S, initialArg: I, init: (initialArg: I) => S): [S, (action: A) => void];
declare function useEffect(create: () => (() => void) | void, deps?: any[]): void;
interface Listener {
    (...args: any[]): void;
}
interface EventMap {
    [eventId: string]: Listener;
}
declare function useChannel(eventMap: EventMap, deps?: any[]): (eventName: string, ...args: any) => void;
declare function useStoryContext<TFramework extends AnyFramework>(): StoryContext<TFramework>;
declare function useParameter<S>(parameterKey: string, defaultValue?: S): S | undefined;
declare function useArgs<SpecificArgs = Args>(): [
    SpecificArgs,
    (newArgs: Partial<SpecificArgs>) => void,
    (argNames?: (keyof SpecificArgs)[]) => void
];
declare function useGlobals(): [Args, (newGlobals: Args) => void];

export { AddonStore, EventMap, HooksContext, Listener, addons, applyHooks, addons as default, isSupportedType, makeDecorator, mockChannel, useArgs, useCallback, useChannel, useEffect, useGlobals, useMemo, useParameter, useReducer, useRef, useState, useStoryContext };
