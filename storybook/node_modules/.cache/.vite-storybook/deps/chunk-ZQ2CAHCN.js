import {
  includeConditionalArg,
  isExportStory,
  sanitize,
  storyNameFromExport,
  toId
} from "./chunk-H7VH7ZR2.js";
import {
  dedent
} from "./chunk-6P6QZ5GB.js";
import {
  require_browser
} from "./chunk-7LRRBEWW.js";
import {
  require_slash
} from "./chunk-2B4PH5BP.js";
import {
  require_synchronous_promise
} from "./chunk-N442H5QH.js";
import {
  require_mapValues
} from "./chunk-RTPUDCD3.js";
import {
  require_pick
} from "./chunk-2NUKKQBK.js";
import {
  require_pickBy
} from "./chunk-R7UUYJRS.js";
import {
  require_isPlainObject
} from "./chunk-G7LAUJAA.js";
import {
  Y,
  c,
  de,
  ie,
  ne,
  se,
  x
} from "./chunk-UACHQL3Y.js";
import {
  V,
  s
} from "./chunk-M3XCZAQ7.js";
import {
  require_memoizerific
} from "./chunk-E3PQJO36.js";
import {
  i,
  n
} from "./chunk-3QDDUDC7.js";
import {
  require_window
} from "./chunk-Z3ID2O7F.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@storybook/store/dist/index.mjs
var import_memoizerific = __toESM(require_memoizerific(), 1);
var import_mapValues = __toESM(require_mapValues(), 1);
var import_pick = __toESM(require_pick(), 1);
var import_synchronous_promise = __toESM(require_synchronous_promise(), 1);
var import_memoizerific2 = __toESM(require_memoizerific(), 1);

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/@storybook/store/dist/index.mjs
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
var import_mapValues2 = __toESM(require_mapValues(), 1);
var import_util_deprecate = __toESM(require_browser(), 1);
var import_util_deprecate2 = __toESM(require_browser(), 1);
var import_global = __toESM(require_window(), 1);
var import_isPlainObject2 = __toESM(require_isPlainObject(), 1);
var import_mapValues3 = __toESM(require_mapValues(), 1);
var import_mapValues4 = __toESM(require_mapValues(), 1);
var import_pickBy = __toESM(require_pickBy(), 1);
var import_slash = __toESM(require_slash(), 1);
var Dr = (0, import_memoizerific2.default)(1)((e) => Object.values(e).reduce((r, t) => (r[t.importPath] = r[t.importPath] || t, r), {}));
var z = class {
  constructor({ entries: r } = { v: 4, entries: {} }) {
    this.entries = r;
  }
  entryFromSpecifier(r) {
    let t = Object.values(this.entries);
    if (r === "*")
      return t[0];
    if (typeof r == "string")
      return this.entries[r] ? this.entries[r] : t.find((s2) => s2.id.startsWith(r));
    let { name: o, title: n2 } = r;
    return t.find((s2) => s2.name === o && s2.title === n2);
  }
  storyIdToEntry(r) {
    let t = this.entries[r];
    if (!t)
      throw new Error(dedent`Couldn't find story matching '${r}' after HMR.
      - Did you remove it from your CSF file?
      - Are you sure a story with that id exists?
      - Please check your entries field of your main.js config.
      - Also check the browser console and terminal for error messages.`);
    return t;
  }
  importPathToEntry(r) {
    return Dr(this.entries)[r];
  }
};
var x2 = Symbol("incompatible");
var Y2 = (e, r) => {
  let t = r.type;
  if (e == null || !t || r.mapping)
    return e;
  switch (t.name) {
    case "string":
      return String(e);
    case "enum":
      return e;
    case "number":
      return Number(e);
    case "boolean":
      return e === "true";
    case "array":
      return !t.value || !Array.isArray(e) ? x2 : e.reduce((o, n2, s2) => {
        let i2 = Y2(n2, { type: t.value });
        return i2 !== x2 && (o[s2] = i2), o;
      }, new Array(e.length));
    case "object":
      return typeof e == "string" || typeof e == "number" ? e : !t.value || typeof e != "object" ? x2 : Object.entries(e).reduce((o, [n2, s2]) => {
        let i2 = Y2(s2, { type: t.value[n2] });
        return i2 === x2 ? o : Object.assign(o, { [n2]: i2 });
      }, {});
    default:
      return x2;
  }
};
var cr = (e, r) => Object.entries(e).reduce((t, [o, n2]) => {
  if (!r[o])
    return t;
  let s2 = Y2(n2, r[o]);
  return s2 === x2 ? t : Object.assign(t, { [o]: s2 });
}, {});
var B = (e, r) => Array.isArray(e) && Array.isArray(r) ? r.reduce((t, o, n2) => (t[n2] = B(e[n2], r[n2]), t), [...e]).filter((t) => t !== void 0) : !(0, import_isPlainObject.default)(e) || !(0, import_isPlainObject.default)(r) ? r : Object.keys({ ...e, ...r }).reduce((t, o) => {
  if (o in r) {
    let n2 = B(e[o], r[o]);
    n2 !== void 0 && (t[o] = n2);
  } else
    t[o] = e[o];
  return t;
}, {});
var dr = (e, r) => Object.entries(r).reduce((t, [o, { options: n2 }]) => {
  function s2() {
    return o in e && (t[o] = e[o]), t;
  }
  if (!n2)
    return s2();
  if (!Array.isArray(n2))
    return n.error(dedent`
        Invalid argType: '${o}.options' should be an array.

        More info: https://storybook.js.org/docs/react/api/argtypes
      `), s2();
  if (n2.some((m) => m && ["object", "function"].includes(typeof m)))
    return n.error(dedent`
        Invalid argType: '${o}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
      `), s2();
  let i2 = Array.isArray(e[o]), a = i2 && e[o].findIndex((m) => !n2.includes(m)), l = i2 && a === -1;
  if (e[o] === void 0 || n2.includes(e[o]) || l)
    return s2();
  let y = i2 ? `${o}[${a}]` : o, d = n2.map((m) => typeof m == "string" ? `'${m}'` : String(m)).join(", ");
  return n.warn(`Received illegal value for '${y}'. Supported options: ${d}`), t;
}, {});
var b = Symbol("Deeply equal");
var _ = (e, r) => {
  if (typeof e != typeof r)
    return r;
  if (dequal(e, r))
    return b;
  if (Array.isArray(e) && Array.isArray(r)) {
    let t = r.reduce((o, n2, s2) => {
      let i2 = _(e[s2], n2);
      return i2 !== b && (o[s2] = i2), o;
    }, new Array(r.length));
    return r.length >= e.length ? t : t.concat(new Array(e.length - r.length).fill(void 0));
  }
  return (0, import_isPlainObject.default)(e) && (0, import_isPlainObject.default)(r) ? Object.keys({ ...e, ...r }).reduce((t, o) => {
    let n2 = _(e == null ? void 0 : e[o], r == null ? void 0 : r[o]);
    return n2 === b ? t : Object.assign(t, { [o]: n2 });
  }, {}) : r;
};
var R = "";
function q({ args: e, argTypes: r }) {
  let t = {};
  return Object.entries(e).forEach(([o, n2]) => {
    let { target: s2 = R } = r[o] || {};
    t[s2] = t[s2] || {}, t[s2][o] = n2;
  }), t;
}
function ve(e) {
  return q(e)[R];
}
function $r(e) {
  return Object.keys(e).forEach((r) => e[r] === void 0 && delete e[r]), e;
}
var G = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(r) {
    if (!(r in this.argsByStoryId))
      throw new Error(`No args known for ${r} -- has it been rendered yet?`);
    return this.argsByStoryId[r];
  }
  setInitial(r) {
    if (!this.initialArgsByStoryId[r.id])
      this.initialArgsByStoryId[r.id] = r.initialArgs, this.argsByStoryId[r.id] = r.initialArgs;
    else if (this.initialArgsByStoryId[r.id] !== r.initialArgs) {
      let t = _(this.initialArgsByStoryId[r.id], this.argsByStoryId[r.id]);
      this.initialArgsByStoryId[r.id] = r.initialArgs, this.argsByStoryId[r.id] = r.initialArgs, t !== b && this.updateFromDelta(r, t);
    }
  }
  updateFromDelta(r, t) {
    let o = dr(t, r.argTypes);
    this.argsByStoryId[r.id] = B(this.argsByStoryId[r.id], o);
  }
  updateFromPersisted(r, t) {
    let o = cr(t, r.argTypes);
    return this.updateFromDelta(r, o);
  }
  update(r, t) {
    if (!(r in this.argsByStoryId))
      throw new Error(`No args known for ${r} -- has it been rendered yet?`);
    this.argsByStoryId[r] = $r({ ...this.argsByStoryId[r], ...t });
  }
};
var k = (e = {}) => Object.entries(e).reduce((r, [t, { defaultValue: o }]) => (typeof o < "u" && (r[t] = o), r), {});
var D = class {
  constructor({ globals: r = {}, globalTypes: t = {} }) {
    this.set({ globals: r, globalTypes: t });
  }
  set({ globals: r = {}, globalTypes: t = {} }) {
    let o = this.initialGlobals && _(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(r), ...Object.keys(t)]);
    let n2 = k(t);
    this.initialGlobals = { ...n2, ...r }, this.globals = this.initialGlobals, o && o !== b && this.updateFromPersisted(o);
  }
  filterAllowedGlobals(r) {
    return Object.entries(r).reduce((t, [o, n2]) => (this.allowedGlobalNames.has(o) ? t[o] = n2 : i.warn(`Attempted to set a global (${o}) that is not defined in initial globals or globalTypes`), t), {});
  }
  updateFromPersisted(r) {
    let t = this.filterAllowedGlobals(r);
    this.globals = { ...this.globals, ...t };
  }
  get() {
    return this.globals;
  }
  update(r) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(r) };
  }
};
var vr = (e) => typeof e == "string" ? { name: e } : e;
var Wr = (e) => typeof e == "string" ? { type: e } : e;
var Hr = (e, r) => {
  let { type: t, control: o, ...n2 } = e, s2 = { name: r, ...n2 };
  return t && (s2.type = vr(t)), o ? s2.control = Wr(o) : o === false && (s2.control = { disable: true }), s2;
};
var w = (e) => (0, import_mapValues2.default)(e, Hr);
var Qr = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
var Zr = (0, import_util_deprecate.default)(() => {
}, Qr);
function M(e, r, t) {
  let o = r, n2 = typeof r == "function" ? r : null, { story: s2 } = o;
  s2 && (i.debug("deprecated story", s2), Zr());
  let i2 = storyNameFromExport(e), a = typeof o != "function" && o.name || o.storyName || (s2 == null ? void 0 : s2.name) || i2, l = [...o.decorators || [], ...(s2 == null ? void 0 : s2.decorators) || []], y = { ...s2 == null ? void 0 : s2.parameters, ...o.parameters }, d = { ...s2 == null ? void 0 : s2.args, ...o.args }, m = { ...s2 == null ? void 0 : s2.argTypes, ...o.argTypes }, f2 = [...o.loaders || [], ...(s2 == null ? void 0 : s2.loaders) || []], { render: u, play: j, tags: T = [] } = o, U = y.__id || toId(t.id, i2);
  return { moduleExport: r, id: U, name: a, tags: T, decorators: l, parameters: y, args: d, argTypes: w(m), loaders: f2, ...u && { render: u }, ...n2 && { userStoryFn: n2 }, ...j && { play: j } };
}
function $(e, r = e.title, t) {
  let { id: o, argTypes: n2 } = e;
  return { id: sanitize(o || r), ...e, title: r, ...n2 && { argTypes: w(n2) }, parameters: { fileName: t, ...e.parameters } };
}
var ee = (e) => {
  let { globals: r, globalTypes: t } = e;
  (r || t) && i.error("Global args/argTypes can only be set globally", JSON.stringify({ globals: r, globalTypes: t }));
};
var te = (e) => {
  let { options: r } = e;
  (r == null ? void 0 : r.storySort) && i.error("The storySort option parameter can only be set globally");
};
var Sr = (e) => {
  !e || (ee(e), te(e));
};
function ur(e, r, t) {
  let { default: o, __namedExportsOrder: n2, ...s2 } = e, i2 = $(o, t, r);
  Sr(i2.parameters);
  let a = { meta: i2, stories: {} };
  return Object.keys(s2).forEach((l) => {
    if (isExportStory(l, i2)) {
      let y = M(l, s2[l], i2);
      Sr(y.parameters), a.stories[y.id] = y;
    }
  }), a;
}
var F = (...e) => {
  let r = {}, t = e.filter(Boolean), o = t.reduce((n2, s2) => (Object.entries(s2).forEach(([i2, a]) => {
    let l = n2[i2];
    Array.isArray(a) || typeof l > "u" ? n2[i2] = a : (0, import_isPlainObject2.default)(a) && (0, import_isPlainObject2.default)(l) ? r[i2] = true : typeof a < "u" && (n2[i2] = a);
  }), n2), {});
  return Object.keys(r).forEach((n2) => {
    let s2 = t.filter(Boolean).map((i2) => i2[n2]).filter((i2) => typeof i2 < "u");
    s2.every((i2) => (0, import_isPlainObject2.default)(i2)) ? o[n2] = F(...s2) : o[n2] = s2[s2.length - 1];
  }), o;
};
function oe(e, r, t) {
  let o = t(e);
  return (n2) => r(o, n2);
}
function ne2({ componentId: e, title: r, kind: t, id: o, name: n2, story: s2, parameters: i2, initialArgs: a, argTypes: l, ...y } = {}) {
  return y;
}
function gr(e, r) {
  let t = {}, o = (s2) => (i2) => {
    if (!t.value)
      throw new Error("Decorated function called without init");
    return t.value = { ...t.value, ...ne2(i2) }, s2(t.value);
  }, n2 = r.reduce((s2, i2) => oe(s2, i2, o), e);
  return (s2) => (t.value = s2, n2(s2));
}
var ye = (0, import_util_deprecate2.default)(() => {
}, dedent`
  \`argType.defaultValue\` is deprecated and will be removed in Storybook 7.0.

  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`);
function V2(e, r, t) {
  var _a;
  let { moduleExport: o, id: n2, name: s2 } = e, { title: i2 } = r, a = [...e.tags || r.tags || [], "story"], l = F(t.parameters, r.parameters, e.parameters), y = [...e.decorators || [], ...r.decorators || [], ...t.decorators || []], { applyDecorators: d = gr, argTypesEnhancers: m = [], argsEnhancers: f2 = [], runStep: u } = t, j = [...t.loaders || [], ...r.loaders || [], ...e.loaders || []], T = e.userStoryFn || e.render || r.render || t.render;
  if (!T)
    throw new Error(`No render function available for storyId '${n2}'`);
  let U = F(t.argTypes, r.argTypes, e.argTypes), { passArgsFirst: Er = true } = l;
  l.__isArgsStory = Er && T.length > 0;
  let ar = { ...t.args, ...r.args, ...e.args }, g = { componentId: r.id, title: i2, kind: i2, id: n2, name: s2, story: s2, component: r.component, subcomponents: r.subcomponents, tags: a, parameters: l, initialArgs: ar, argTypes: U };
  g.argTypes = m.reduce((c2, S) => S({ ...g, argTypes: c2 }), g.argTypes);
  let lr = k(g.argTypes);
  Object.keys(lr).length > 0 && ye();
  let Or = { ...lr, ...ar };
  g.initialArgs = f2.reduce((c2, S) => ({ ...c2, ...S({ ...g, initialArgs: c2 }) }), Or), ((_a = import_global.default.FEATURES) == null ? void 0 : _a.breakingChangesV7) || (g.parameters = { ...g.parameters, __id: n2, globals: t.globals, globalTypes: t.globalTypes, args: g.initialArgs, argTypes: g.argTypes });
  let jr = async (c2) => {
    let S = await Promise.all(j.map((A) => A(c2))), h = Object.assign({}, ...S);
    return { ...c2, loaded: h };
  }, yr = (c2) => {
    let S = Object.entries(c2.args).reduce((C, [P, I]) => {
      var _a2;
      let E = (_a2 = c2.argTypes[P]) == null ? void 0 : _a2.mapping;
      return C[P] = E && I in E ? E[I] : I, C;
    }, {}), h = Object.entries(S).reduce((C, [P, I]) => {
      let E = c2.argTypes[P] || {};
      return includeConditionalArg(E, S, c2.globals) && (C[P] = I), C;
    }, {}), A = { ...c2, args: h }, { passArgsFirst: Br = true } = c2.parameters;
    return Br ? T(A.args, A) : T(A);
  }, zr = ne(d)(yr, y), Nr = (c2) => {
    var _a2;
    let S = c2;
    if ((_a2 = import_global.default.FEATURES) == null ? void 0 : _a2.argTypeTargetsV7) {
      let h = q(c2);
      S = { ...c2, allArgs: c2.args, argsByTarget: h, args: h[R] || {} };
    }
    return zr(S);
  }, { play: mr } = e;
  return Object.freeze({ ...g, moduleExport: o, originalStoryFn: T, undecoratedStoryFn: yr, unboundStoryFn: Nr, applyLoaders: jr, playFunction: mr && (async (c2) => {
    let S = { ...c2, step: (h, A) => u(h, A, S) };
    return mr(S);
  }) });
}
var Z = (e, r, t) => {
  let o = typeof e;
  switch (o) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: o };
    default:
      break;
  }
  if (e) {
    if (t.has(e))
      return i.warn(dedent`
        We've detected a cycle in arg '${r}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" };
    if (t.add(e), Array.isArray(e)) {
      let s2 = e.length > 0 ? Z(e[0], r, new Set(t)) : { name: "other", value: "unknown" };
      return { name: "array", value: s2 };
    }
    let n2 = (0, import_mapValues3.default)(e, (s2) => Z(s2, r, new Set(t)));
    return { name: "object", value: n2 };
  }
  return { name: "object", value: {} };
};
var X = (e) => {
  let { id: r, argTypes: t = {}, initialArgs: o = {} } = e, n2 = (0, import_mapValues3.default)(o, (i2, a) => ({ name: a, type: Z(i2, `${r}.${a}`, /* @__PURE__ */ new Set()) })), s2 = (0, import_mapValues3.default)(t, (i2, a) => ({ name: a }));
  return F(n2, s2, t);
};
X.secondPass = true;
var hr = (e, r) => Array.isArray(r) ? r.includes(e) : e.match(r);
var rr = (e, r, t) => !r && !t ? e : e && (0, import_pickBy.default)(e, (o, n2) => {
  let s2 = o.name || n2;
  return (!r || hr(s2, r)) && (!t || !hr(s2, t));
});
var fe = (e, r, t) => {
  let { type: o, options: n2 } = e;
  if (!!o) {
    if (t.color && t.color.test(r)) {
      let s2 = o.name;
      if (s2 === "string")
        return { control: { type: "color" } };
      s2 !== "enum" && i.warn(`Addon controls: Control of type color only supports string, received "${s2}" instead`);
    }
    if (t.date && t.date.test(r))
      return { control: { type: "date" } };
    switch (o.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: s2 } = o;
        return { control: { type: (s2 == null ? void 0 : s2.length) <= 5 ? "radio" : "select" }, options: s2 };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: n2 ? "select" : "object" } };
    }
  }
};
var L = (e) => {
  let { argTypes: r, parameters: { __isArgsStory: t, controls: { include: o = null, exclude: n2 = null, matchers: s2 = {} } = {} } } = e;
  if (!t)
    return r;
  let i2 = rr(r, o, n2), a = (0, import_mapValues4.default)(i2, (l, y) => (l == null ? void 0 : l.type) && fe(l, y, s2));
  return F(a, i2);
};
L.secondPass = true;
function v2({ argTypes: e, globalTypes: r, argTypesEnhancers: t, ...o }) {
  return { ...e && { argTypes: w(e) }, ...r && { globalTypes: w(r) }, argTypesEnhancers: [...t || [], X, L], ...o };
}
function Tr(e) {
  return async (r, t, o) => {
    await e.reduceRight((s2, i2) => async () => i2(r, s2, o), async () => t(o))();
  };
}
function O(e, r) {
  return e.map((t) => t[r]).filter(Boolean);
}
function W(e, r) {
  return O(e, r).reduce((t, o) => [...t, ...o], []);
}
function H(e, r) {
  return Object.assign({}, ...O(e, r));
}
function er(e, r) {
  return O(e, r).pop();
}
function Ar(e) {
  let r = W(e, "argTypesEnhancers"), t = O(e, "runStep");
  return { parameters: F(...O(e, "parameters")), decorators: W(e, "decorators"), args: H(e, "args"), argsEnhancers: W(e, "argsEnhancers"), argTypes: H(e, "argTypes"), argTypesEnhancers: [...r.filter((o) => !o.secondPass), ...r.filter((o) => o.secondPass)], globals: H(e, "globals"), globalTypes: H(e, "globalTypes"), loaders: W(e, "loaders"), render: er(e, "render"), renderToDOM: er(e, "renderToDOM"), applyDecorators: er(e, "applyDecorators"), runStep: Tr(t) };
}
var br = {};
function eo(e) {
  let r = Array.isArray(e) ? e : [e];
  br = Ar(r);
}
function to(e, r, t = br, o = {}, n2) {
  var _a, _b;
  if (e === void 0)
    throw new Error("Expected a story but received undefined.");
  r.title = (_a = r.title) != null ? _a : "ComposedStory";
  let s2 = $(r), i2 = n2 || e.storyName || ((_b = e.story) == null ? void 0 : _b.name) || e.name || "unknown", a = M(i2, e, s2), l = v2({ ...t, ...o }), y = V2(a, s2, l), d = k(t.globalTypes), m = (f2) => {
    let u = { ...y, hooks: new x(), globals: d, args: { ...y.initialArgs, ...f2 } };
    return y.unboundStoryFn(u);
  };
  return m.storyName = i2, m.args = y.initialArgs, m.play = y.playFunction, m.parameters = y.parameters, m;
}
function oo(e, r, t) {
  let { default: o, __esModule: n2, __namedExportsOrder: s2, ...i2 } = e;
  return Object.entries(i2).reduce((l, [y, d]) => isExportStory(y, o) ? Object.assign(l, { [y]: t(d, o, r, y) }) : l, {});
}
var Te = 1e3;
var Ae = 1e4;
var or = class {
  constructor() {
    this.getStoriesJsonData = () => {
      let { storyIndex: r } = this;
      if (!r)
        throw new Error("getStoriesJsonData called before initialization");
      let t = this.getSetStoriesPayload(), o = ["fileName", "docsOnly", "framework", "__id", "__isArgsStory"], n2 = (0, import_mapValues.default)(t.stories, (s2) => {
        let { importPath: i2 } = r.entries[s2.id];
        return { ...(0, import_pick.default)(s2, ["id", "name", "title"]), importPath: i2, kind: s2.title, story: s2.name, parameters: { ...(0, import_pick.default)(s2.parameters, o), fileName: i2 } };
      });
      return { v: 3, stories: n2 };
    };
    this.args = new G(), this.hooks = {}, this.processCSFFileWithCache = (0, import_memoizerific.default)(Te)(ur), this.prepareStoryWithCache = (0, import_memoizerific.default)(Ae)(V2), this.initializationPromise = new import_synchronous_promise.SynchronousPromise((r) => {
      this.resolveInitializationPromise = r;
    });
  }
  setProjectAnnotations(r) {
    this.projectAnnotations = v2(r);
    let { globals: t, globalTypes: o } = r;
    this.globals ? this.globals.set({ globals: t, globalTypes: o }) : this.globals = new D({ globals: t, globalTypes: o });
  }
  initialize({ storyIndex: r, importFn: t, cache: o = false }) {
    return this.storyIndex = new z(r), this.importFn = t, this.resolveInitializationPromise(), o ? this.cacheAllCSFFiles() : import_synchronous_promise.SynchronousPromise.resolve();
  }
  async onStoriesChanged({ importFn: r, storyIndex: t }) {
    await this.initializationPromise, r && (this.importFn = r), t && (this.storyIndex.entries = t.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  async storyIdToEntry(r) {
    return await this.initializationPromise, this.storyIndex.storyIdToEntry(r);
  }
  loadCSFFileByStoryId(r) {
    if (!this.storyIndex || !this.importFn)
      throw new Error("loadCSFFileByStoryId called before initialization");
    let { importPath: t, title: o } = this.storyIndex.storyIdToEntry(r);
    return this.importFn(t).then((n2) => this.processCSFFileWithCache(n2, t, o));
  }
  loadAllCSFFiles() {
    if (!this.storyIndex)
      throw new Error("loadAllCSFFiles called before initialization");
    let r = {};
    Object.entries(this.storyIndex.entries).forEach(([o, { importPath: n2 }]) => {
      r[n2] = o;
    });
    let t = Object.entries(r).map(([o, n2]) => this.loadCSFFileByStoryId(n2).then((s2) => ({ importPath: o, csfFile: s2 })));
    return import_synchronous_promise.SynchronousPromise.all(t).then((o) => o.reduce((n2, { importPath: s2, csfFile: i2 }) => (n2[s2] = i2, n2), {}));
  }
  cacheAllCSFFiles() {
    return this.initializationPromise.then(() => this.loadAllCSFFiles().then((r) => {
      this.cachedCSFFiles = r;
    }));
  }
  async loadStory({ storyId: r }) {
    await this.initializationPromise;
    let t = await this.loadCSFFileByStoryId(r);
    return this.storyFromCSFFile({ storyId: r, csfFile: t });
  }
  storyFromCSFFile({ storyId: r, csfFile: t }) {
    if (!this.projectAnnotations)
      throw new Error("storyFromCSFFile called before initialization");
    let o = t.stories[r];
    if (!o)
      throw new Error(`Didn't find '${r}' in CSF file, this is unexpected`);
    let n2 = t.meta, s2 = this.prepareStoryWithCache(o, n2, this.projectAnnotations);
    return this.args.setInitial(s2), this.hooks[s2.id] = this.hooks[s2.id] || new x(), s2;
  }
  componentStoriesFromCSFFile({ csfFile: r }) {
    if (!this.storyIndex)
      throw new Error("componentStoriesFromCSFFile called before initialization");
    return Object.keys(this.storyIndex.entries).filter((t) => !!r.stories[t]).map((t) => this.storyFromCSFFile({ storyId: t, csfFile: r }));
  }
  async loadEntry(r) {
    let t = await this.storyIdToEntry(r), { importFn: o, storyIndex: n2 } = this;
    if (!n2 || !o)
      throw new Error("loadEntry called before initialization");
    let s2 = t.type === "docs" ? t.storiesImports : [], [i2, ...a] = await Promise.all([o(t.importPath), ...s2.map((l) => {
      let y = n2.importPathToEntry(l);
      return this.loadCSFFileByStoryId(y.id);
    })]);
    return { entryExports: i2, csfFiles: a };
  }
  getStoryContext(r) {
    if (!this.globals)
      throw new Error("getStoryContext called before initialization");
    return { ...r, args: this.args.get(r.id), globals: this.globals.get(), hooks: this.hooks[r.id] };
  }
  cleanupStory(r) {
    this.hooks[r.id].clean();
  }
  extract(r = { includeDocsOnly: false }) {
    if (!this.storyIndex)
      throw new Error("extract called before initialization");
    let { cachedCSFFiles: t } = this;
    if (!t)
      throw new Error("Cannot call extract() unless you call cacheAllCSFFiles() first.");
    return Object.entries(this.storyIndex.entries).reduce((o, [n2, { type: s2, importPath: i2 }]) => {
      if (s2 === "docs")
        return o;
      let a = t[i2], l = this.storyFromCSFFile({ storyId: n2, csfFile: a });
      return !r.includeDocsOnly && l.parameters.docsOnly || (o[n2] = Object.entries(l).reduce((y, [d, m]) => d === "moduleExport" || typeof m == "function" ? y : Array.isArray(m) ? Object.assign(y, { [d]: m.slice().sort() }) : Object.assign(y, { [d]: m }), { args: l.initialArgs })), o;
    }, {});
  }
  getSetStoriesPayload() {
    if (!this.globals)
      throw new Error("getSetStoriesPayload called before initialization");
    let r = this.extract({ includeDocsOnly: true }), t = Object.values(r).reduce((o, { title: n2 }) => (o[n2] = {}, o), {});
    return { v: 2, globals: this.globals.get(), globalParameters: {}, kindParameters: t, stories: r };
  }
  getSetIndexPayload() {
    if (!this.storyIndex)
      throw new Error("getSetIndexPayload called before initialization");
    let r = this.extract({ includeDocsOnly: true });
    return { v: 4, entries: Object.fromEntries(Object.entries(this.storyIndex.entries).map(([t, o]) => [t, r[t] ? { ...o, args: r[t].initialArgs, initialArgs: r[t].initialArgs, argTypes: r[t].argTypes, parameters: r[t].parameters } : o])) };
  }
  raw() {
    return Object.values(this.extract()).map(({ id: r }) => this.fromId(r)).filter(Boolean);
  }
  fromId(r) {
    if (!this.storyIndex)
      throw new Error("fromId called before initialization");
    if (!this.cachedCSFFiles)
      throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");
    let t;
    try {
      ({ importPath: t } = this.storyIndex.storyIdToEntry(r));
    } catch {
      return null;
    }
    let o = this.cachedCSFFiles[t], n2 = this.storyFromCSFFile({ storyId: r, csfFile: o });
    return { ...n2, storyFn: (s2) => {
      let i2 = { ...this.getStoryContext(n2), viewMode: "story" };
      return n2.unboundStoryFn({ ...i2, ...s2 });
    } };
  }
};
function Ce(e, r) {
  let t = c.getChannel(), [o] = t.last(`${s}-manager-${e}`) || t.last(`${V}-manager-${e}`) || [], [n2, s2] = ie(o || r), i2 = se(() => ({ [`${s}-manager-${e}`]: (l) => s2(l), [`${V}-manager-${e}`]: (l) => s2(l) }), [e]), a = de(i2, [e]);
  return Y(() => {
    r !== void 0 && !o && a(`${V}-client-${e}`, r);
  }, [e]), [n2, (l) => {
    s2(l), a(`${s}-client-${e}`, l);
  }];
}
function Co(e, r) {
  return Ce(e, r);
}
var Ee = (e) => {
  let r = [...e], t = r[r.length - 1], o = t.indexOf("."), n2 = o > 0 ? t.substr(0, o) : t;
  r[r.length - 1] = n2;
  let [s2, ...i2] = r;
  return s2 === "" && (r = i2), r;
};
var Oe = /^index$/i;
var je = (e) => {
  let r;
  return e.filter((t, o) => o === e.length - 1 && (t === r || Oe.test(t)) ? false : (r = t, true));
};
function _r(e) {
  let r = new RegExp("/{1,}", "g");
  return e.join("/").replace(r, "/");
}
var ze = (e, r, t) => {
  let { directory: o, importPathMatcher: n2, titlePrefix: s2 = "" } = r || {};
  typeof e == "number" && n.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let i2 = (0, import_slash.default)(String(e));
  if (n2.exec(i2)) {
    if (!t) {
      let a = i2.replace(o, ""), y = (0, import_slash.default)(_r([s2, a])).split("/");
      return y = Ee(y), y = je(y), y.join("/");
    }
    return s2 ? (0, import_slash.default)(_r([s2, t])) : t;
  }
};
var jo = (e, r, t) => {
  for (let o = 0; o < r.length; o += 1) {
    let n2 = ze(e, r[o], t);
    if (n2)
      return n2;
  }
  return t || void 0;
};
var kr = /\s*\/\s*/;
var Cr = (e = {}) => (r, t) => {
  if (r.title === t.title && !e.includeNames)
    return 0;
  let o = e.method || "configure", n2 = e.order || [], s2 = r.title.trim().split(kr), i2 = t.title.trim().split(kr);
  e.includeNames && (s2.push(r.name), i2.push(t.name));
  let a = 0;
  for (; s2[a] || i2[a]; ) {
    if (!s2[a])
      return -1;
    if (!i2[a])
      return 1;
    let l = s2[a], y = i2[a];
    if (l !== y) {
      let m = n2.indexOf(l), f2 = n2.indexOf(y), u = n2.indexOf("*");
      return m !== -1 || f2 !== -1 ? (m === -1 && (u !== -1 ? m = u : m = n2.length), f2 === -1 && (u !== -1 ? f2 = u : f2 = n2.length), m - f2) : o === "configure" ? 0 : l.localeCompare(y, e.locales ? e.locales : void 0, { numeric: true, sensitivity: "accent" });
    }
    let d = n2.indexOf(l);
    d === -1 && (d = n2.indexOf("*")), n2 = d !== -1 && Array.isArray(n2[d + 1]) ? n2[d + 1] : [], a += 1;
  }
  return 0;
};
var Ir = (e, r, t) => {
  if (r) {
    let o;
    typeof r == "function" ? o = r : o = Cr(r), e.sort(o);
  } else
    e.sort((o, n2) => t.indexOf(o.importPath) - t.indexOf(n2.importPath));
  return e;
};
var Go = (e, r, t) => {
  try {
    return Ir(e, r, t);
  } catch (o) {
    throw new Error(dedent`
    Error sorting stories with sort parameter ${r}:

    > ${o.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
};
var Pr = (e) => {
  let { id: r, title: t, name: o, parameters: n2, type: s2 } = e;
  return { id: r, title: t, name: o, importPath: n2.fileName, type: s2 };
};
var Do = (e, r, t) => {
  if (r && typeof r == "function")
    return e.sort(r), e.map((n2) => Pr(n2[1]));
  let o = e.map((n2) => Pr(n2[1]));
  return Ir(o, r, t);
};

export {
  dequal,
  cr,
  B,
  dr,
  b,
  _,
  R,
  q,
  ve,
  k,
  Hr,
  w,
  M,
  $,
  ur,
  F,
  oe,
  ne2 as ne,
  gr,
  V2 as V,
  rr,
  L,
  v2 as v,
  Tr,
  O,
  W,
  H,
  er,
  Ar,
  eo,
  to,
  oo,
  or,
  Ce,
  Co,
  ze,
  jo,
  Go,
  Do
};
//# sourceMappingURL=chunk-ZQ2CAHCN.js.map
