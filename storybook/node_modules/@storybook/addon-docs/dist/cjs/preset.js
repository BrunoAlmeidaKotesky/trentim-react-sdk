"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storyIndexers = exports.docs = void 0;
exports.webpack = webpack;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _remarkSlug = _interopRequireDefault(require("remark-slug"));

var _remarkExternalLinks = _interopRequireDefault(require("remark-external-links"));

var _tsDedent = require("ts-dedent");

var _csfTools = require("@storybook/csf-tools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function createBabelOptions({
  babelOptions,
  mdxBabelOptions,
  configureJSX
}) {
  const babelPlugins = (mdxBabelOptions === null || mdxBabelOptions === void 0 ? void 0 : mdxBabelOptions.plugins) || (babelOptions === null || babelOptions === void 0 ? void 0 : babelOptions.plugins) || [];
  const filteredBabelPlugins = babelPlugins.filter(p => {
    const name = Array.isArray(p) ? p[0] : p;

    if (typeof name === 'string') {
      return !name.includes('plugin-transform-react-jsx');
    }

    return true;
  });
  const jsxPlugin = [require.resolve('@babel/plugin-transform-react-jsx'), {
    pragma: 'React.createElement',
    pragmaFrag: 'React.Fragment'
  }];
  const plugins = configureJSX ? [...filteredBabelPlugins, jsxPlugin] : babelPlugins;
  return Object.assign({
    // don't use the root babelrc by default (users can override this in mdxBabelOptions)
    babelrc: false,
    configFile: false
  }, babelOptions, mdxBabelOptions, {
    plugins
  });
}

async function webpack(webpackConfig = {}, options) {
  const resolvedBabelLoader = await options.presets.apply('babelLoaderRef');
  const {
    module = {}
  } = webpackConfig; // it will reuse babel options that are already in use in storybook
  // also, these babel options are chained with other presets.

  const {
    babelOptions,
    mdxBabelOptions,
    configureJSX = true,
    csfPluginOptions = {},
    sourceLoaderOptions = null,
    transcludeMarkdown = false
  } = options;
  const mdxLoaderOptions = {
    // whether to skip storybook files, useful for docs only mdx or md files
    skipCsf: true,
    remarkPlugins: [_remarkSlug.default, _remarkExternalLinks.default]
  };

  if (sourceLoaderOptions) {
    throw new Error((0, _tsDedent.dedent)`
      Addon-docs no longer uses source-loader in 7.0.

      To update your configuration, please see migration instructions here:

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#dropped-source-loader--storiesof-static-snippets
    `);
  }

  const mdxLoader = require.resolve('@storybook/mdx2-csf/loader');

  let rules = module.rules || [];

  if (transcludeMarkdown) {
    rules = [...rules.filter(rule => {
      var _rule$test;

      return ((_rule$test = rule.test) === null || _rule$test === void 0 ? void 0 : _rule$test.toString()) !== '/\\.md$/';
    }), {
      test: /\.md$/,
      use: [{
        loader: resolvedBabelLoader,
        options: createBabelOptions({
          babelOptions,
          mdxBabelOptions,
          configureJSX
        })
      }, {
        loader: mdxLoader,
        options: mdxLoaderOptions
      }]
    }];
  }

  const result = Object.assign({}, webpackConfig, {
    plugins: [...(webpackConfig.plugins || []), // eslint-disable-next-line global-require
    ...(csfPluginOptions ? [require('@storybook/csf-plugin').webpack(csfPluginOptions)] : [])],
    module: Object.assign({}, module, {
      rules: [...rules, {
        test: /(stories|story)\.mdx$/,
        use: [{
          loader: resolvedBabelLoader,
          options: createBabelOptions({
            babelOptions,
            mdxBabelOptions,
            configureJSX
          })
        }, {
          loader: mdxLoader,
          options: Object.assign({}, mdxLoaderOptions, {
            skipCsf: false
          })
        }]
      }, {
        test: /\.mdx$/,
        exclude: /(stories|story)\.mdx$/,
        use: [{
          loader: resolvedBabelLoader,
          options: createBabelOptions({
            babelOptions,
            mdxBabelOptions,
            configureJSX
          })
        }, {
          loader: mdxLoader,
          options: mdxLoaderOptions
        }]
      }]
    })
  });
  return result;
}

const storyIndexers = indexers => {
  const mdxIndexer = async (fileName, opts) => {
    let code = (await _fsExtra.default.readFile(fileName, 'utf-8')).toString();
    const {
      compile
    } = await Promise.resolve().then(() => _interopRequireWildcard(require('@storybook/mdx2-csf')));
    code = await compile(code, {});
    return (0, _csfTools.loadCsf)(code, Object.assign({}, opts, {
      fileName
    })).parse();
  };

  return [{
    test: /(stories|story)\.mdx$/,
    indexer: mdxIndexer
  }, ...(indexers || [])];
};

exports.storyIndexers = storyIndexers;

const docs = docsOptions => {
  return Object.assign({}, docsOptions, {
    enabled: true,
    defaultName: 'Docs',
    docsPage: true
  });
};

exports.docs = docs;