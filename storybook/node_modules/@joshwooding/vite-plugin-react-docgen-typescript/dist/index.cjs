'use strict';

const pluginutils = require('@rollup/pluginutils');
const docGen = require('react-docgen-typescript');
const ts = require('typescript');
const glob = require('glob-promise');
const path = require('path');
const MagicString = require('magic-string');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n["default"] = e;
  return n;
}

const docGen__namespace = /*#__PURE__*/_interopNamespace(docGen);
const ts__namespace = /*#__PURE__*/_interopNamespace(ts);
const glob__default = /*#__PURE__*/_interopDefaultLegacy(glob);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const path__namespace = /*#__PURE__*/_interopNamespace(path);
const MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);

function createLiteral(value) {
  switch (typeof value) {
    case "string":
      return ts__namespace.factory.createStringLiteral(value);
    case "number":
      return ts__namespace.factory.createNumericLiteral(value);
    case "boolean":
      return Boolean(value) ? ts__namespace.factory.createTrue() : ts__namespace.factory.createFalse();
  }
}
function insertTsIgnoreBeforeStatement(statement) {
  ts__namespace.setSyntheticLeadingComments(statement, [
    {
      text: " @ts-ignore",
      kind: ts__namespace.SyntaxKind.SingleLineCommentTrivia,
      pos: -1,
      end: -1
    }
  ]);
  return statement;
}
function setDisplayName(d) {
  return insertTsIgnoreBeforeStatement(ts__namespace.factory.createExpressionStatement(ts__namespace.factory.createBinaryExpression(ts__namespace.factory.createPropertyAccessExpression(ts__namespace.factory.createIdentifier(d.displayName), ts__namespace.factory.createIdentifier("displayName")), ts__namespace.SyntaxKind.EqualsToken, ts__namespace.factory.createStringLiteral(d.displayName))));
}
function createPropDefinition(propName, prop, options) {
  const setDefaultValue = (defaultValue) => ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral("defaultValue"), defaultValue?.value !== void 0 && (typeof defaultValue.value === "string" || typeof defaultValue.value === "number" || typeof defaultValue.value === "boolean") ? ts__namespace.factory.createObjectLiteralExpression([
    ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createIdentifier("value"), createLiteral(defaultValue.value))
  ]) : ts__namespace.factory.createNull());
  const setStringLiteralField = (fieldName, fieldValue) => ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral(fieldName), ts__namespace.factory.createStringLiteral(fieldValue));
  const setDescription = (description) => setStringLiteralField("description", description);
  const setName = (name) => setStringLiteralField("name", name);
  const setRequired = (required) => ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral("required"), required ? ts__namespace.factory.createTrue() : ts__namespace.factory.createFalse());
  const setValue = (typeValue) => Array.isArray(typeValue) && typeValue.every((value) => typeof value.value === "string") ? ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral("value"), ts__namespace.factory.createArrayLiteralExpression(typeValue.map((value) => ts__namespace.factory.createObjectLiteralExpression([
    setStringLiteralField("value", value.value)
  ])))) : void 0;
  const setType = (typeName, typeValue) => {
    const objectFields = [setStringLiteralField("name", typeName)];
    const valueField = setValue(typeValue);
    if (valueField) {
      objectFields.push(valueField);
    }
    return ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral(options.typePropName), ts__namespace.factory.createObjectLiteralExpression(objectFields));
  };
  return ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral(propName), ts__namespace.factory.createObjectLiteralExpression([
    setDefaultValue(prop.defaultValue),
    setDescription(prop.description),
    setName(prop.name),
    setRequired(prop.required),
    setType(prop.type.name, prop.type.value)
  ]));
}
function insertDocgenIntoGlobalCollection(d, docgenCollectionName, relativeFilename) {
  return insertTsIgnoreBeforeStatement(ts__namespace.factory.createIfStatement(ts__namespace.factory.createBinaryExpression(ts__namespace.factory.createTypeOfExpression(ts__namespace.factory.createIdentifier(docgenCollectionName)), ts__namespace.SyntaxKind.ExclamationEqualsEqualsToken, ts__namespace.factory.createStringLiteral("undefined")), insertTsIgnoreBeforeStatement(ts__namespace.factory.createExpressionStatement(ts__namespace.factory.createBinaryExpression(ts__namespace.factory.createElementAccessExpression(ts__namespace.factory.createIdentifier(docgenCollectionName), ts__namespace.factory.createStringLiteral(`${relativeFilename}#${d.displayName}`)), ts__namespace.SyntaxKind.EqualsToken, ts__namespace.factory.createObjectLiteralExpression([
    ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createIdentifier("docgenInfo"), ts__namespace.factory.createPropertyAccessExpression(ts__namespace.factory.createIdentifier(d.displayName), ts__namespace.factory.createIdentifier("__docgenInfo"))),
    ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createIdentifier("name"), ts__namespace.factory.createStringLiteral(d.displayName)),
    ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createIdentifier("path"), ts__namespace.factory.createStringLiteral(`${relativeFilename}#${d.displayName}`))
  ]))))));
}
function setComponentDocGen(d, options) {
  return insertTsIgnoreBeforeStatement(ts__namespace.factory.createExpressionStatement(ts__namespace.factory.createBinaryExpression(ts__namespace.factory.createPropertyAccessExpression(ts__namespace.factory.createIdentifier(d.displayName), ts__namespace.factory.createIdentifier("__docgenInfo")), ts__namespace.SyntaxKind.EqualsToken, ts__namespace.factory.createObjectLiteralExpression([
    ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral("description"), ts__namespace.factory.createStringLiteral(d.description)),
    ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral("displayName"), ts__namespace.factory.createStringLiteral(d.displayName)),
    ts__namespace.factory.createPropertyAssignment(ts__namespace.factory.createStringLiteral("props"), ts__namespace.factory.createObjectLiteralExpression(Object.entries(d.props).map(([propName, prop]) => createPropDefinition(propName, prop, options))))
  ]))));
}
function generateDocgenCodeBlock(options) {
  const sourceFile = ts__namespace.createSourceFile(options.filename, options.source, ts__namespace.ScriptTarget.ESNext);
  const relativeFilename = path__default.relative("./", path__default.resolve("./", options.filename)).replace(/\\/g, "/");
  const wrapInTryStatement = (statements) => ts__namespace.factory.createTryStatement(ts__namespace.factory.createBlock(statements, true), ts__namespace.factory.createCatchClause(ts__namespace.factory.createVariableDeclaration(ts__namespace.factory.createIdentifier("__react_docgen_typescript_loader_error")), ts__namespace.factory.createBlock([])), void 0);
  const codeBlocks = options.componentDocs.map((d) => wrapInTryStatement([
    options.setDisplayName ? setDisplayName(d) : null,
    setComponentDocGen(d, options),
    options.docgenCollectionName === null || options.docgenCollectionName === void 0 ? null : insertDocgenIntoGlobalCollection(d, options.docgenCollectionName, relativeFilename)
  ].filter((s2) => s2 !== null)));
  const printer = ts__namespace.createPrinter({ newLine: ts__namespace.NewLineKind.LineFeed });
  const printNode = (sourceNode) => printer.printNode(ts__namespace.EmitHint.Unspecified, sourceNode, sourceFile);
  const s = new MagicString__default(options.source);
  codeBlocks.forEach((node) => {
    s.append(printNode(node));
  });
  return {
    code: s.toString(),
    map: s.generateMap()
  };
}

function getTSConfigFile(tsconfigPath) {
  try {
    const basePath = path__namespace.dirname(tsconfigPath);
    const configFile = ts__namespace.readConfigFile(tsconfigPath, ts__namespace.sys.readFile);
    return ts__namespace.parseJsonConfigFileContent(configFile.config, ts__namespace.sys, basePath, {}, tsconfigPath);
  } catch (error) {
    return {};
  }
}
const defaultPropFilter = (prop) => {
  return !prop.parent?.fileName.includes("node_modules");
};
function getOptions(options) {
  const {
    tsconfigPath = "./tsconfig.json",
    compilerOptions: userCompilerOptions,
    docgenCollectionName = "STORYBOOK_REACT_CLASSES",
    setDisplayName = true,
    typePropName = "type",
    propFilter = defaultPropFilter,
    ...docgenOptions
  } = options;
  let compilerOptions = {
    jsx: ts__namespace.JsxEmit.React,
    module: ts__namespace.ModuleKind.CommonJS,
    target: ts__namespace.ScriptTarget.Latest
  };
  if (userCompilerOptions) {
    compilerOptions = {
      ...compilerOptions,
      ...userCompilerOptions
    };
  } else {
    const { options: tsOptions } = getTSConfigFile(tsconfigPath);
    compilerOptions = { ...compilerOptions, ...tsOptions };
  }
  return {
    docgenOptions: {
      propFilter,
      ...docgenOptions
    },
    generateOptions: {
      docgenCollectionName,
      setDisplayName,
      typePropName
    },
    compilerOptions
  };
}
function reactDocgenTypescript(config = {}) {
  const { docgenOptions, compilerOptions, generateOptions } = getOptions(config);
  const docGenParser = docGen__namespace.withCompilerOptions(compilerOptions, docgenOptions);
  const { exclude = ["**/**.stories.tsx"], include = ["**/**.tsx"] } = docgenOptions;
  const filter = pluginutils.createFilter(include, exclude);
  const files = include.map((filePath) => glob__default.sync(path__namespace.isAbsolute(filePath) ? filePath : path__namespace.join(process.cwd(), filePath))).reduce((carry, files2) => carry.concat(files2), []);
  const tsProgram = ts__namespace.createProgram(files, compilerOptions);
  return {
    name: "vite:react-docgen-typescript",
    async transform(src, id) {
      if (!filter(id))
        return;
      const componentDocs = docGenParser.parseWithProgramProvider(id, () => tsProgram);
      if (!componentDocs.length) {
        return null;
      }
      return generateDocgenCodeBlock({
        filename: id,
        source: src,
        componentDocs,
        ...generateOptions
      });
    }
  };
}

module.exports = reactDocgenTypescript;
