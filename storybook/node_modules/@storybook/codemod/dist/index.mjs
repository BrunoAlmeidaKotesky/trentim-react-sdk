import u from"fs";import x from"path";import{promisify as w}from"util";import $ from"globby";import{sync as I}from"cross-spawn";import N from"lodash/camelCase";import C from"lodash/upperFirst";function m(t){let i={babylon:"babel",flow:"flow",ts:"typescript",tsx:"typescript"};return t&&i[t]||"babel"}var l={"@kadira/react-storybook-decorator-centered":"@storybook/addon-centered","@kadira/storybook-addons":"@storybook/addons","@kadira/storybook-addon-actions":"@storybook/addon-actions","@kadira/storybook-addon-comments":"@storybook/addon-comments","@kadira/storybook-addon-graphql":"@storybook/addon-graphql","@kadira/storybook-addon-info":"@storybook/addon-info","@kadira/storybook-addon-knobs":"@storybook/addon-knobs","@kadira/storybook-addon-links":"@storybook/addon-links","@kadira/storybook-addon-notes":"@storybook/addon-notes","@kadira/storybook-addon-options":"@storybook/addon-options","@kadira/storybook-channels":"@storybook/channels","@kadira/storybook-channel-postmsg":"@storybook/channel-postmessage","@kadira/storybook-channel-websocket":"@storybook/channel-websocket","@kadira/storybook-ui":"@storybook/manager","@kadira/react-native-storybook":"@storybook/react-native","@kadira/react-storybook":"@storybook/react","@kadira/getstorybook":"@storybook/cli","@kadira/storybook":"@storybook/react",storyshots:"@storybook/addon-storyshots",getstorybook:"@storybook/cli"};function y(t,i){let o=i.jscodeshift,d=Object.keys(l),a=e=>d.find(r=>e.match(r)),c=e=>{let r=a(e);if(r){let n=l[r];return e.replace(r,n)}return e},f=e=>(e.node.source.value=c(e.node.source.value),e.node);return o(t.source).find(o.ImportDeclaration).replaceWith(f).toSource({quote:"single"})}function b(t,i){let o=i.jscodeshift,d=o(t.source),a=r=>r[3]===void 0?r[2]===void 0?[r[0]]:[r[1]]:[o.objectExpression([o.property("init",o.identifier("text"),r[1]),...r[3].properties])],c=r=>{let{node:n}=r,s=n.arguments,p=s[2]?s[2]:s[1];return n.callee.property.name="add",n.arguments=[s[0],o.callExpression(o.callExpression(o.identifier("withInfo"),a(s)),[p])],n},f=()=>{d.find(o.ImportDeclaration).filter(n=>n.node.source.value==="@storybook/addon-info").size()||d.find(o.ImportDeclaration).at(-1).insertAfter(o.importDeclaration([o.importSpecifier(o.identifier("withInfo"))],o.literal("@storybook/addon-info")))},e=d.find(o.CallExpression,{callee:{property:{name:"addWithInfo"}}});return e.size()&&(f(),e.replaceWith(c)),d.toSource()}var h=`${__dirname}/transforms`;function j(){return u.readdirSync(h).filter(t=>t.endsWith(".js")).map(t=>t.slice(0,-3))}var E=w(u.rename);async function P(t,i,o,{logger:d}){let a=t.replace(i,o);return d.log(`Rename: ${t} ${a}`),E(t,a)}async function M(t,{glob:i,logger:o,dryRun:d,rename:a,parser:c}){if(!j().includes(t))throw new Error(`Unknown codemod ${t}. Run --list for options.`);let e=null;if(a&&(e=a.split(":"),e.length!==2))throw new Error(`Codemod rename: expected format "from:to", got "${a}"`);let r=c;if(!c){let s=x.extname(i).slice(1);m(s)!=="babel"&&(r=s)}let n=await $([i,"!**/node_modules","!**/dist"]);if(o.log(`=> Applying ${t}: ${n.length} files`),!d){let s=r?["--parser",r]:[];I("npx",["jscodeshift","-t",`${h}/${t}.js`,...s,...n],{stdio:"inherit",shell:!0})}if(e){let[s,p]=e;o.log(`=> Renaming ${a}: ${n.length} files`),await Promise.all(n.map(g=>P(g,new RegExp(`${s}$`),p,{logger:o})))}}export{j as listCodemods,l as packageNames,M as runCodemod,b as updateAddonInfo,y as updateOrganisationName};
