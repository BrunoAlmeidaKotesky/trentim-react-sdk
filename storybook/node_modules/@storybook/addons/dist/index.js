var P=Object.create;var p=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var M=Object.getOwnPropertyNames;var U=Object.getPrototypeOf,$=Object.prototype.hasOwnProperty;var K=(t,e)=>{for(var r in e)p(t,r,{get:e[r],enumerable:!0})},C=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of M(e))!$.call(t,o)&&o!==r&&p(t,o,{get:()=>e[o],enumerable:!(n=I(e,o))||n.enumerable});return t};var O=(t,e,r)=>(r=t!=null?P(U(t)):{},C(e||!t||!t.__esModule?p(r,"default",{value:t,enumerable:!0}):r,t)),Y=t=>C(p({},"__esModule",{value:!0}),t);var ae={};K(ae,{AddonStore:()=>k,HooksContext:()=>w,addons:()=>c,applyHooks:()=>W,default:()=>se,isSupportedType:()=>j,makeDecorator:()=>B,mockChannel:()=>A,types:()=>y.Addon_TypesEnum,useArgs:()=>oe,useCallback:()=>f,useChannel:()=>te,useEffect:()=>L,useGlobals:()=>ne,useMemo:()=>J,useParameter:()=>re,useReducer:()=>ee,useRef:()=>Q,useState:()=>Z,useStoryContext:()=>g});module.exports=Y(ae);var m=O(require("global")),F=require("@storybook/core-events"),y=require("@storybook/types"),_=require("@storybook/client-logger");var b=require("@storybook/channels");function A(){let t={setHandler:()=>{},send:()=>{}};return new b.Channel({transport:t})}function j(t){return!!Object.values(y.Addon_TypesEnum).find(e=>e===t)}var k=class{constructor(){this.loaders={};this.elements={};this.config={};this.getChannel=()=>(this.channel||this.setChannel(A()),this.channel);this.getServerChannel=()=>{if(!this.serverChannel)throw new Error("Accessing non-existent serverChannel");return this.serverChannel};this.ready=()=>this.promise;this.hasChannel=()=>!!this.channel;this.hasServerChannel=()=>!!this.serverChannel;this.setChannel=e=>{this.channel=e,this.resolve()};this.setServerChannel=e=>{this.serverChannel=e};this.getElements=e=>(this.elements[e]||(this.elements[e]={}),this.elements[e]);this.addPanel=(e,r)=>{this.add(e,{type:y.Addon_TypesEnum.PANEL,...r})};this.add=(e,r)=>{let{type:n}=r,o=this.getElements(n);o[e]={id:e,...r}};this.setConfig=e=>{Object.assign(this.config,e),this.hasChannel()&&this.getChannel().emit(F.SET_CONFIG,e)};this.getConfig=()=>this.config;this.register=(e,r)=>{this.loaders[e]&&_.logger.warn(`${e} was loaded twice, this could have bad side-effects`),this.loaders[e]=r};this.loadAddons=e=>{Object.values(this.loaders).forEach(r=>r(e))};this.promise=new Promise(e=>{this.resolve=()=>e(this.getChannel())})}},v="__STORYBOOK_ADDONS";function G(){return m.default[v]||(m.default[v]=new k),m.default[v]}var c=G();var B=({name:t,parameterName:e,wrapper:r,skipIfNoParametersOrOptions:n=!1})=>{let o=s=>(a,d)=>{let u=d.parameters&&d.parameters[e];return u&&u.disable||n&&!s&&!u?a(d):r(a,d,{options:s,parameters:u})};return(...s)=>typeof s[0]=="function"?o()(...s):(...a)=>{if(a.length>1)return s.length>1?o(s)(...a):o(...s)(...a);throw new Error(`Passing stories directly into ${t}() is not allowed,
        instead use addDecorator(${t}) and pass options with the '${e}' parameter`)}};var l=O(require("global")),h=require("@storybook/client-logger"),i=require("@storybook/core-events");var w=class{constructor(){this.renderListener=e=>{e===this.currentContext.id&&(this.triggerEffects(),this.currentContext=null,this.removeRenderListeners())};this.init()}init(){this.hookListsMap=new WeakMap,this.mountedDecorators=new Set,this.prevMountedDecorators=this.mountedDecorators,this.currentHooks=[],this.nextHookIndex=0,this.currentPhase="NONE",this.currentEffects=[],this.prevEffects=[],this.currentDecoratorName=null,this.hasUpdates=!1,this.currentContext=null}clean(){this.prevEffects.forEach(e=>{e.destroy&&e.destroy()}),this.init(),this.removeRenderListeners()}getNextHook(){let e=this.currentHooks[this.nextHookIndex];return this.nextHookIndex+=1,e}triggerEffects(){this.prevEffects.forEach(e=>{!this.currentEffects.includes(e)&&e.destroy&&e.destroy()}),this.currentEffects.forEach(e=>{this.prevEffects.includes(e)||(e.destroy=e.create())}),this.prevEffects=this.currentEffects,this.currentEffects=[]}addRenderListeners(){this.removeRenderListeners(),c.getChannel().on(i.STORY_RENDERED,this.renderListener)}removeRenderListeners(){c.getChannel().removeListener(i.STORY_RENDERED,this.renderListener)}};function D(t){return(...e)=>{let{hooks:r}=typeof e[0]=="function"?e[1]:e[0],n=r.currentPhase,o=r.currentHooks,s=r.nextHookIndex,a=r.currentDecoratorName;r.currentDecoratorName=t.name,r.prevMountedDecorators.has(t)?(r.currentPhase="UPDATE",r.currentHooks=r.hookListsMap.get(t)||[]):(r.currentPhase="MOUNT",r.currentHooks=[],r.hookListsMap.set(t,r.currentHooks),r.prevMountedDecorators.add(t)),r.nextHookIndex=0;let d=l.default.STORYBOOK_HOOKS_CONTEXT;l.default.STORYBOOK_HOOKS_CONTEXT=r;let u=t(...e);if(l.default.STORYBOOK_HOOKS_CONTEXT=d,r.currentPhase==="UPDATE"&&r.getNextHook()!=null)throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");return r.currentPhase=n,r.currentHooks=o,r.nextHookIndex=s,r.currentDecoratorName=a,u}}var T=0,z=25,W=t=>(e,r)=>{let n=t(D(e),r.map(o=>D(o)));return o=>{let{hooks:s}=o;s.prevMountedDecorators=s.mountedDecorators,s.mountedDecorators=new Set([e,...r]),s.currentContext=o,s.hasUpdates=!1;let a=n(o);for(T=1;s.hasUpdates;)if(s.hasUpdates=!1,s.currentEffects=[],a=n(o),T+=1,T>z)throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");return s.addRenderListeners(),a}},X=(t,e)=>t.length===e.length&&t.every((r,n)=>r===e[n]),E=()=>new Error("Storybook preview hooks can only be called inside decorators and story functions.");function H(){return l.default.STORYBOOK_HOOKS_CONTEXT||null}function x(){let t=H();if(t==null)throw E();return t}function q(t,e,r){let n=x();if(n.currentPhase==="MOUNT"){r!=null&&!Array.isArray(r)&&h.logger.warn(`${t} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`);let o={name:t,deps:r};return n.currentHooks.push(o),e(o),o}if(n.currentPhase==="UPDATE"){let o=n.getNextHook();if(o==null)throw new Error("Rendered more hooks than during the previous render.");return o.name!==t&&h.logger.warn(`Storybook has detected a change in the order of Hooks${n.currentDecoratorName?` called by ${n.currentDecoratorName}`:""}. This will lead to bugs and errors if not fixed.`),r!=null&&o.deps==null&&h.logger.warn(`${t} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`),r!=null&&o.deps!=null&&r.length!==o.deps.length&&h.logger.warn(`The final argument passed to ${t} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${r}`),(r==null||o.deps==null||!X(r,o.deps))&&(e(o),o.deps=r),o}throw E()}function S(t,e,r){let{memoizedState:n}=q(t,o=>{o.memoizedState=e()},r);return n}function J(t,e){return S("useMemo",t,e)}function f(t,e){return S("useCallback",()=>t,e)}function R(t,e){return S(t,()=>({current:e}),[])}function Q(t){return R("useRef",t)}function V(){let t=H();if(t!=null&&t.currentPhase!=="NONE")t.hasUpdates=!0;else try{c.getChannel().emit(i.FORCE_RE_RENDER)}catch{h.logger.warn("State updates of Storybook preview hooks work only in browser")}}function N(t,e){let r=R(t,typeof e=="function"?e():e),n=o=>{r.current=typeof o=="function"?o(r.current):o,V()};return[r.current,n]}function Z(t){return N("useState",t)}function ee(t,e,r){let n=r!=null?()=>r(e):e,[o,s]=N("useReducer",n);return[o,d=>s(u=>t(u,d))]}function L(t,e){let r=x(),n=S("useEffect",()=>({create:t}),e);r.currentEffects.includes(n)||r.currentEffects.push(n)}function te(t,e=[]){let r=c.getChannel();return L(()=>(Object.entries(t).forEach(([n,o])=>r.on(n,o)),()=>{Object.entries(t).forEach(([n,o])=>r.removeListener(n,o))}),[...Object.keys(t),...e]),f(r.emit.bind(r),[r])}function g(){let{currentContext:t}=x();if(t==null)throw E();return t}function re(t,e){let{parameters:r}=g();if(t)return r[t]??e}function oe(){let t=c.getChannel(),{id:e,args:r}=g(),n=f(s=>t.emit(i.UPDATE_STORY_ARGS,{storyId:e,updatedArgs:s}),[t,e]),o=f(s=>t.emit(i.RESET_STORY_ARGS,{storyId:e,argNames:s}),[t,e]);return[r,n,o]}function ne(){let t=c.getChannel(),{globals:e}=g(),r=f(n=>t.emit(i.UPDATE_GLOBALS,{globals:n}),[t]);return[e,r]}var se=c;0&&(module.exports={AddonStore,HooksContext,addons,applyHooks,isSupportedType,makeDecorator,mockChannel,types,useArgs,useCallback,useChannel,useEffect,useGlobals,useMemo,useParameter,useReducer,useRef,useState,useStoryContext});
