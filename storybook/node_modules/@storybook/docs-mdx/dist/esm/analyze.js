import * as t from '@babel/types';
import toBabel from 'estree-to-babel';
import * as babelTraverse from '@babel/traverse';
import { compileSync } from '@mdx-js/mdx';
import { toEstree } from 'hast-util-to-estree';

const getAttr = (elt, what) => {
  const attr = elt.attributes.find(n => n.name.name === what);
  return attr;
};

const getAttrValue = (elt, what) => {
  var _getAttr;

  return (_getAttr = getAttr(elt, what)) === null || _getAttr === void 0 ? void 0 : _getAttr.value;
};

const extractTitle = (root, varToImport) => {
  const result = {
    title: undefined,
    of: undefined,
    name: undefined,
    isTemplate: false
  };
  let contents;
  root.program.body.forEach(child => {
    if (t.isExpressionStatement(child) && t.isJSXFragment(child.expression)) {
      if (contents) throw new Error('duplicate contents');
      contents = child;
    }
  });

  if (contents) {
    const jsx = contents.expression;
    jsx.children.forEach(child => {
      if (t.isJSXElement(child)) {
        if (t.isJSXIdentifier(child.openingElement.name)) {
          const name = child.openingElement.name.name;

          if (name === 'Meta') {
            if (result.title || result.name || result.of) {
              throw new Error('Meta can only be declared once');
            }

            const titleAttrValue = getAttrValue(child.openingElement, 'title');

            if (titleAttrValue) {
              if (t.isStringLiteral(titleAttrValue)) {
                result.title = titleAttrValue.value;
              } else {
                throw new Error(`Expected string literal title, received ${titleAttrValue.type}`);
              }
            }

            const nameAttrValue = getAttrValue(child.openingElement, 'name');

            if (nameAttrValue) {
              if (t.isStringLiteral(nameAttrValue)) {
                result.name = nameAttrValue.value;
              } else {
                throw new Error(`Expected string literal name, received ${nameAttrValue.type}`);
              }
            }

            const ofAttrValue = getAttrValue(child.openingElement, 'of');

            if (ofAttrValue) {
              if (t.isJSXExpressionContainer(ofAttrValue)) {
                const of = ofAttrValue.expression;

                if (t.isIdentifier(of)) {
                  const importName = varToImport[of.name];

                  if (importName) {
                    result.of = importName;
                  } else {
                    throw new Error(`Unknown identifier ${of.name}`);
                  }
                } else {
                  throw new Error(`Expected identifier, received ${of.type}`);
                }
              } else {
                throw new Error(`Expected JSX expression, received ${ofAttrValue.type}`);
              }
            }

            const isTemplateAttr = getAttr(child.openingElement, 'isTemplate');

            if (isTemplateAttr) {
              if (!isTemplateAttr.value) {
                // no value, implicit true
                result.isTemplate = true;
              } else if (t.isJSXExpressionContainer(isTemplateAttr.value)) {
                const isTemplate = isTemplateAttr.value.expression;

                if (t.isBooleanLiteral(isTemplate)) {
                  result.isTemplate = isTemplate.value;
                } else {
                  throw new Error(`Expected boolean isTemplate, received ${isTemplate.type}`);
                }
              } else {
                throw new Error(`Expected JSX expression isTemplate, received ${isTemplateAttr.value.type}`);
              }
            }
          }
        }
      } else if (t.isJSXExpressionContainer(child) && t.isStringLiteral(child.expression)) {// Skip string literals
      } else {
        throw new Error(`Unexpected JSX child: ${child.type}`);
      }
    });
  }

  return result;
};
/**
 * This is a hack to get around inconsistencies between
 * Babel's own weird interop code AND the typescript types (definitelyTyped)
 * and the fact that we're using `type: "module"` in this package
 * which has some weird behaviors
 */


const getTraverse = input => {
  switch (true) {
    case typeof input === 'function':
      {
        return input;
      }

    case typeof input.traverse === 'function':
      {
        return input.traverse;
      }

    case typeof input.default === 'function':
      {
        return input.default;
      }

    case typeof input.default.default === 'function':
      {
        return input.default.default;
      }

    default:
      {
        throw new Error(`Unable to get traverse function from ${input}`);
      }
  }
};

export const extractImports = root => {
  const varToImport = {};
  getTraverse(babelTraverse)(root, {
    ImportDeclaration: {
      enter({
        node
      }) {
        const {
          source,
          specifiers
        } = node;

        if (t.isStringLiteral(source)) {
          specifiers.forEach(s => {
            varToImport[s.local.name] = source.value;
          });
        } else {
          throw new Error('MDX: unexpected import source');
        }
      }

    }
  });
  return varToImport;
};
export const plugin = store => root => {
  const imports = root.children.find(child => child.type === 'mdxjsEsm');
  let varToImport = {};

  if (imports) {
    varToImport = extractImports(toBabel(imports.data.estree));
  }

  const estree = store.toEstree(root); // toBabel mutates root, bug we don't need to clone it because
  // we're not using it again
  // const clone = cloneDeep(estree);

  const babel = toBabel(estree);
  const {
    title,
    of,
    name,
    isTemplate
  } = extractTitle(babel, varToImport);
  store.title = title;
  store.of = of;
  store.name = name;
  store.isTemplate = isTemplate;
  store.imports = Array.from(new Set(Object.values(varToImport)));
  return root;
};
export const analyze = code => {
  const store = {
    title: undefined,
    of: undefined,
    name: undefined,
    isTemplate: false,
    imports: undefined,
    toEstree
  };
  compileSync(code, {
    rehypePlugins: [[plugin, store]]
  });
  const {
    title,
    of,
    name,
    isTemplate,
    imports = []
  } = store;
  return {
    title,
    of,
    name,
    isTemplate,
    imports
  };
};